                <span id="toolboxIcon">üß∞</span>
                <span id="toolboxModeText">Toolbox</span>
                <span style="font-size:12px;color:var(--text-secondary)" id="toolboxCardCount">(0 cards)</span>
            </div>
            <div class="toolbox-controls">
                <button id="gridModeBtn" class="toolbox-btn mode-btn active" title="Grid Mode">üî≤</button>
                <button id="listModeBtn" class="toolbox-btn mode-btn" title="List Mode">üìã</button>
                <button id="clearToolboxBtn" class="toolbox-btn" title="Clear All">üóëÔ∏è</button>
                <button id="toolboxClose" class="toolbox-btn" title="Close">‚úï</button>
            </div>
        </div>
        <div class="content" id="toolboxContent">
            <div class="toolbox-empty">
                <div class="toolbox-empty-icon">üß∞</div>
                <h3 style="color:var(--accent);margin-bottom:8px;">Empty Toolbox</h3>
                <p style="margin:0;">Add cards by clicking the + buttons on any card</p>
            </div>
        </div>
    </div>

    <!-- Main Header -->
    <header class="main-header">
        <h1>The Most Useful Site in the World</h1>
        <p class="subtitle">Essential tools for productivity, creativity, and problem-solving. All free, no sign-ups required.</p>
        
        <div class="main-search-container">
            <div class="main-search-bar">
                <input type="text" id="mainSearchInput" placeholder="üîç Search tools, calculators, converters..." autocomplete="off">
                <button id="mainSearchBtn" class="main-search-btn">Search</button>
            </div>
            <div class="search-suggestions" id="searchSuggestions"></div>
        </div>
    </header>

    <!-- Card Grid -->
    <div id="dashboard" class="dashboard"></div>

    <script>
    // ===== CONFIGURATION =====
    const CONFIG = {
        GITHUB_REPO: 'mrpr0phecy/mrpr0phecy',
        GITHUB_PATH: 'cards',
        LOAD_DELAY: 50,
        STICKY_THRESHOLD: 100,
        NOTIFICATION_DURATION: 4000
    };

    // ===== STATE =====
    let allCards = [];
    let loadedCards = new Set();
    let cardRatings = {};
    let toolboxCards = [];
    let toolboxMode = 'grid';
    let expandedCards = new Set();
    let isSearching = false;
    let intersectionObserver = null;

    // Themes
    const themes = {
        'default': { bg1: '#0a0f14', bg2: '#141e28' },
        'deep-blue': { bg1: '#05080c', bg2: '#0f151f' },
        'deep-purple': { bg1: '#12081a', bg2: '#1f1229' },
        'deep-teal': { bg1: '#061616', bg2: '#0f2525' },
        'deep-red': { bg1: '#160606', bg2: '#251010' },
        'deep-forest': { bg1: '#081408', bg2: '#152015' },
        'deep-space': { bg1: '#000814', bg2: '#1a1a2e' }
    };

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', async () => {
        console.log('üöÄ Initializing...');
        
        // Show loading screen
        updateLoadingStatus('Loading preferences...', 10);
        
        loadSettings();
        setupEventListeners();
        setupStickyBar();
        setupFAB();
        setupToolbox();
        
        updateLoadingStatus('Fetching tools...', 30);
        
        // Load cards automatically - NO SCROLL NEEDED
        await loadCards();
        
        updateLoadingStatus('Ready!', 100);
        
        // Hide loading screen
        setTimeout(() => {
            document.getElementById('loadingSplash').classList.add('hidden');
            showNotification('Welcome! üéâ', 'All tools loaded and ready to use.', 'success');
        }, 500);
    });

    // ===== LOADING SCREEN =====
    function updateLoadingStatus(text, percent) {
        document.getElementById('loadingStatus').textContent = text;
        document.getElementById('loadingBarFill').style.width = percent + '%';
    }

    // ===== CARD LOADING - AUTO START =====
    async function loadCards() {
        try {
            const [owner, repo] = CONFIG.GITHUB_REPO.split('/');
            const url = `https://api.github.com/repos/${owner}/${repo}/contents/${CONFIG.GITHUB_PATH}`;
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`GitHub API: ${response.status}`);
            
            const data = await response.json();
            
            const cardFiles = data
                .filter(item => item.type === 'file' && item.name.endsWith('.html'))
                .map(item => item.name.replace('.html', ''))
                .sort();
            
            allCards = cardFiles;
            const dashboard = document.getElementById('dashboard');
            
            // Create placeholders with staggered animation
            cardFiles.forEach((cardName, index) => {
                const displayName = cardName.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                const card = document.createElement('div');
                card.className = 'card';
                card.dataset.name = cardName;
                card.dataset.displayName = displayName;
                card.style.animationDelay = `${index * 0.05}s`;
                
                card.innerHTML = `
                    <div class="card-header">
                        <h3>${displayName}</h3>
                        <div class="card-actions">
                            <button class="card-action-btn add-grid" title="Add to Grid">üî≤</button>
                            <button class="card-action-btn add-list" title="Add to List">üìã</button>
                            <button class="card-action-btn expand-card" title="Open">‚Üó</button>
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="card-loading">
                            <div class="card-loading-spinner"></div>
                        </div>
                        <div class="card-sandbox" id="sandbox-${cardName}"></div>
                    </div>
                `;
                
                dashboard.appendChild(card);
                
                // Load content immediately
                loadCardContent(card, cardName);
                
                // Setup buttons
                card.querySelector('.add-grid').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addToToolbox(cardName, 'grid');
                });
                
                card.querySelector('.add-list').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addToToolbox(cardName, 'list');
                });
                
                card.querySelector('.expand-card').addEventListener('click', () => {
                    window.open(`cards/${cardName}.html`, '_blank');
                });
            });
            
            // Setup intersection observer for lazy loading footer content
            setupIntersectionObserver();
            
        } catch (error) {
            console.error('Failed to load cards:', error);
            showNotification('Error loading tools', error.message, 'error');
        }
    }

    async function loadCardContent(card, cardName) {
        try {
            const response = await fetch(`cards/${cardName}.html`);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const html = await response.text();
            const sandbox = card.querySelector('.card-sandbox');
            const loading = card.querySelector('.card-loading');
            
            // Parse and clean
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            doc.querySelectorAll('script').forEach(s => s.remove());
            
            sandbox.innerHTML = doc.body.innerHTML;
            loading.remove();
            
            // Add footer
            addCardFooter(card, cardName);
            
            // Show card
            setTimeout(() => card.classList.add('visible'), 50);
            
        } catch (error) {
            console.error(`Failed to load ${cardName}:`, error);
            card.querySelector('.card-sandbox').innerHTML = `
                <div style="padding:40px;text-align:center;color:#ff6b6b;">
                    <div style="font-size:48px;margin-bottom:16px;">‚ö†Ô∏è</div>
                    <div>Failed to load</div>
                </div>
            `;
            card.classList.add('visible');
        }
    }

    function addCardFooter(card, cardName) {
        const footer = document.createElement('div');
        footer.className = 'card-footer';
        
        const rating = getRating(cardName);
        const percentage = calculatePercentage(rating);
        
        footer.innerHTML = `
            <div class="rating-display">
                <span class="rating-label">Useful:</span>
                <div class="rating-bar">
                    <div class="rating-fill" style="width:${percentage}%"></div>
                </div>
                <span class="rating-percentage">${percentage}%</span>
            </div>
            <div class="rating-buttons">
                <button class="rating-btn up" data-card="${cardName}">üëç</button>
                <button class="rating-btn down" data-card="${cardName}">üëé</button>
            </div>
            <div class="embed-section">
                <button class="embed-btn" data-card="${cardName}">üîó Embed</button>
            </div>
        `;
        
        footer.querySelector('.rating-btn.up').addEventListener('click', () => rateCard(cardName, 'up'));
        footer.querySelector('.rating-btn.down').addEventListener('click', () => rateCard(cardName, 'down'));
        footer.querySelector('.embed-btn').addEventListener('click', () => copyEmbed(cardName));
        
        card.appendChild(footer);
    }

    // ===== TOOLBOX SYSTEM =====
    function setupToolbox() {
        const toolbox = document.getElementById('toolbox');
        const titlebar = document.getElementById('toolboxTitle');
        
        // Dragging
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        titlebar.addEventListener('mousedown', (e) => {
            if (e.target.closest('button')) return;
            isDragging = true;
            const rect = toolbox.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);
        });
        
        function onDrag(e) {
            if (!isDragging) return;
            e.preventDefault();
            toolbox.style.left = `${e.clientX - dragOffset.x}px`;
            toolbox.style.top = `${e.clientY - dragOffset.y}px`;
            toolbox.style.right = 'auto';
        }
        
        function stopDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);
        }
        
        // Mode buttons
        document.getElementById('gridModeBtn').addEventListener('click', () => setToolboxMode('grid'));
        document.getElementById('listModeBtn').addEventListener('click', () => setToolboxMode('list'));
        document.getElementById('clearToolboxBtn').addEventListener('click', clearToolbox);
        document.getElementById('toolboxClose').addEventListener('click', closeToolbox);
    }

    function setToolboxMode(mode) {
        toolboxMode = mode;
        document.getElementById('gridModeBtn').classList.toggle('active', mode === 'grid');
        document.getElementById('listModeBtn').classList.toggle('active', mode === 'list');
        document.getElementById('toolbox').classList.toggle('grid-mode', mode === 'grid');
        document.getElementById('toolbox').classList.toggle('list-mode', mode === 'list');
        document.getElementById('toolboxModeText').textContent = mode === 'grid' ? 'Grid Mode' : 'List Mode';
        document.getElementById('toolboxIcon').textContent = mode === 'grid' ? 'üî≤' : 'üìã';
        renderToolbox();
        saveSettings();
    }

    function addToToolbox(cardName, mode) {
        if (toolboxCards.find(c => c.name === cardName)) {
            showNotification('Already in toolbox', `${cardName} is already added.`, 'warning');
            return;
        }
        
        const card = document.querySelector(`.card[data-name="${cardName}"]`);
        const content = card.querySelector('.card-sandbox').innerHTML;
        
        toolboxCards.push({ name: cardName, content, mode });
        
        if (mode !== toolboxMode) {
            setToolboxMode(mode);
        }
        
        openToolbox();
        renderToolbox();
        saveSettings();
        
        showNotification('Added to toolbox', `${cardName} added to ${mode} mode.`, 'success');
    }

    function renderToolbox() {
        const content = document.getElementById('toolboxContent');
        document.getElementById('toolboxCardCount').textContent = `(${toolboxCards.length} cards)`;
        
        if (toolboxCards.length === 0) {
            content.innerHTML = `
                <div class="toolbox-empty">
                    <div class="toolbox-empty-icon">üß∞</div>
                    <h3 style="color:var(--accent);margin-bottom:8px;">Empty Toolbox</h3>
                    <p>Add cards by clicking the grid/list buttons</p>
                </div>
            `;
            return;
        }
        
        if (toolboxMode === 'grid') {
            renderGridMode(content);
        } else {
            renderListMode(content);
        }
    }

    function renderGridMode(container) {
        container.innerHTML = '<div class="grid-mode-container"></div>';
        const grid = container.querySelector('.grid-mode-container');
        
        toolboxCards.forEach((card, index) => {
            const isExpanded = expandedCards.has(index);
            const el = document.createElement('div');
            el.className = `grid-mode-card ${isExpanded ? 'expanded' : ''}`;
            el.innerHTML = `
                <div class="grid-mode-card-header">
                    <h4>${card.name}</h4>
                    <div class="grid-mode-card-actions">
                        <button class="grid-mode-card-btn expand-btn">${isExpanded ? '‚àí' : '+'}</button>
                        <button class="grid-mode-card-btn remove-btn">‚úï</button>
                    </div>
                </div>
                <div class="grid-mode-card-content">
                    <div class="grid-mode-card-content-inner">${card.content}</div>
                </div>
            `;
            
            el.querySelector('.expand-btn').addEventListener('click', () => {
                expandedCards.has(index) ? expandedCards.delete(index) : expandedCards.add(index);
                renderToolbox();
            });
            
            el.querySelector('.remove-btn').addEventListener('click', () => {
                toolboxCards.splice(index, 1);
                renderToolbox();
                saveSettings();
            });
            
            grid.appendChild(el);
        });
    }

    function renderListMode(container) {
        container.innerHTML = '<div class="list-mode-container"></div>';
        const list = container.querySelector('.list-mode-container');
        
        toolboxCards.forEach((card, index) => {
            const isExpanded = expandedCards.has(index);
            const el = document.createElement('div');
            el.className = `list-mode-item ${isExpanded ? 'expanded' : ''}`;
            el.innerHTML = `
                <div class="list-mode-item-header">
                    <div class="list-mode-item-name">${card.name}</div>
                </div>
                <div class="list-mode-item-actions">
                    <button class="list-mode-item-btn expand-btn">${isExpanded ? '‚àí' : '+'}</button>
                    <button class="list-mode-item-btn remove">‚úï</button>
                </div>
                <div class="list-mode-item-content">${card.content}</div>
            `;
            
            el.querySelector('.list-mode-item-header').addEventListener('click', () => {
                expandedCards.has(index) ? expandedCards.delete(index) : expandedCards.add(index);
                renderToolbox();
            });
            
            el.querySelector('.expand-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                expandedCards.has(index) ? expandedCards.delete(index) : expandedCards.add(index);
                renderToolbox();
            });
            
            el.querySelector('.remove').addEventListener('click', (e) => {
                e.stopPropagation();
                toolboxCards.splice(index, 1);
                renderToolbox();
                saveSettings();
            });
            
            list.appendChild(el);
        });
    }

    function openToolbox() {
        document.getElementById('toolbox').classList.add('open');
        document.getElementById('stickyToolboxToggle').classList.add('active');
    }

    function closeToolbox() {
        document.getElementById('toolbox').classList.remove('open');
        document.getElementById('stickyToolboxToggle').classList.remove('active');
    }

    function clearToolbox() {
        if (toolboxCards.length === 0) return;
        if (confirm(`Clear all ${toolboxCards.length} cards?`)) {
            toolboxCards = [];
            expandedCards.clear();
            renderToolbox();
            saveSettings();
            showNotification('Toolbox cleared', 'All cards removed.', 'info');
        }
    }

    // ===== EVENT LISTENERS =====
    function setupEventListeners() {
        // Search
        const searchInput = document.getElementById('mainSearchInput');
        const stickySearch = document.getElementById('stickySearchInput');
        
        searchInput.addEventListener('input', (e) => {
            stickySearch.value = e.target.value;
            performSearch(e.target.value);
        });
        
        stickySearch.addEventListener('input', (e) => {
            searchInput.value = e.target.value;
            performSearch(e.target.value);
        });
        
        // Palette
        document.getElementById('stickyPaletteToggle').addEventListener('click', togglePalette);
        
        document.querySelectorAll('.palette-color').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.palette-color').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const color = btn.dataset.accent;
                document.documentElement.style.setProperty('--accent', color);
                saveSettings();
            });
        });
        
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyTheme(btn.dataset.theme);
            });
        });
        
        // Reader mode
        document.getElementById('stickyReaderToggle').addEventListener('click', () => {
            document.body.classList.toggle('reader-mode');
            const isOn = document.body.classList.contains('reader-mode');
            document.getElementById('stickyReaderToggle').classList.toggle('active', isOn);
            saveSettings();
        });
        
        // Toolbox toggle
        document.getElementById('stickyToolboxToggle').addEventListener('click', () => {
            const toolbox = document.getElementById('toolbox');
            toolbox.classList.contains('open') ? closeToolbox() : openToolbox();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 't': e.preventDefault(); toggleToolbox(); break;
                    case 'p': e.preventDefault(); togglePalette(); break;
                    case 'r': e.preventDefault(); toggleReader(); break;
                    case 'k': e.preventDefault(); searchInput.focus(); break;
                }
            }
            if (e.key === 'Escape') {
                closeToolbox();
                closePalette();
            }
        });
        
        // Close panels on outside click
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.panel') && !e.target.closest('.sticky-action-btn')) {
                closePalette();
            }
            if (!e.target.closest('#toolbox') && !e.target.closest('#stickyToolboxToggle')) {
                closeToolbox();
            }
        });
    }

    function setupStickyBar() {
        const bar = document.getElementById('stickyCommandBar');
        let lastScroll = 0;
        
        window.addEventListener('scroll', () => {
            const currentScroll = window.pageYOffset;
            if (currentScroll > CONFIG.STICKY_THRESHOLD) {
                bar.classList.add('visible');
            } else {
                bar.classList.remove('visible');
            }
            lastScroll = currentScroll;
        }, { passive: true });
    }

    function setupFAB() {
        const fab = document.getElementById('fabMain');
        const menu = document.getElementById('fabMenu');
        
        fab.addEventListener('click', () => {
            menu.classList.toggle('open');
            fab.style.transform = menu.classList.contains('open') ? 'rotate(45deg)' : '';
        });
        
        document.getElementById('fabScrollTop').addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
            menu.classList.remove('open');
            fab.style.transform = '';
        });
        
        document.getElementById('fabRandom').addEventListener('click', () => {
            const cards = document.querySelectorAll('.card.visible');
            if (cards.length > 0) {
                const random = cards[Math.floor(Math.random() * cards.length)];
                random.scrollIntoView({ behavior: 'smooth', block: 'center' });
                random.style.animation = 'pulse 0.5s';
                setTimeout(() => random.style.animation = '', 500);
            }
            menu.classList.remove('open');
            fab.style.transform = '';
        });
        
        document.getElementById('fabExport').addEventListener('click', () => {
            exportData();
            menu.classList.remove('open');
            fab.style.transform = '';
        });
    }

    // ===== SEARCH =====
    function performSearch(query) {
        query = query.toLowerCase().trim();
        const cards = document.querySelectorAll('.card');
        
        cards.forEach(card => {
            const name = card.dataset.name.toLowerCase();
            const displayName = card.dataset.displayName.toLowerCase();
            const matches = name.includes(query) || displayName.includes(query);
            card.style.display = matches ? '' : 'none';
        });
    }

    // ===== RATINGS =====
    function getRating(cardName) {
        return cardRatings[cardName] || { up: 0, down: 0 };
    }

    function calculatePercentage(rating) {
        const total = rating.up + rating.down;
        return total === 0 ? 0 : Math.round((rating.up / total) * 100);
    }

    function rateCard(cardName, type) {
        if (!cardRatings[cardName]) cardRatings[cardName] = { up: 0, down: 0 };
        cardRatings[cardName][type]++;
        saveSettings();
        
        // Update UI
        const card = document.querySelector(`.card[data-name="${cardName}"]`);
        if (card) {
            const footer = card.querySelector('.card-footer');
            footer.remove();
            addCardFooter(card, cardName);
        }
        
        showNotification('Thanks!', `You rated this tool ${type === 'up' ? 'üëç' : 'üëé'}`, 'success');
    }

    // ===== EMBED =====
    function copyEmbed(cardName) {
        const code = `<iframe src="${window.location.origin}/cards/${cardName}.html" width="100%" height="400" style="border:none;border-radius:12px;"></iframe>`;
        navigator.clipboard.writeText(code).then(() => {
            showNotification('Copied!', 'Embed code copied to clipboard.', 'success');
        });
    }

    // ===== NOTIFICATIONS =====
    function showNotification(title, message, type = 'info') {
        const container = document.getElementById('notificationContainer');
        const notif = document.createElement('div');
        notif.className = `notification ${type}`;
        
        const icons = { success: '‚úÖ', error: '‚ùå', warning: '‚ö†Ô∏è', info: '‚ÑπÔ∏è' };
        
        notif.innerHTML = `
            <span class="notification-icon">${icons[type]}</span>
            <div class="notification-content">
                <div class="notification-title">${title}</div>
                <div class="notification-message">${message}</div>
            </div>
            <button class="notification-close">‚úï</button>
        `;
        
        notif.querySelector('.notification-close').addEventListener('click', () => {
            notif.classList.add('hiding');
            setTimeout(() => notif.remove(), 300);
        });
        
        container.appendChild(notif);
        
        setTimeout(() => {
            notif.classList.add('hiding');
            setTimeout(() => notif.remove(), 300);
        }, CONFIG.NOTIFICATION_DURATION);
    }

    // ===== SETTINGS =====
    function loadSettings() {
        const saved = localStorage.getItem('usefulSiteSettings');
        if (saved) {
            const data = JSON.parse(saved);
            cardRatings = data.ratings || {};
            toolboxCards = data.toolbox || [];
            toolboxMode = data.toolboxMode || 'grid';
            
            if (data.accent) {
                document.documentElement.style.setProperty('--accent', data.accent);
            }
            if (data.theme) {
                applyTheme(data.theme);
            }
            if (data.readerMode) {
                document.body.classList.add('reader-mode');
            }
        }
    }

    function saveSettings() {
        const data = {
            ratings: cardRatings,
            toolbox: toolboxCards,
            toolboxMode: toolboxMode,
            accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
            theme: document.querySelector('.theme-btn.active')?.dataset.theme || 'default',
            readerMode: document.body.classList.contains('reader-mode')
        };
        localStorage.setItem('usefulSiteSettings', JSON.stringify(data));
    }

    function applyTheme(themeName) {
        const theme = themes[themeName];
        if (theme) {
            document.body.style.background = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
        }
    }

    function exportData() {
        const data = {
            ratings: cardRatings,
            toolbox: toolboxCards,
            exportedAt: new Date().toISOString()
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'useful-site-data.json';
        a.click();
        URL.revokeObjectURL(url);
        showNotification('Exported!', 'Your data has been downloaded.', 'success');
    }

    // ===== UTILITY =====
    function togglePalette() {
        document.getElementById('palettePanel').classList.toggle('open');
    }

    function closePalette() {
        document.getElementById('palettePanel').classList.remove('open');
    }

    function toggleToolbox() {
        const toolbox = document.getElementById('toolbox');
        toolbox.classList.contains('open') ? closeToolbox() : openToolbox();
    }

    function toggleReader() {
        document.body.classList.toggle('reader-mode');
        const isOn = document.body.classList.contains('reader-mode');
        document.getElementById('stickyReaderToggle').classList.toggle('active', isOn);
        saveSettings();
    }

    function setupIntersectionObserver() {
        const options = {
            root: null,
            rootMargin: '100px',
            threshold: 0.1
        };
        
        intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('visible');
                }
            });
        }, options);
        
        document.querySelectorAll('.card').forEach(card => {
            intersectionObserver.observe(card);
        });
    }
    </script>
</body>
</html>
