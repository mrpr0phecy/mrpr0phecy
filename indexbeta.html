<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  :root{
    --accent:#2dd4ff; --muted:#e6faff; --text:#e6faff;
    --bg-1:#0f1720; --bg-2:#1b2630;
    --glass: rgba(255,255,255,0.06);
    --panel: rgba(20,20,20,0.92);
    --card-grad-1: rgba(255,255,255,0.04);
    --card-grad-2: rgba(255,255,255,0.07);
    --border: rgba(255,255,255,0.10);
    --card-min: 260px;
    --card-scale: 1;
    --card-translateY: 18px;
    --toolbox-width: 520px;
    --toolbox-height: 420px;
  }

  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(135deg,var(--bg-1),var(--bg-2));color:var(--text);-webkit-font-smoothing:antialiased}
  header{padding:20px;text-align:center;z-index:2}
  header h1{margin:0;color:var(--accent);font-size:1.6rem}

  /* Controls */
  .control-btn{
    position:fixed;bottom:18px;z-index:14000;width:48px;height:48px;border-radius:10px;
    background:var(--glass);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;
    cursor:pointer;backdrop-filter:blur(6px);box-shadow:0 8px 30px rgba(0,0,0,0.45);color:var(--accent);
  }
  #toolboxToggle{left:18px}
  #paletteToggle{left:78px}
  #readerToggle{left:138px}

  /* Palette */
  .palette-panel{position:fixed;left:78px;bottom:74px;z-index:13900;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;display:none;pointer-events:none}
  .palette-panel.open{display:block;pointer-events:auto}

  /* Toolbox container (resizable) */
  .toolbox {
    position:fixed;
    right:18px;
    bottom:18px;
    width:var(--toolbox-width);
    height:var(--toolbox-height);
    z-index:13700;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:0 18px 48px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    resize:both;
    min-width:300px;
    min-height:200px;
  }
  .toolbox.hidden{display:none}

  .toolbox .titlebar{
    display:flex;align-items:center;justify-content:space-between;padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);cursor:grab;z-index:13750;
  }

  /* Toolbox content is a positioned canvas for freeform widgets */
  .toolbox .content{
    position:relative;
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    overflow:auto;
  }

  /* Freeform widget: absolutely positioned inside toolbox content */
  .widget-wrap{
    position:absolute;
    box-sizing:border-box;
    background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
    border-radius:10px;border:1px solid rgba(255,255,255,0.04);
    min-width:160px; min-height:100px;
    overflow:hidden;
    resize:both;
    z-index:1;
    box-shadow:0 8px 20px rgba(0,0,0,0.35);
  }

  .widget-titlebar{
    display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    cursor:move;
    user-select:none;
  }
  .widget-titlebar strong{color:var(--accent)}
  .widget-body{padding:10px;overflow:auto;max-height:60vh}

  .widget-close, #toolboxClose { z-index: 13800; position: relative; background:transparent;border:0;color:var(--muted);cursor:pointer }

  /* Grid / cards */
  main{position:relative;z-index:2}
  .search-bar{max-width:1100px;margin:14px auto 16px;display:flex;background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.02));border-radius:12px;padding:12px 16px;border:1px solid rgba(255,255,255,0.04)}
  .search-bar input{flex:1;border:none;background:transparent;color:var(--text);font-size:1rem;outline:none}

  .controls{display:flex;gap:8px;justify-content:center;margin-bottom:12px}
  .controls button{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted);cursor:pointer}

  .dashboard{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
    gap:20px;
    padding:20px;
    align-items:start;
    box-sizing:border-box;
  }

  /* Card placeholder ensures stable layout while lazy-loading */
  .card{
    box-sizing:border-box;
    background:linear-gradient(135deg,var(--card-grad-1),var(--card-grad-2));
    border:1px solid var(--border);
    border-radius:12px;
    padding:16px;
    min-height:120px; /* prevents collapse during fast scroll */
    backdrop-filter:blur(8px);
    width:100%;
    max-width:100%;
    opacity:0;
    transform: translateY(var(--card-translateY)) scale(var(--card-scale));
    transition:opacity .36s ease, transform .36s ease;
    box-shadow:0 8px 24px rgba(0,0,0,0.35);
    overflow:hidden;
  }
  .card.visible{opacity:1; transform: translateY(0) scale(var(--card-scale));}
  .card-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .card-header h3{margin:0;color:var(--accent);font-size:1.05rem}

  /* Reader mode */
  body.reader-mode{font-size:1.12rem;line-height:1.6}
  body.reader-mode .dashboard{grid-template-columns:1fr;gap:18px}
  body.reader-mode .card{padding:20px;background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));border-color:rgba(255,255,255,0.06)}
</style>
</head>
<body>

  <button id="toolboxToggle" class="control-btn" title="Open toolbox">ðŸ§°</button>
  <button id="paletteToggle" class="control-btn" title="Theme">ðŸŽ¨</button>
  <button id="readerToggle" class="control-btn" title="Reader mode">ðŸ‘“</button>

  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px">Accent color</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#00ff99" style="background:#00ff99;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd;height:34px;border-radius:8px;cursor:pointer"></div>
    </div>
  </div>

  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div style="font-weight:600;color:var(--accent)">Toolbox</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="dockBtn" title="Dock/undock">â‡±</button>
        <button id="toolboxClose" title="Close">âœ•</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite"></div>
  </div>

  <header><h1>The Most Useful Site in the World</h1></header>

  <main>
    <div class="search-bar"><input id="searchInput" placeholder="Search cards..." /></div>

    <div class="controls">
      <button id="sortAlphaBtn">Sort Aâ†’Z</button>
      <button id="sortRandomBtn">Random</button>
    </div>

    <div id="status" class="muted" style="text-align:center;margin-bottom:6px">Loading cards...</div>
    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
/* ---------- Repo loader (unchanged) ---------- */
const DEFAULT_REPO = 'mrpr0phecy/mrpr0phecy';
const DEFAULT_BRANCH = 'main';
function parseOwnerRepo(str){ const p = str.split('/'); return { owner: p[0], repo: p[1] }; }
async function fetchRepoTree(owner, repo, branch){
  const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('GitHub API error: ' + r.status);
  return r.json();
}
async function getCardFiles(owner, repo, branch){
  const data = await fetchRepoTree(owner, repo, branch);
  return (data.tree || []).filter(item => item.path.startsWith('cards/') && item.path.endsWith('.html')).map(item => item.path.replace(/^cards\//,''));
}

/* ---------- Card creation + robust lazy loading ---------- */
const grid = document.getElementById('gridContainer');
const cardLoadState = new WeakMap(); // track loaded cards

function createCardElement(file){
  const name = file.replace('.html','');
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.file = file;
  card.dataset.name = name;

  const header = document.createElement('div');
  header.className = 'card-header';
  const title = document.createElement('h3');
  title.textContent = name;
  const btnWrap = document.createElement('div');
  btnWrap.style.display = 'flex';
  btnWrap.style.gap = '8px';

  const addBtn = document.createElement('div');
  addBtn.className = 'add-to-toolbox';
  addBtn.title = 'Add to toolbox';
  addBtn.textContent = '+';
  addBtn.style.cursor = 'pointer';
  addBtn.addEventListener('click', (e) => { e.stopPropagation(); addToToolbox(file); });

  btnWrap.appendChild(addBtn);
  header.appendChild(title);
  header.appendChild(btnWrap);
  card.appendChild(header);

  const content = document.createElement('div');
  content.className = 'content';
  content.textContent = 'Loadingâ€¦';
  card.appendChild(content);

  // mark as not loaded
  cardLoadState.set(card, false);

  // observe with a generous rootMargin so fast scroll still triggers
  lazyObserver.observe(card);

  return card;
}

async function loadCardContentInto(card, file){
  if(cardLoadState.get(card)) return;
  try{
    const r = await fetch(`cards/${file}`);
    if(!r.ok){ card.querySelector('.content').textContent = 'Preview unavailable'; cardLoadState.set(card,true); return; }
    let html = await r.text();
    html = html.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
    html = html.replace(/<img\b([^>]*?)>/gi, (m, attrs) => /loading\s*=/.test(attrs) ? `<img${attrs}>` : `<img loading="lazy"${attrs}>`);
    card.querySelector('.content').innerHTML = html;
    cardLoadState.set(card,true);
  }catch(e){
    card.querySelector('.content').textContent = 'Failed to load';
    cardLoadState.set(card,true);
  }
}

/* IntersectionObserver with larger rootMargin and fallback checks */
const lazyObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    const el = entry.target;
    if(entry.isIntersecting || entry.intersectionRatio > 0){
      lazyObserver.unobserve(el);
      loadCardContentInto(el, el.dataset.file);
    }
  });
}, { root: null, rootMargin: '1200px 0px 1200px 0px', threshold: 0 });

/* Fallback manual check for very fast scrolls */
let manualCheckScheduled = false;
function manualVisibilityCheck(){
  manualCheckScheduled = false;
  document.querySelectorAll('#gridContainer .card').forEach(card => {
    if(cardLoadState.get(card)) return;
    const r = card.getBoundingClientRect();
    const buffer = 1200;
    if(r.bottom >= -buffer && r.top <= (window.innerHeight + buffer)){
      lazyObserver.unobserve(card);
      loadCardContentInto(card, card.dataset.file);
    }
  });
  // also use idle time to prefetch a few more cards
  if('requestIdleCallback' in window){
    requestIdleCallback(() => {
      document.querySelectorAll('#gridContainer .card').forEach(card => {
        if(cardLoadState.get(card)) return;
        const r = card.getBoundingClientRect();
        const buffer = 2400;
        if(r.bottom >= -buffer && r.top <= (window.innerHeight + buffer)){
          lazyObserver.unobserve(card);
          loadCardContentInto(card, card.dataset.file);
        }
      });
    }, {timeout:1000});
  }
}
window.addEventListener('scroll', () => {
  if(!manualCheckScheduled){
    manualCheckScheduled = true;
    requestAnimationFrame(manualVisibilityCheck);
  }
}, { passive: true });

window.addEventListener('resize', manualVisibilityCheck);
window.addEventListener('touchend', manualVisibilityCheck);

/* ---------- Toolbox freeform widgets ---------- */
const toolbox = document.getElementById('toolbox');
const toolboxContent = document.getElementById('toolboxContent');
const toolboxToggle = document.getElementById('toolboxToggle');
const toolboxClose = document.getElementById('toolboxClose');
const toolboxTitle = document.getElementById('toolboxTitle');
const dockBtn = document.getElementById('dockBtn');

let toolboxDocked = true;

/* restore toolbox state */
(function restoreToolbox(){
  try{
    const s = JSON.parse(localStorage.getItem('toolbox_state_v2') || '{}');
    if(s.width) toolbox.style.width = s.width + 'px';
    if(s.height) toolbox.style.height = s.height + 'px';
    if(s.left !== undefined && s.left !== null){
      toolbox.style.left = s.left + 'px';
      toolbox.style.top = s.top + 'px';
      toolbox.style.right = 'auto';
      toolbox.style.bottom = 'auto';
      toolboxDocked = false;
    }
  }catch(e){}
})();

toolboxToggle.addEventListener('click', () => {
  toolbox.classList.toggle('hidden');
  toolbox.classList.contains('hidden') ? toolbox.setAttribute('aria-hidden','true') : toolbox.setAttribute('aria-hidden','false');
});

/* Close always works, even when undocked */
toolboxClose.addEventListener('click', (e) => {
  e.stopPropagation();
  toolbox.classList.add('hidden');
  toolbox.setAttribute('aria-hidden','true');
  persistToolboxState();
});

/* Drag toolbox when undocked (titlebar) */
(function enableToolboxDrag(){
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
  toolboxTitle.addEventListener('pointerdown', (e) => {
    if(e.target.closest('button')) return;
    if(toolboxDocked) return;
    dragging = true;
    sx = e.clientX; sy = e.clientY;
    const rect = toolbox.getBoundingClientRect();
    startLeft = rect.left; startTop = rect.top;
    toolbox.style.transition = 'none';
    try{ toolbox.setPointerCapture(e.pointerId); }catch(_){}
  });
  window.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const dx = e.clientX - sx, dy = e.clientY - sy;
    toolbox.style.left = Math.max(8, startLeft + dx) + 'px';
    toolbox.style.top = Math.max(8, startTop + dy) + 'px';
    toolbox.style.right = 'auto'; toolbox.style.bottom = 'auto';
  });
  window.addEventListener('pointerup', (e) => {
    if(!dragging) return;
    dragging = false;
    toolbox.style.transition = '';
    try{ toolbox.releasePointerCapture(e.pointerId); }catch(_){}
    persistToolboxState();
  });
})();

/* Dock toggle */
dockBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  toolboxDocked = !toolboxDocked;
  if(toolboxDocked){
    toolbox.style.left = 'auto';
    toolbox.style.top = 'auto';
    toolbox.style.right = '18px';
    toolbox.style.bottom = '18px';
  } else {
    const rect = toolbox.getBoundingClientRect();
    toolbox.style.left = rect.left + 'px';
    toolbox.style.top = rect.top + 'px';
    toolbox.style.right = 'auto';
    toolbox.style.bottom = 'auto';
  }
  persistToolboxState();
});

/* Persist toolbox size/position */
function persistToolboxState(){
  try{
    const r = toolbox.getBoundingClientRect();
    const state = { width: Math.round(r.width), height: Math.round(r.height) };
    if(!toolboxDocked){ state.left = Math.round(r.left); state.top = Math.round(r.top); }
    localStorage.setItem('toolbox_state_v2', JSON.stringify(state));
  }catch(e){}
}
toolbox.addEventListener('pointerup', persistToolboxState);
window.addEventListener('resize', persistToolboxState);

/* ---------- Freeform widget creation: absolute position, draggable and resizable ---------- */
const TOOLBOX_KEY = 'toolbox_items_v2';
function loadToolboxStore(){ try { return JSON.parse(localStorage.getItem(TOOLBOX_KEY) || '[]'); } catch(e) { return []; } }
function saveToolboxStore(items){ localStorage.setItem(TOOLBOX_KEY, JSON.stringify(items)); }
let toolboxItems = loadToolboxStore().map(x => x.file) || []; // if stored as objects, map to file list

function createWidget(file, saved){
  const wrap = document.createElement('div');
  wrap.className = 'widget-wrap';
  wrap.dataset.file = file;

  // default size/position
  const defaultW = 320, defaultH = 200;
  const left = saved?.left ?? 12 + (Math.random()*40|0);
  const top = saved?.top ?? 12 + (Math.random()*40|0);
  const width = saved?.width ?? defaultW;
  const height = saved?.height ?? defaultH;

  wrap.style.left = left + 'px';
  wrap.style.top = top + 'px';
  wrap.style.width = width + 'px';
  wrap.style.height = height + 'px';

  const titlebar = document.createElement('div');
  titlebar.className = 'widget-titlebar';
  const title = document.createElement('strong');
  title.textContent = file.replace('.html','');
  const close = document.createElement('button');
  close.className = 'widget-close';
  close.innerHTML = 'âœ•';
  close.addEventListener('click', (e) => { e.stopPropagation(); removeFromToolbox(file); });
  titlebar.appendChild(title);
  titlebar.appendChild(close);

  const body = document.createElement('div');
  body.className = 'widget-body';
  body.textContent = 'Loadingâ€¦';

  wrap.appendChild(titlebar);
  wrap.appendChild(body);
  toolboxContent.appendChild(wrap);

  // load content
  (async function loadIntoWidget(f, container){
    try{
      const r = await fetch(`cards/${f}`);
      if(!r.ok){ container.textContent = 'Preview unavailable'; return; }
      let html = await r.text();
      html = html.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
      html = html.replace(/<img\b([^>]*?)>/gi, (m, attrs) => /loading\s*=/.test(attrs) ? `<img${attrs}>` : `<img loading="lazy"${attrs}>`);
      container.innerHTML = html;
    }catch(e){
      container.textContent = 'Failed to load';
    }
  })(file, body);

  // make widget draggable within toolboxContent by titlebar
  enableWidgetDrag(wrap, titlebar);

  // observe resize to persist (no hard clamp)
  observeWidgetResize(wrap);

  return wrap;
}

/* Dragging widgets inside toolboxContent */
function enableWidgetDrag(widget, handle){
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
  handle.addEventListener('pointerdown', (e) => {
    if(e.target.closest('button')) return;
    dragging = true;
    sx = e.clientX; sy = e.clientY;
    const rect = widget.getBoundingClientRect();
    const parentRect = toolboxContent.getBoundingClientRect();
    startLeft = rect.left - parentRect.left;
    startTop = rect.top - parentRect.top;
    widget.style.transition = 'none';
    try{ handle.setPointerCapture(e.pointerId); }catch(_){}
  });
  window.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const parentRect = toolboxContent.getBoundingClientRect();
    const dx = e.clientX - sx, dy = e.clientY - sy;
    let nx = Math.max(-2000, startLeft + dx); // allow moving beyond visible area if desired
    let ny = Math.max(-2000, startTop + dy);
    // do not forcibly clamp; allow free placement inside canvas (canvas will scroll)
    widget.style.left = nx + 'px';
    widget.style.top = ny + 'px';
  });
  window.addEventListener('pointerup', (e) => {
    if(!dragging) return;
    dragging = false;
    widget.style.transition = '';
    try{ handle.releasePointerCapture(e.pointerId); }catch(_){}
    persistWidgetsState();
  });
}

/* ResizeObserver to persist widget sizes (no clamping) */
let widgetResizeObserver = null;
function observeWidgetResize(widget){
  if(!widgetResizeObserver){
    widgetResizeObserver = new ResizeObserver(entries => {
      for(const entry of entries){
        persistWidgetsState();
      }
    });
  }
  widgetResizeObserver.observe(widget);
}

/* Persist widget positions/sizes */
function persistWidgetsState(){
  try{
    const items = [];
    toolboxContent.querySelectorAll('.widget-wrap').forEach(w => {
      items.push({
        file: w.dataset.file,
        left: Math.round(parseFloat(w.style.left || 0)),
        top: Math.round(parseFloat(w.style.top || 0)),
        width: Math.round(w.offsetWidth),
        height: Math.round(w.offsetHeight)
      });
    });
    saveToolboxStore(items);
  }catch(e){}
}

/* Render toolbox from store */
function renderToolboxPanel(){
  toolboxContent.innerHTML = '';
  const saved = loadToolboxStore();
  if(!toolboxItems || !toolboxItems.length){
    const empty = document.createElement('div');
    empty.className = 'muted';
    empty.style.padding = '12px';
    empty.textContent = 'No widgets pinned. Click + on a card to pin it here.';
    toolboxContent.appendChild(empty);
    return;
  }
  for(const file of toolboxItems){
    const s = (saved || []).find(x => x.file === file);
    createWidget(file, s);
  }
}

/* Add / remove widgets */
function addToToolbox(file){
  if(toolboxItems.includes(file)){ openToolbox(); return; }
  toolboxItems.unshift(file);
  if(toolboxItems.length > 80) toolboxItems.length = 80;
  saveToolboxStore(toolboxItems);
  renderToolboxPanel();
  openToolbox();
}
function removeFromToolbox(file){
  const idx = toolboxItems.indexOf(file);
  if(idx >= 0){ toolboxItems.splice(idx,1); saveToolboxStore(toolboxItems); renderToolboxPanel(); persistWidgetsState(); }
}
function openToolbox(){ toolbox.classList.remove('hidden'); toolbox.setAttribute('aria-hidden','false'); }

/* ---------- Palette handling ---------- */
document.getElementById('paletteToggle').addEventListener('click', () => {
  const p = document.getElementById('palettePanel');
  p.classList.toggle('open');
  p.classList.contains('open') ? p.setAttribute('aria-hidden','false') : p.setAttribute('aria-hidden','true');
});
document.querySelectorAll('.palette-color').forEach(c => {
  c.addEventListener('click', () => {
    document.querySelectorAll('.palette-color').forEach(x => x.classList.remove('active'));
    c.classList.add('active');
    const col = c.dataset.accent;
    applyAccent(col);
    localStorage.setItem('accent', col);
  });
});
function applyAccent(hex){
  document.documentElement.style.setProperty('--accent', hex);
  const rgb = hexToRgb(hex);
  if(rgb){
    document.documentElement.style.setProperty('--glass', `rgba(${rgb.r},${rgb.g},${rgb.b},0.06)`);
    document.documentElement.style.setProperty('--card-grad-1', `rgba(${Math.min(255,rgb.r+18)},${Math.min(255,rgb.g+18)},${Math.min(255,rgb.b+18)},0.04)`);
    document.documentElement.style.setProperty('--card-grad-2', `rgba(${Math.min(255,rgb.r+36)},${Math.min(255,rgb.g+36)},${Math.min(255,rgb.b+36)},0.07)`);
  }
}
function hexToRgb(hex){
  try{ hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(c=>c+c).join(''); const n = parseInt(hex,16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 }; }catch(e){ return null; }
}
if(localStorage.getItem('accent')){
  const saved = localStorage.getItem('accent');
  document.documentElement.style.setProperty('--accent', saved);
  document.querySelector(`.palette-color[data-accent="${saved}"]`)?.classList.add('active');
  applyAccent(saved);
}

/* ---------- Reader mode ---------- */
const readerToggle = document.getElementById('readerToggle');
readerToggle.addEventListener('click', ()=>{
  document.body.classList.toggle('reader-mode');
  if(document.body.classList.contains('reader-mode')) localStorage.setItem('readerMode','on'); else localStorage.removeItem('readerMode');
});
if(localStorage.getItem('readerMode') === 'on') document.body.classList.add('reader-mode');

/* ---------- Search / sort / reveal ---------- */
document.getElementById('searchInput').addEventListener('input', (e) => {
  const q = (e.target.value || '').trim().toLowerCase();
  document.querySelectorAll('#gridContainer .card').forEach(card => {
    const name = (card.dataset.name || '').toLowerCase();
    const text = (card.textContent || '').toLowerCase();
    const show = !q || name.includes(q) || text.includes(q);
    card.style.display = show ? '' : 'none';
  });
});
document.getElementById('sortAlphaBtn').addEventListener('click', () => {
  const nodes = Array.from(grid.children);
  nodes.sort((a,b) => a.dataset.name.localeCompare(b.dataset.name, undefined, {sensitivity:'base', numeric:true}));
  nodes.forEach(n => grid.appendChild(n));
  revealCards();
});
document.getElementById('sortRandomBtn').addEventListener('click', () => {
  const nodes = Array.from(grid.children);
  for(let i = nodes.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [nodes[i], nodes[j]] = [nodes[j], nodes[i]];
  }
  nodes.forEach(n => grid.appendChild(n));
  revealCards();
});
function revealCards(){
  const cards = Array.from(document.querySelectorAll('#gridContainer .card'));
  cards.forEach((c, i) => {
    c.classList.remove('visible');
    setTimeout(() => c.classList.add('visible'), i * 60);
  });
}

/* ---------- Sortable ---------- */
new Sortable(document.getElementById('gridContainer'), { animation: 150 });

/* ---------- Load dashboard and toolbox ---------- */
async function loadDashboard(){
  const { owner, repo } = parseOwnerRepo(DEFAULT_REPO);
  try{
    const files = await getCardFiles(owner, repo, DEFAULT_BRANCH);
    if(!files.length){ document.getElementById('status').textContent = 'No cards folder found'; return; }
    files.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base', numeric:true}));
    grid.innerHTML = '';
    files.forEach(f => grid.appendChild(createCardElement(f)));
    document.getElementById('status').textContent = `${files.length} tools loaded`;
    setTimeout(revealCards, 200);

    // restore toolbox pinned items (stored as objects or array)
    const saved = loadToolboxStore();
    if(Array.isArray(saved) && saved.length && saved[0].file){
      toolboxItems = saved.map(x => x.file);
    } else if(Array.isArray(saved) && typeof saved[0] === 'string'){
      toolboxItems = saved;
    } else {
      toolboxItems = toolboxItems || [];
    }
    renderToolboxPanel();
  }catch(e){
    document.getElementById('status').textContent = 'Check repo name or cards/ folder';
    console.error(e);
  }
}

/* Init */
loadDashboard();
</script>
</body>
</html>
