<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  :root{
    --accent:#2dd4ff; --muted:#e6faff; --text:#e6faff;
    --bg-1:#0f1720; --bg-2:#1b2630;
    --glass: rgba(255,255,255,0.06);
    --panel: rgba(20,20,20,0.92);
    --card-grad-1: rgba(255,255,255,0.04);
    --card-grad-2: rgba(255,255,255,0.07);
    --border: rgba(255,255,255,0.10);
    --card-min: 260px;
    --card-scale: 1;
    --card-translateY: 18px;
    --toolbox-width: 520px;
    --toolbox-height: 420px;
  }

  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(135deg,var(--bg-1),var(--bg-2));color:var(--text);-webkit-font-smoothing:antialiased}
  header{padding:20px;text-align:center;z-index:2}
  header h1{margin:0;color:var(--accent);font-size:1.6rem}

  .control-btn{position:fixed;bottom:18px;z-index:14000;width:48px;height:48px;border-radius:10px;background:var(--glass);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;cursor:pointer;backdrop-filter:blur(6px);box-shadow:0 8px 30px rgba(0,0,0,0.45);color:var(--accent)}
  #toolboxToggle{left:18px} #paletteToggle{left:78px} #readerToggle{left:138px}

  .palette-panel{position:fixed;left:78px;bottom:74px;z-index:13900;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;display:none;pointer-events:none}
  .palette-panel.open{display:block;pointer-events:auto}

  .toolbox { position:fixed; right:18px; bottom:18px; width:var(--toolbox-width); height:var(--toolbox-height); z-index:13700; background:var(--panel); border:1px solid var(--border); border-radius:12px; box-shadow:0 18px 48px rgba(0,0,0,0.6); display:flex; flex-direction:column; overflow:hidden; resize:both; min-width:300px; min-height:200px; }
  .toolbox.hidden{display:none}
  .toolbox .titlebar{display:flex;align-items:center;justify-content:space-between;padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);cursor:grab;z-index:13750;}

  .toolbox .content{ position:relative; flex:1; background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); overflow:auto; }

  .widget-wrap{ position:absolute; box-sizing:border-box; background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04)); border-radius:10px;border:1px solid rgba(255,255,255,0.04); min-width:160px; min-height:100px; overflow:hidden; resize:both; z-index:1; box-shadow:0 8px 20px rgba(0,0,0,0.35); --widget-font-scale:1; }
  .widget-titlebar{ display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.03); background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent); cursor:move; user-select:none; }
  .widget-titlebar strong{color:var(--accent)}
  .widget-body{ padding:10px; overflow:auto; max-height:60vh; font-size: calc(1rem * var(--widget-font-scale)); line-height: calc(1.45 * var(--widget-font-scale)); }
  .widget-close, #toolboxClose { z-index: 13800; position: relative; background:transparent;border:0;color:var(--muted);cursor:pointer }

  main{position:relative;z-index:2}
  .search-bar{max-width:1100px;margin:14px auto 16px;display:flex;background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.02));border-radius:12px;padding:12px 16px;border:1px solid rgba(255,255,255,0.04)}
  .search-bar input{flex:1;border:none;background:transparent;color:var(--text);font-size:1rem;outline:none}

  .controls{display:flex;gap:8px;justify-content:center;margin-bottom:12px}
  .controls button{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted);cursor:pointer}

  .dashboard{ display:grid; grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr)); gap:20px; padding:20px; align-items:start; box-sizing:border-box; }

  .card{ box-sizing:border-box; background:linear-gradient(135deg,var(--card-grad-1),var(--card-grad-2)); border:1px solid var(--border); border-radius:12px; padding:16px; min-height:120px; backdrop-filter:blur(8px); width:100%; max-width:100%; opacity:0; transform: translateY(var(--card-translateY)) scale(var(--card-scale)); transition:opacity .36s ease, transform .36s ease; box-shadow:0 8px 24px rgba(0,0,0,0.35); overflow:hidden; }
  .card.visible{opacity:1; transform: translateY(0) scale(var(--card-scale));}
  .card-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .card-header h3{margin:0;color:var(--accent);font-size:1.05rem}

  body.reader-mode{font-size:1.12rem;line-height:1.6}
  body.reader-mode .dashboard{grid-template-columns:1fr;gap:18px}
  body.reader-mode .card{padding:20px;background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));border-color:rgba(255,255,255,0.06)}
</style>
</head>
<body>

  <button id="toolboxToggle" class="control-btn" title="Open toolbox">ðŸ§°</button>
  <button id="paletteToggle" class="control-btn" title="Theme">ðŸŽ¨</button>
  <button id="readerToggle" class="control-btn" title="Reader mode">ðŸ‘“</button>

  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px">Accent color</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#00ff99" style="background:#00ff99;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd;height:34px;border-radius:8px;cursor:pointer"></div>
    </div>
  </div>

  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div style="font-weight:600;color:var(--accent)">Toolbox</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="dockBtn" title="Dock/undock">â‡±</button>
        <button id="toolboxClose" title="Close">âœ•</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite"></div>
  </div>

  <header><h1>The Most Useful Site in the World</h1></header>

  <main>
    <div class="search-bar"><input id="searchInput" placeholder="Search cards..." /></div>

    <div class="controls">
      <button id="sortAlphaBtn">Sort Aâ†’Z</button>
      <button id="sortRandomBtn">Random</button>
    </div>

    <div id="status" class="muted" style="text-align:center;margin-bottom:6px">Loading cards...</div>
    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
/* ---------- Repo loader (unchanged) ---------- */
const DEFAULT_REPO = 'mrpr0phecy/mrpr0phecy';
const DEFAULT_BRANCH = 'main';
function parseOwnerRepo(str){ const p = str.split('/'); return { owner: p[0], repo: p[1] }; }
async function fetchRepoTree(owner, repo, branch){
  const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('GitHub API error: ' + r.status);
  return r.json();
}
async function getCardFiles(owner, repo, branch){
  const data = await fetchRepoTree(owner, repo, branch);
  return (data.tree || []).filter(item => item.path.startsWith('cards/') && item.path.endsWith('.html')).map(item => item.path.replace(/^cards\//,''));
}

/* ---------- Batched lazy loading: only load visible + up to 32 above and 32 below ---------- */
const grid = document.getElementById('gridContainer');
const cardLoadState = new WeakMap(); // track loaded cards
let allCardElements = [];            // ordered list of card DOM nodes
let filesList = [];                  // ordered list of file names
const BATCH_NEIGHBORS = 32;         // load up to 32 above and 32 below

function createCardElement(file){
  const name = file.replace('.html','');
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.file = file;
  card.dataset.name = name;

  const header = document.createElement('div');
  header.className = 'card-header';
  const title = document.createElement('h3');
  title.textContent = name;
  const btnWrap = document.createElement('div');
  btnWrap.style.display = 'flex';
  btnWrap.style.gap = '8px';

  const addBtn = document.createElement('div');
  addBtn.className = 'add-to-toolbox';
  addBtn.title = 'Add to toolbox';
  addBtn.textContent = '+';
  addBtn.style.cursor = 'pointer';
  addBtn.addEventListener('click', (e) => { e.stopPropagation(); addToToolbox(file); });

  btnWrap.appendChild(addBtn);
  header.appendChild(title);
  header.appendChild(btnWrap);
  card.appendChild(header);

  const content = document.createElement('div');
  content.className = 'content';
  content.textContent = 'Loadingâ€¦';
  card.appendChild(content);

  cardLoadState.set(card, false);
  return card;
}

async function loadCardContentInto(card, file){
  if(cardLoadState.get(card)) return;
  try{
    const r = await fetch(`cards/${file}`);
    if(!r.ok){ card.querySelector('.content').textContent = 'Preview unavailable'; cardLoadState.set(card,true); return; }
    let html = await r.text();
    html = html.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
    html = html.replace(/<img\b([^>]*?)>/gi, (m, attrs) => /loading\s*=/.test(attrs) ? `<img${attrs}>` : `<img loading="lazy"${attrs}>`);
    card.querySelector('.content').innerHTML = html;
    cardLoadState.set(card,true);
  }catch(e){
    card.querySelector('.content').textContent = 'Failed to load';
    cardLoadState.set(card,true);
  }
}

/* Compute the index range to load: visible cards plus up to BATCH_NEIGHBORS above and below.
   This function is called on scroll/resize and on search. */
function computeVisibleIndexRange(){
  const cards = allCardElements;
  if(!cards.length) return null;

  const viewportTop = 0;
  const viewportBottom = window.innerHeight;

  // find first and last card whose bounding rect intersects viewport
  let firstVisible = -1, lastVisible = -1;
  for(let i=0;i<cards.length;i++){
    const r = cards[i].getBoundingClientRect();
    if(r.bottom >= viewportTop && r.top <= viewportBottom){
      if(firstVisible === -1) firstVisible = i;
      lastVisible = i;
    }
  }

  // if none visible (e.g., scrolled to empty area), find nearest by center distance
  if(firstVisible === -1){
    let nearest = 0, bestDist = Infinity;
    for(let i=0;i<cards.length;i++){
      const r = cards[i].getBoundingClientRect();
      const center = (r.top + r.bottom) / 2;
      const dist = Math.min(Math.abs(center - viewportTop), Math.abs(center - viewportBottom));
      if(dist < bestDist){ bestDist = dist; nearest = i; }
    }
    firstVisible = lastVisible = nearest;
  }

  const start = Math.max(0, firstVisible - BATCH_NEIGHBORS);
  const end = Math.min(cards.length - 1, lastVisible + BATCH_NEIGHBORS);
  return { start, end, firstVisible, lastVisible };
}

/* Load a batch defined by start..end (inclusive). Ensures we only load each card once. */
function loadBatch(start, end){
  const cards = allCardElements;
  for(let i = start; i <= end; i++){
    const c = cards[i];
    if(!c) continue;
    if(!cardLoadState.get(c)){
      loadCardContentInto(c, c.dataset.file);
    }
  }
}

/* Debounced handler that computes and loads the batch around the viewport */
let batchScheduled = false;
function scheduleBatchLoad(){
  if(batchScheduled) return;
  batchScheduled = true;
  requestAnimationFrame(() => {
    batchScheduled = false;
    const range = computeVisibleIndexRange();
    if(range) loadBatch(range.start, range.end);
  });
}

/* Search integration: when user searches, only load matching cards (and their neighbors).
   If query is empty, revert to normal batch behavior. */
const searchInput = document.getElementById('searchInput');
let currentQuery = '';
let searchDebounceTimer = null;
searchInput.addEventListener('input', (e) => {
  const q = (e.target.value || '').trim().toLowerCase();
  currentQuery = q;
  if(searchDebounceTimer) clearTimeout(searchDebounceTimer);
  searchDebounceTimer = setTimeout(() => {
    applySearchFilter(q);
  }, 180);
});

function applySearchFilter(q){
  const cards = allCardElements;
  if(!q){
    // show all cards and schedule normal batch load
    cards.forEach(c => c.style.display = '');
    scheduleBatchLoad();
    return;
  }
  // hide non-matching cards, show matching ones and load a tight batch around matches
  const matches = [];
  cards.forEach((c, idx) => {
    const name = (c.dataset.name || '').toLowerCase();
    const text = (c.textContent || '').toLowerCase();
    const match = name.includes(q) || text.includes(q);
    c.style.display = match ? '' : 'none';
    if(match) matches.push(idx);
  });

  if(!matches.length) return;

  // compute min/max match index and expand by neighbors up to BATCH_NEIGHBORS
  const minIdx = Math.max(0, Math.min(...matches) - BATCH_NEIGHBORS);
  const maxIdx = Math.min(cards.length - 1, Math.max(...matches) + BATCH_NEIGHBORS);
  loadBatch(minIdx, maxIdx);
  // also scroll first match into view if none visible
  const range = computeVisibleIndexRange();
  if(range && (range.lastVisible < minIdx || range.start > maxIdx)){
    const firstMatchEl = cards[matches[0]];
    if(firstMatchEl) firstMatchEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
}

/* Attach scroll/resize listeners to trigger batch loads */
window.addEventListener('scroll', scheduleBatchLoad, { passive: true });
window.addEventListener('resize', scheduleBatchLoad);

/* ---------- Toolbox and widgets (unchanged behavior) ---------- */
const toolbox = document.getElementById('toolbox');
const toolboxContent = document.getElementById('toolboxContent');
const toolboxToggle = document.getElementById('toolboxToggle');
const toolboxClose = document.getElementById('toolboxClose');
const toolboxTitle = document.getElementById('toolboxTitle');
const dockBtn = document.getElementById('dockBtn');

let toolboxDocked = true;

/* restore toolbox state */
(function restoreToolbox(){
  try{
    const s = JSON.parse(localStorage.getItem('toolbox_state_v2') || '{}');
    if(s.width) toolbox.style.width = s.width + 'px';
    if(s.height) toolbox.style.height = s.height + 'px';
    if(s.left !== undefined && s.left !== null){
      toolbox.style.left = s.left + 'px';
      toolbox.style.top = s.top + 'px';
      toolbox.style.right = 'auto';
      toolbox.style.bottom = 'auto';
      toolboxDocked = false;
    }
  }catch(e){}
})();

toolboxToggle.addEventListener('click', () => {
  toolbox.classList.toggle('hidden');
  toolbox.classList.contains('hidden') ? toolbox.setAttribute('aria-hidden','true') : toolbox.setAttribute('aria-hidden','false');
});

toolboxClose.addEventListener('click', (e) => {
  e.stopPropagation();
  toolbox.classList.add('hidden');
  toolbox.setAttribute('aria-hidden','true');
  persistToolboxState();
});

/* Drag toolbox when undocked (titlebar) */
(function enableToolboxDrag(){
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
  toolboxTitle.addEventListener('pointerdown', (e) => {
    if(e.target.closest('button')) return;
    if(toolboxDocked) return;
    dragging = true;
    sx = e.clientX; sy = e.clientY;
    const rect = toolbox.getBoundingClientRect();
    startLeft = rect.left; startTop = rect.top;
    toolbox.style.transition = 'none';
    try{ toolbox.setPointerCapture(e.pointerId); }catch(_){}
  });
  window.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const dx = e.clientX - sx, dy = e.clientY - sy;
    toolbox.style.left = Math.max(8, startLeft + dx) + 'px';
    toolbox.style.top = Math.max(8, startTop + dy) + 'px';
    toolbox.style.right = 'auto'; toolbox.style.bottom = 'auto';
  });
  window.addEventListener('pointerup', (e) => {
    if(!dragging) return;
    dragging = false;
    toolbox.style.transition = '';
    try{ toolbox.releasePointerCapture(e.pointerId); }catch(_){}
    persistToolboxState();
  });
})();

/* Dock toggle: toggles back and forth and persists */
dockBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  toolboxDocked = !toolboxDocked;
  if(toolboxDocked){
    toolbox.style.left = 'auto';
    toolbox.style.top = 'auto';
    toolbox.style.right = '18px';
    toolbox.style.bottom = '18px';
    dockBtn.textContent = 'â‡±';
  } else {
    const rect = toolbox.getBoundingClientRect();
    toolbox.style.left = rect.left + 'px';
    toolbox.style.top = rect.top + 'px';
    toolbox.style.right = 'auto';
    toolbox.style.bottom = 'auto';
    dockBtn.textContent = 'â‡²';
  }
  persistToolboxState();
});

function persistToolboxState(){
  try{
    const r = toolbox.getBoundingClientRect();
    const state = { width: Math.round(r.width), height: Math.round(r.height) };
    if(!toolboxDocked){ state.left = Math.round(r.left); state.top = Math.round(r.top); }
    localStorage.setItem('toolbox_state_v2', JSON.stringify(state));
  }catch(e){}
}
toolbox.addEventListener('pointerup', persistToolboxState);
window.addEventListener('resize', persistToolboxState);

/* ---------- Freeform widgets (kept as before) ---------- */
const TOOLBOX_KEY = 'toolbox_items_v2';
function loadToolboxStore(){ try { return JSON.parse(localStorage.getItem(TOOLBOX_KEY) || '[]'); } catch(e) { return []; } }
function saveToolboxStore(items){ localStorage.setItem(TOOLBOX_KEY, JSON.stringify(items)); }
let toolboxItems = loadToolboxStore().map(x => x.file) || [];

function createWidget(file, saved){
  const wrap = document.createElement('div');
  wrap.className = 'widget-wrap';
  wrap.dataset.file = file;

  const defaultW = 320, defaultH = 200;
  const left = saved?.left ?? 12 + (Math.random()*40|0);
  const top = saved?.top ?? 12 + (Math.random()*40|0);
  const width = saved?.width ?? defaultW;
  const height = saved?.height ?? defaultH;

  wrap.style.left = left + 'px';
  wrap.style.top = top + 'px';
  wrap.style.width = width + 'px';
  wrap.style.height = height + 'px';

  const titlebar = document.createElement('div');
  titlebar.className = 'widget-titlebar';
  const title = document.createElement('strong');
  title.textContent = file.replace('.html','');
  const close = document.createElement('button');
  close.className = 'widget-close';
  close.innerHTML = 'âœ•';
  close.addEventListener('click', (e) => { e.stopPropagation(); removeFromToolbox(file); });
  titlebar.appendChild(title);
  titlebar.appendChild(close);

  const body = document.createElement('div');
  body.className = 'widget-body';
  body.textContent = 'Loadingâ€¦';

  wrap.appendChild(titlebar);
  wrap.appendChild(body);
  toolboxContent.appendChild(wrap);

  (async function loadIntoWidget(f, container){
    try{
      const r = await fetch(`cards/${f}`);
      if(!r.ok){ container.textContent = 'Preview unavailable'; return; }
      let html = await r.text();
      html = html.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
      html = html.replace(/<img\b([^>]*?)>/gi, (m, attrs) => /loading\s*=/.test(attrs) ? `<img${attrs}>` : `<img loading="lazy"${attrs}>`);
      container.innerHTML = html;
      adjustWidgetContentScale(wrap);
    }catch(e){
      container.textContent = 'Failed to load';
    }
  })(file, body);

  enableWidgetDrag(wrap, titlebar);
  observeWidgetResize(wrap);
  return wrap;
}

function enableWidgetDrag(widget, handle){
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;
  handle.addEventListener('pointerdown', (e) => {
    if(e.target.closest('button')) return;
    dragging = true;
    sx = e.clientX; sy = e.clientY;
    const rect = widget.getBoundingClientRect();
    const parentRect = toolboxContent.getBoundingClientRect();
    startLeft = rect.left - parentRect.left;
    startTop = rect.top - parentRect.top;
    widget.style.transition = 'none';
    try{ handle.setPointerCapture(e.pointerId); }catch(_){}
  });
  window.addEventListener('pointermove', (e) => {
    if(!dragging) return;
    const dx = e.clientX - sx, dy = e.clientY - sy;
    let nx = Math.max(-2000, startLeft + dx);
    let ny = Math.max(-2000, startTop + dy);
    widget.style.left = nx + 'px';
    widget.style.top = ny + 'px';
  });
  window.addEventListener('pointerup', (e) => {
    if(!dragging) return;
    dragging = false;
    widget.style.transition = '';
    try{ handle.releasePointerCapture(e.pointerId); }catch(_){}
    persistWidgetsState();
  });
}

let widgetResizeObserver = null;
function observeWidgetResize(widget){
  if(!widgetResizeObserver){
    widgetResizeObserver = new ResizeObserver(entries => {
      for(const entry of entries){
        adjustWidgetContentScale(entry.target);
        persistWidgetsState();
      }
    });
  }
  widgetResizeObserver.observe(widget);
  adjustWidgetContentScale(widget);
}

function adjustWidgetContentScale(widget){
  try{
    const body = widget.querySelector('.widget-body');
    if(!body) return;
    const base = 320;
    const w = widget.offsetWidth || parseFloat(widget.style.width) || base;
    const h = widget.offsetHeight || parseFloat(widget.style.height) || 200;
    let scale = (w / base);
    scale = Math.max(0.6, Math.min(1.8, scale));
    const heightFactor = Math.max(0.7, Math.min(1.4, h / 180));
    scale = scale * (0.85 + 0.15 * heightFactor);
    widget.style.setProperty('--widget-font-scale', scale.toFixed(3));
  }catch(e){}
}

function persistWidgetsState(){
  try{
    const items = [];
    toolboxContent.querySelectorAll('.widget-wrap').forEach(w => {
      items.push({
        file: w.dataset.file,
        left: Math.round(parseFloat(w.style.left || 0)),
        top: Math.round(parseFloat(w.style.top || 0)),
        width: Math.round(w.offsetWidth),
        height: Math.round(w.offsetHeight)
      });
    });
    saveToolboxStore(items);
  }catch(e){}
}

function renderToolboxPanel(){
  toolboxContent.innerHTML = '';
  const saved = loadToolboxStore();
  if(!toolboxItems || !toolboxItems.length){
    const empty = document.createElement('div');
    empty.className = 'muted';
    empty.style.padding = '12px';
    empty.textContent = 'No widgets pinned. Click + on a card to pin it here.';
    toolboxContent.appendChild(empty);
    return;
  }
  for(const file of toolboxItems){
    const s = (saved || []).find(x => x.file === file);
    createWidget(file, s);
  }
}

function addToToolbox(file){
  if(toolboxItems.includes(file)){ openToolbox(); return; }
  toolboxItems.unshift(file);
  if(toolboxItems.length > 80) toolboxItems.length = 80;
  saveToolboxStore(toolboxItems);
  renderToolboxPanel();
  openToolbox();
}
function removeFromToolbox(file){
  const idx = toolboxItems.indexOf(file);
  if(idx >= 0){ toolboxItems.splice(idx,1); saveToolboxStore(toolboxItems); renderToolboxPanel(); persistWidgetsState(); }
}
function openToolbox(){ toolbox.classList.remove('hidden'); toolbox.setAttribute('aria-hidden','false'); }

/* ---------- Palette, reader mode, sort (unchanged) ---------- */
document.getElementById('paletteToggle').addEventListener('click', () => {
  const p = document.getElementById('palettePanel');
  p.classList.toggle('open');
  p.classList.contains('open') ? p.setAttribute('aria-hidden','false') : p.setAttribute('aria-hidden','true');
});
document.querySelectorAll('.palette-color').forEach(c => {
  c.addEventListener('click', () => {
    document.querySelectorAll('.palette-color').forEach(x => x.classList.remove('active'));
    c.classList.add('active');
    const col = c.dataset.accent;
    applyAccent(col);
    localStorage.setItem('accent', col);
  });
});
function applyAccent(hex){
  document.documentElement.style.setProperty('--accent', hex);
  const rgb = hexToRgb(hex);
  if(rgb){
    document.documentElement.style.setProperty('--glass', `rgba(${rgb.r},${rgb.g},${rgb.b},0.06)`);
    document.documentElement.style.setProperty('--card-grad-1', `rgba(${Math.min(255,rgb.r+18)},${Math.min(255,rgb.g+18)},${Math.min(255,rgb.b+18)},0.04)`);
    document.documentElement.style.setProperty('--card-grad-2', `rgba(${Math.min(255,rgb.r+36)},${Math.min(255,rgb.g+36)},${Math.min(255,rgb.b+36)},0.07)`);
  }
}
function hexToRgb(hex){
  try{ hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(c=>c+c).join(''); const n = parseInt(hex,16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 }; }catch(e){ return null; }
}
if(localStorage.getItem('accent')){
  const saved = localStorage.getItem('accent');
  document.documentElement.style.setProperty('--accent', saved);
  document.querySelector(`.palette-color[data-accent="${saved}"]`)?.classList.add('active');
  applyAccent(saved);
}

const readerToggle = document.getElementById('readerToggle');
readerToggle.addEventListener('click', ()=>{
  document.body.classList.toggle('reader-mode');
  if(document.body.classList.contains('reader-mode')) localStorage.setItem('readerMode','on'); else localStorage.removeItem('readerMode');
});
if(localStorage.getItem('readerMode') === 'on') document.body.classList.add('reader-mode');

document.getElementById('sortAlphaBtn').addEventListener('click', () => {
  const nodes = Array.from(grid.children);
  nodes.sort((a,b) => a.dataset.name.localeCompare(b.dataset.name, undefined, {sensitivity:'base', numeric:true}));
  nodes.forEach(n => grid.appendChild(n));
  // refresh internal list and schedule batch load
  allCardElements = Array.from(document.querySelectorAll('#gridContainer .card'));
  scheduleBatchLoad();
});
document.getElementById('sortRandomBtn').addEventListener('click', () => {
  const nodes = Array.from(grid.children);
  for(let i = nodes.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [nodes[i], nodes[j]] = [nodes[j], nodes[i]];
  }
  nodes.forEach(n => grid.appendChild(n));
  allCardElements = Array.from(document.querySelectorAll('#gridContainer .card'));
  scheduleBatchLoad();
});

/* ---------- Load dashboard and initialize batched loader ---------- */
async function loadDashboard(){
  const { owner, repo } = parseOwnerRepo(DEFAULT_REPO);
  try{
    filesList = await getCardFiles(owner, repo, DEFAULT_BRANCH);
    if(!filesList.length){ document.getElementById('status').textContent = 'No cards folder found'; return; }
    filesList.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base', numeric:true}));
    grid.innerHTML = '';
    filesList.forEach(f => grid.appendChild(createCardElement(f)));
    allCardElements = Array.from(document.querySelectorAll('#gridContainer .card'));
    document.getElementById('status').textContent = `${filesList.length} tools loaded`;
    // initial batch load around viewport
    scheduleBatchLoad();
    // restore toolbox pinned items
    const saved = loadToolboxStore();
    if(Array.isArray(saved) && saved.length && saved[0].file){
      toolboxItems = saved.map(x => x.file);
    } else if(Array.isArray(saved) && typeof saved[0] === 'string'){
      toolboxItems = saved;
    } else {
      toolboxItems = toolboxItems || [];
    }
    renderToolboxPanel();
  }catch(e){
    document.getElementById('status').textContent = 'Check repo name or cards/ folder';
    console.error(e);
  }
}

/* Init */
loadDashboard();
</script>
</body>
</html>
