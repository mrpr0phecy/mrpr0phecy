<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  /* DARK DEFAULTS DIRECTLY IN CSS - NO VARIABLES FOR BACKGROUND */
  html,body{
    height:100%;
    margin:0;
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(135deg, #0a0f14, #141e28); /* DARK DEFAULT */
    color:#e6faff;
    -webkit-font-smoothing:antialiased;
    /* FIX 1: Ensure background covers entire page */
    background-attachment: fixed;
    background-size: cover;
  }
  
  /* CSS VARIABLES ONLY FOR THINGS THAT CHANGE */
  :root{
    --accent:#2dd4ff; 
    --muted:#e6faff; 
    --text:#e6faff;
    --glass: rgba(255,255,255,0.06);
    --panel: rgba(20,20,20,0.92);
    --card-grad-1: rgba(255,255,255,0.02);
    --card-grad-2: rgba(255,255,255,0.04);
    --border: rgba(255,255,255,0.10);
    --card-min: 260px;
    --card-scale: 1;
    --card-translateY: 18px;
    --toolbox-width: 520px;
    --toolbox-height: 420px;
  }

  header{padding:20px;text-align:center;z-index:2}
  header h1{margin:0;color:var(--accent);font-size:1.6rem}

  .control-btn{
    position:fixed;bottom:18px;z-index:14000;width:48px;height:48px;border-radius:10px;
    background:var(--glass);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;
    cursor:pointer;backdrop-filter:blur(6px);box-shadow:0 8px 30px rgba(0,0,0,0.45);color:var(--accent);
  }
  .control-btn:hover{transform:scale(1.06)}
  #toolboxToggle{left:18px}
  #paletteToggle{left:78px}
  #readerToggle{left:138px}

  .palette-panel{
    position:fixed;left:78px;bottom:74px;z-index:13900;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;box-shadow:0 12px 36px rgba(0,0,0,0.6);backdrop-filter:blur(8px);
    display:none;pointer-events:none;
  }
  .palette-panel.open{display:block;pointer-events:auto}

  .toolbox {
    position:fixed;
    right:18px;
    bottom:18px;
    width:var(--toolbox-width);
    height:var(--toolbox-height);
    z-index:13700;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:0 18px 48px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    resize:both;
    min-width:300px;
    min-height:200px;
  }
  .toolbox.hidden{display:none}

  .toolbox .titlebar{
    display:flex;align-items:center;justify-content:space-between;padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);cursor:grab;z-index:13750;
  }

  .toolbox .content{
    position:relative;
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    overflow:auto;
    min-height:100px;
  }

  .widget-wrap{
    position:absolute;
    box-sizing:border-box;
    background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
    border-radius:10px;border:1px solid rgba(255,255,255,0.04);
    min-width:160px; min-height:100px;
    max-width:calc(100% - 20px);
    max-height:calc(100% - 20px);
    overflow:hidden;
    resize:both;
    z-index:1;
    box-shadow:0 8px 20px rgba(0,0,0,0.35);
    /* FIX 2: Add font scaling based on widget size */
    --widget-font-scale: 1;
  }

  .widget-titlebar{
    display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    cursor:move;
    user-select:none;
  }
  .widget-titlebar strong{color:var(--accent)}
  /* FIX 2: Responsive text based on widget size */
  .widget-body{
    padding:10px;
    overflow:auto;
    max-height:60vh;
    font-size: calc(0.9rem * var(--widget-font-scale));
    line-height: calc(1.4 * var(--widget-font-scale));
  }

  .widget-close, #toolboxClose { z-index: 13800; position: relative; background:transparent;border:0;color:var(--muted);cursor:pointer }

  main{position:relative;z-index:2}
  .search-bar{max-width:1100px;margin:14px auto 16px;display:flex;background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.02));border-radius:12px;padding:12px 16px;border:1px solid rgba(255,255,255,0.04)}
  .search-bar input{flex:1;border:none;background:transparent;color:var(--text);font-size:1rem;outline:none}

  .controls{display:flex;gap:8px;justify-content:center;margin-bottom:12px}
  .controls button{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted);cursor:pointer}

  .dashboard{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
    gap:20px;
    padding:20px;
    align-items:start;
    box-sizing:border-box;
  }

  .card{
    box-sizing:border-box;
    background:linear-gradient(135deg,var(--card-grad-1),var(--card-grad-2));
    border:1px solid var(--border);
    border-radius:12px;
    padding:16px;
    min-height:120px;
    width:100%;
    max-width:100%;
    opacity:0;
    transform: translateY(var(--card-translateY)) scale(var(--card-scale));
    transition:opacity .36s ease, transform .36s ease;
    box-shadow:0 8px 24px rgba(0,0,0,0.35);
    overflow:hidden;
  }
  .card.visible{opacity:1; transform: translateY(0) scale(var(--card-scale));}
  .card-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .card-header h3{margin:0;color:var(--accent);font-size:1.05rem}

  body.reader-mode{font-size:1.12rem;line-height:1.6}
  body.reader-mode .dashboard{grid-template-columns:1fr;gap:18px}
  body.reader-mode .card{padding:20px;background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));border-color:rgba(255,255,255,0.06)}
</style>
</head>
<body>

  <button id="toolboxToggle" class="control-btn" title="Open toolbox">ðŸ§°</button>
  <button id="paletteToggle" class="control-btn" title="Theme">ðŸŽ¨</button>
  <button id="readerToggle" class="control-btn" title="Reader mode">ðŸ‘“</button>

  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px">Accent color</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#00ff99" style="background:#00ff99;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd;height:34px;border-radius:8px;cursor:pointer"></div>
    </div>
    
    <!-- SIMPLIFIED BACKGROUND THEMES - DIRECT COLOR VALUES -->
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px;margin-top:12px">Background theme</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <button class="theme-btn active" data-color="default" style="background:linear-gradient(135deg, #0a0f14, #141e28);height:34px;border-radius:8px;cursor:pointer;border:2px solid var(--accent)"></button>
      <button class="theme-btn" data-color="deep-blue" style="background:linear-gradient(135deg, #05080c, #0f151f);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-purple" style="background:linear-gradient(135deg, #12081a, #1f1229);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-teal" style="background:linear-gradient(135deg, #061616, #0f2525);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-red" style="background:linear-gradient(135deg, #160606, #251010);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
    </div>
  </div>

  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div style="font-weight:600;color:var(--accent)">Toolbox</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="dockBtn" title="Dock/undock" style="background:transparent;border:0;color:var(--muted);cursor:pointer">â‡±</button>
        <button id="toolboxClose" title="Close" style="background:transparent;border:0;color:var(--muted);cursor:pointer">âœ•</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite"></div>
  </div>

  <header><h1>The Most Useful Site in the World</h1></header>

  <main>
    <div class="search-bar"><input id="searchInput" placeholder="Search cards..." /></div>

    <div class="controls">
      <button id="sortAlphaBtn">Sort Aâ†’Z</button>
      <button id="sortRandomBtn">Random</button>
    </div>

    <div id="status" class="muted" style="text-align:center;margin-bottom:6px">Loading cards...</div>
    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
// MINIMAL, WORKING CODE - NO COMPLEXITY

console.log("=== STARTING APP ===");

// Background themes - SIMPLE OBJECT MAPPING
const themes = {
  'default': { bg1: '#0a0f14', bg2: '#141e28' },
  'deep-blue': { bg1: '#05080c', bg2: '#0f151f' },
  'deep-purple': { bg1: '#12081a', bg2: '#1f1229' },
  'deep-teal': { bg1: '#061616', bg2: '#0f2525' },
  'deep-red': { bg1: '#160606', bg2: '#251010' }
};

// Apply background directly (no CSS variables for background)
function applyTheme(themeName) {
  console.log("Applying theme:", themeName);
  const theme = themes[themeName];
  if (!theme) return;
  
  // FIX 1: Apply to html AND body for full coverage
  const gradient = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
  document.documentElement.style.background = gradient;
  document.body.style.background = gradient;
  
  // Also update theme buttons for consistency
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === themeName) {
      btn.style.background = gradient;
    }
  });
  
  // Save to localStorage
  localStorage.setItem('theme', themeName);
  console.log("Theme saved to localStorage:", themeName);
}

// FIX 2: Calculate font scale based on widget size
function updateWidgetFontScale(widget) {
  const width = parseInt(widget.style.width) || widget.offsetWidth;
  const height = parseInt(widget.style.height) || widget.offsetHeight;
  
  // Base size for reference (200px wide = scale 1)
  const baseWidth = 200;
  const baseHeight = 150;
  
  // Calculate scale based on both width and height, but prioritize width
  const widthScale = width / baseWidth;
  const heightScale = height / baseHeight;
  
  // Use the smaller scale to ensure text fits both dimensions
  const scale = Math.min(widthScale, heightScale);
  
  // Clamp scale between 0.5 and 2.0 for readability
  const clampedScale = Math.max(0.5, Math.min(2.0, scale));
  
  // Apply scale to CSS custom property
  widget.style.setProperty('--widget-font-scale', clampedScale);
  
  // Also adjust title font size
  const title = widget.querySelector('.widget-titlebar strong');
  if (title) {
    title.style.fontSize = `${Math.max(0.8, Math.min(1.2, clampedScale))}rem`;
  }
}

// ===== TOOLBOX WIDGET MANAGEMENT =====
let widgets = [];
let toolboxDocked = false;

// Make toolbox draggable and resizable
function initToolbox() {
  const toolbox = document.getElementById('toolbox');
  const toolboxTitle = document.getElementById('toolboxTitle');
  
  // Make toolbox draggable
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  toolboxTitle.addEventListener('mousedown', startDrag);
  
  function startDrag(e) {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = toolbox.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = 'grabbing';
  }
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    toolbox.style.left = 'auto';
    toolbox.style.right = 'auto';
    toolbox.style.top = e.clientY - dragOffset.y + 'px';
    toolbox.style.left = e.clientX - dragOffset.x + 'px';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = '';
  }
  
  // Dock/undock button
  document.getElementById('dockBtn').addEventListener('click', function() {
    toolboxDocked = !toolboxDocked;
    
    if (toolboxDocked) {
      // Dock to right
      toolbox.style.left = 'auto';
      toolbox.style.right = '18px';
      toolbox.style.top = 'auto';
      toolbox.style.bottom = '18px';
      this.textContent = 'â‡²';
    } else {
      // Undock
      this.textContent = 'â‡±';
    }
  });
  
  // Load saved widgets
  loadSavedWidgets();
}

// Create a widget in toolbox
function createWidget(name, contentHTML) {
  const widgetId = 'widget-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  const widget = document.createElement('div');
  widget.className = 'widget-wrap';
  widget.id = widgetId;
  widget.dataset.name = name;
  
  // Random position within toolbox
  const toolboxContent = document.getElementById('toolboxContent');
  const tRect = toolboxContent.getBoundingClientRect();
  
  widget.style.left = Math.random() * (tRect.width - 200) + 'px';
  widget.style.top = Math.random() * (tRect.height - 150) + 'px';
  widget.style.width = '200px';
  widget.style.height = '150px';
  
  widget.innerHTML = `
    <div class="widget-titlebar">
      <strong>${name}</strong>
      <button class="widget-close" title="Close widget">âœ•</button>
    </div>
    <div class="widget-body">${contentHTML}</div>
  `;
  
  toolboxContent.appendChild(widget);
  
  // Initialize font scale
  updateWidgetFontScale(widget);
  
  // Make widget draggable
  makeWidgetDraggable(widget);
  
  // Make widget resizable
  makeWidgetResizable(widget);
  
  // Close button
  widget.querySelector('.widget-close').addEventListener('click', function() {
    removeWidget(widgetId);
  });
  
  // Save widget
  widgets.push({
    id: widgetId,
    name: name,
    content: contentHTML,
    x: widget.style.left,
    y: widget.style.top,
    width: widget.style.width,
    height: widget.style.height
  });
  
  saveWidgets();
  
  return widgetId;
}

// Make widget draggable
function makeWidgetDraggable(widget) {
  const titlebar = widget.querySelector('.widget-titlebar');
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  titlebar.addEventListener('mousedown', startDrag);
  
  function startDrag(e) {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = widget.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    widget.style.zIndex = '1000';
  }
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    const parentRect = widget.parentElement.getBoundingClientRect();
    const x = e.clientX - parentRect.left - dragOffset.x;
    const y = e.clientY - parentRect.top - dragOffset.y;
    
    // Keep within bounds
    const maxX = parentRect.width - widget.offsetWidth;
    const maxY = parentRect.height - widget.offsetHeight;
    
    widget.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
    widget.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    widget.style.zIndex = '1';
    
    // Update saved position
    const widgetObj = widgets.find(w => w.id === widget.id);
    if (widgetObj) {
      widgetObj.x = widget.style.left;
      widgetObj.y = widget.style.top;
      saveWidgets();
    }
  }
}

// Make widget resizable
function makeWidgetResizable(widget) {
  const resizeHandle = document.createElement('div');
  resizeHandle.style.position = 'absolute';
  resizeHandle.style.right = '0';
  resizeHandle.style.bottom = '0';
  resizeHandle.style.width = '16px';
  resizeHandle.style.height = '16px';
  resizeHandle.style.cursor = 'se-resize';
  resizeHandle.style.background = 'transparent';
  resizeHandle.style.zIndex = '10';
  
  widget.appendChild(resizeHandle);
  
  let isResizing = false;
  let startWidth, startHeight, startX, startY;
  
  resizeHandle.addEventListener('mousedown', startResize);
  
  function startResize(e) {
    e.stopPropagation();
    isResizing = true;
    startWidth = parseInt(getComputedStyle(widget).width);
    startHeight = parseInt(getComputedStyle(widget).height);
    startX = e.clientX;
    startY = e.clientY;
    
    document.addEventListener('mousemove', onResize);
    document.addEventListener('mouseup', stopResize);
  }
  
  function onResize(e) {
    if (!isResizing) return;
    
    e.preventDefault();
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    const newWidth = Math.max(160, startWidth + dx);
    const newHeight = Math.max(100, startHeight + dy);
    
    widget.style.width = newWidth + 'px';
    widget.style.height = newHeight + 'px';
    
    // FIX 2: Update font scale when resizing
    updateWidgetFontScale(widget);
  }
  
  function stopResize() {
    isResizing = false;
    document.removeEventListener('mousemove', onResize);
    document.removeEventListener('mouseup', stopResize);
    
    // Update saved size
    const widgetObj = widgets.find(w => w.id === widget.id);
    if (widgetObj) {
      widgetObj.width = widget.style.width;
      widgetObj.height = widget.style.height;
      saveWidgets();
    }
  }
}

// Remove widget
function removeWidget(widgetId) {
  const widget = document.getElementById(widgetId);
  if (widget) {
    widget.remove();
  }
  
  widgets = widgets.filter(w => w.id !== widgetId);
  saveWidgets();
}

// Save widgets to localStorage
function saveWidgets() {
  localStorage.setItem('toolboxWidgets', JSON.stringify(widgets));
}

// Load saved widgets
function loadSavedWidgets() {
  const saved = localStorage.getItem('toolboxWidgets');
  if (saved) {
    try {
      widgets = JSON.parse(saved) || [];
      widgets.forEach(widgetData => {
        const widget = document.createElement('div');
        widget.className = 'widget-wrap';
        widget.id = widgetData.id;
        widget.dataset.name = widgetData.name;
        widget.style.left = widgetData.x;
        widget.style.top = widgetData.y;
        widget.style.width = widgetData.width;
        widget.style.height = widgetData.height;
        
        widget.innerHTML = `
          <div class="widget-titlebar">
            <strong>${widgetData.name}</strong>
            <button class="widget-close" title="Close widget">âœ•</button>
          </div>
          <div class="widget-body">${widgetData.content}</div>
        `;
        
        document.getElementById('toolboxContent').appendChild(widget);
        
        // Initialize font scale for loaded widget
        updateWidgetFontScale(widget);
        
        makeWidgetDraggable(widget);
        makeWidgetResizable(widget);
        
        widget.querySelector('.widget-close').addEventListener('click', function() {
          removeWidget(widgetData.id);
        });
      });
    } catch (e) {
      console.error('Failed to load widgets:', e);
      widgets = [];
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
  console.log("DOM ready");
  
  // Apply saved theme or default
  const savedTheme = localStorage.getItem('theme') || 'default';
  applyTheme(savedTheme);
  
  // Activate saved theme button
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === savedTheme) {
      btn.classList.add('active');
      btn.style.border = '2px solid var(--accent)';
    } else {
      btn.classList.remove('active');
      btn.style.border = '1px solid var(--border)';
    }
  });
  
  // Apply saved accent
  const savedAccent = localStorage.getItem('accent') || '#2dd4ff';
  document.documentElement.style.setProperty('--accent', savedAccent);
  document.querySelectorAll('.palette-color').forEach(c => {
    c.classList.toggle('active', c.dataset.accent === savedAccent);
  });
  
  // Apply reader mode
  if(localStorage.getItem('readerMode') === 'on') {
    document.body.classList.add('reader-mode');
  }
  
  // Initialize toolbox
  initToolbox();
  
  // Load dashboard
  loadDashboard();
});

// ===== PALETTE HANDLING =====
document.getElementById('paletteToggle').addEventListener('click', function() {
  const panel = document.getElementById('palettePanel');
  panel.classList.toggle('open');
});

// Accent colors
document.querySelectorAll('.palette-color').forEach(c => {
  c.addEventListener('click', function() {
    document.querySelectorAll('.palette-color').forEach(x => x.classList.remove('active'));
    this.classList.add('active');
    const col = this.dataset.accent;
    document.documentElement.style.setProperty('--accent', col);
    localStorage.setItem('accent', col);
  });
});

// Background themes - SIMPLE
document.querySelectorAll('.theme-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.theme-btn').forEach(b => {
      b.classList.remove('active');
      b.style.border = '1px solid var(--border)';
    });
    this.classList.add('active');
    this.style.border = '2px solid var(--accent)';
    
    const themeName = this.dataset.color;
    applyTheme(themeName);
  });
});

// ===== TOOLBOX =====
const toolbox = document.getElementById('toolbox');
document.getElementById('toolboxToggle').addEventListener('click', function() {
  toolbox.classList.toggle('hidden');
});
document.getElementById('toolboxClose').addEventListener('click', function(e) {
  e.stopPropagation();
  toolbox.classList.add('hidden');
});

// ===== READER MODE =====
document.getElementById('readerToggle').addEventListener('click', function() {
  document.body.classList.toggle('reader-mode');
  localStorage.setItem('readerMode', document.body.classList.contains('reader-mode') ? 'on' : 'off');
});

// ===== SEARCH =====
const searchInput = document.getElementById('searchInput');
searchInput.addEventListener('input', function(e) {
  const q = e.target.value.toLowerCase();
  document.querySelectorAll('.card').forEach(card => {
    const name = card.dataset.name.toLowerCase();
    const text = card.textContent.toLowerCase();
    card.style.display = name.includes(q) || text.includes(q) ? '' : 'none';
  });
});

// ===== SORT BUTTONS =====
document.getElementById('sortAlphaBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  cards.sort((a,b) => a.dataset.name.localeCompare(b.dataset.name));
  cards.forEach(card => grid.appendChild(card));
});

document.getElementById('sortRandomBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  for (let i = cards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [cards[i], cards[j]] = [cards[j], cards[i]];
  }
  cards.forEach(card => grid.appendChild(card));
});

// ===== LOAD CARDS =====
async function loadDashboard() {
  try {
    const DEFAULT_REPO = 'mrpr0phecy/mrpr0phecy';
    const DEFAULT_BRANCH = 'main';
    
    // Parse repo
    const [owner, repo] = DEFAULT_REPO.split('/');
    
    // Fetch card files
    const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${DEFAULT_BRANCH}?recursive=1`;
    const response = await fetch(url);
    const data = await response.json();
    
    const cardFiles = (data.tree || [])
      .filter(item => item.path.startsWith('cards/') && item.path.endsWith('.html'))
      .map(item => item.path.replace(/^cards\//, ''));
    
    console.log("Found", cardFiles.length, "cards");
    
    // Display cards
    const grid = document.getElementById('gridContainer');
    const status = document.getElementById('status');
    
    if (!cardFiles.length) {
      status.textContent = 'No cards found';
      return;
    }
    
    grid.innerHTML = '';
    cardFiles.sort().forEach(file => {
      const name = file.replace('.html', '');
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.file = file;
      card.dataset.name = name;
      
      const header = document.createElement('div');
      header.className = 'card-header';
      header.innerHTML = `<h3>${name}</h3><div style="display:flex;gap:8px"><div class="add-to-toolbox" title="Add to toolbox" style="cursor:pointer;font-weight:bold;color:var(--accent)">+</div></div>`;
      
      const content = document.createElement('div');
      content.className = 'content';
      content.textContent = 'Loadingâ€¦';
      
      card.appendChild(header);
      card.appendChild(content);
      grid.appendChild(card);
      
      // Load content
      fetch(`cards/${file}`)
        .then(r => r.ok ? r.text() : Promise.reject())
        .then(html => {
          content.innerHTML = html.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
        })
        .catch(() => {
          content.textContent = 'Preview unavailable';
        });
    });
    
    status.textContent = `${cardFiles.length} tools loaded`;
    
    // Reveal animation
    setTimeout(() => {
      document.querySelectorAll('.card').forEach((card, i) => {
        setTimeout(() => card.classList.add('visible'), i * 60);
      });
    }, 200);
    
  } catch (error) {
    console.error("Error loading dashboard:", error);
    document.getElementById('status').textContent = 'Error loading cards';
  }
}

// Add event listener for adding cards to toolbox
document.addEventListener('click', function(e) {
  // Check if click is on "Add to toolbox" button
  if (e.target.classList.contains('add-to-toolbox') || 
      e.target.closest('.add-to-toolbox')) {
    
    const card = e.target.closest('.card');
    if (!card) return;
    
    const cardName = card.dataset.name;
    const contentElement = card.querySelector('.content');
    const contentHTML = contentElement.innerHTML;
    
    // Create widget in toolbox
    createWidget(cardName, contentHTML);
    
    // Show toolbox if hidden
    toolbox.classList.remove('hidden');
    
    // Visual feedback
    const addBtn = e.target.closest('.add-to-toolbox');
    addBtn.textContent = 'âœ“';
    addBtn.style.color = 'var(--accent)';
    setTimeout(() => {
      addBtn.textContent = '+';
      addBtn.style.color = '';
    }, 1000);
  }
});

// Make Sortable
new Sortable(document.getElementById('gridContainer'), { animation: 150 });

console.log("=== APP INITIALIZED ===");
</script>
</body>
</html>
