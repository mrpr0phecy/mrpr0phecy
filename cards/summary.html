<h2 id="summary-title" style="margin-top:0;">Summary & Reading Time</h2>

<form aria-describedby="summary-desc">
  <p id="summary-desc" class="small">Paste or type text to get a concise extractive summary and an estimated reading time. Choose summary length and toggle brief explanations of why sentences were chosen.</p>

  <div class="row">
    <div class="field" style="flex:1;">
      <label for="sum-text">Text</label>
      <textarea id="sum-text" rows="10" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit;" placeholder="Paste article, essay, or notes here..."></textarea>
    </div>
  </div>

  <div class="row" style="margin-top:8px;">
    <div class="field">
      <label for="sum-length">Summary length</label>
      <select id="sum-length">
        <option value="short">Short (1–2 sentences)</option>
        <option value="medium" selected>Medium (3–5 sentences)</option>
        <option value="long">Long (6–10 sentences)</option>
      </select>
    </div>

    <div class="field" style="display:flex;align-items:center;gap:8px;">
      <label style="display:inline-flex;align-items:center;gap:8px;">
        <input id="sum-explain" type="checkbox" />
        <span class="small">Explain picks</span>
      </label>
    </div>

    <div class="field">
      <label for="sum-wpm">Reading speed (wpm)</label>
      <input id="sum-wpm" type="number" min="100" max="1000" step="10" value="200" />
    </div>
  </div>

  <div class="actions">
    <button type="button" onclick="sumGenerate(this)">Generate Summary</button>
    <button type="button" class="secondary" onclick="sumReset(this)">Reset</button>
    <button type="button" onclick="sumCopy(this)">Copy Summary</button>
  </div>
</form>

<div class="results" aria-live="polite" style="margin-top:12px;">
  <div class="result">
    <div class="label">Estimated reading time</div>
    <div class="value small" id="sum-reading">–</div>
  </div>

  <h3 class="small" style="margin-top:12px;">Summary</h3>
  <textarea id="sum-output" rows="8" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit;"></textarea>

  <div id="sum-explain-list" class="small" style="margin-top:10px;display:none;">
    <h4 class="small">Why these sentences were chosen</h4>
    <ol id="sum-explain-items" style="padding-left:18px;"></ol>
  </div>
</div>

<script>
/*
  Summary & Reading Time card
  - Client-side extractive summarizer: scores sentences by word frequency and position
  - Reading time estimate based on word count and user wpm
  - Scripts scoped via btn.closest('.card') for modularity
*/

function sumReset(btn) {
  const card = btn.closest('.card');
  card.querySelector('#sum-text').value = "";
  card.querySelector('#sum-output').value = "";
  card.querySelector('#sum-reading').textContent = "–";
  card.querySelector('#sum-explain-list').style.display = "none";
  card.querySelector('#sum-explain-items').innerHTML = "";
}

function sumCopy(btn) {
  const card = btn.closest('.card');
  const out = card.querySelector('#sum-output').value;
  if (!out.trim()) return;
  navigator.clipboard?.writeText(out).then(() => {
    const hint = card.querySelector('#sum-reading');
    const prev = hint.textContent;
    hint.textContent = "Summary copied to clipboard.";
    setTimeout(() => { hint.textContent = prev; }, 1500);
  }).catch(() => {
    alert("Copy failed — select the text and copy manually.");
  });
}

function sumGenerate(btn) {
  const card = btn.closest('.card');
  const text = (card.querySelector('#sum-text').value || "").trim();
  const lengthPref = card.querySelector('#sum-length').value;
  const explain = card.querySelector('#sum-explain').checked;
  const wpm = parseInt(card.querySelector('#sum-wpm').value, 10) || 200;

  if (!text) {
    card.querySelector('#sum-reading').textContent = "Please paste some text to summarise.";
    return;
  }

  const sentences = splitSentences(text);
  if (!sentences.length) {
    card.querySelector('#sum-reading').textContent = "No sentences detected.";
    return;
  }

  const wordCounts = sentences.map(s => s.split(/\s+/).filter(Boolean).length);
  const totalWords = wordCounts.reduce((a,b) => a+b, 0);
  const readingMinutes = Math.max(1, Math.round(totalWords / wpm));
  card.querySelector('#sum-reading').textContent = `${readingMinutes} min read (${totalWords} words at ${wpm} wpm)`;

  // Build frequency map of words (simple, lowercased, remove stopwords)
  const freq = buildFrequencyMap(text);

  // Score sentences: sum of word frequencies + small bonus for early sentences
  const scored = sentences.map((s, i) => {
    const words = s.toLowerCase().match(/\b[a-z0-9']+\b/g) || [];
    let score = 0;
    words.forEach(w => {
      score += freq[w] || 0;
    });
    // position bonus: earlier sentences slightly favored
    score *= (1 + (1 - (i / Math.max(1, sentences.length))) * 0.15);
    // length normalization (avoid extremely long sentences dominating)
    score = score / Math.sqrt(Math.max(1, words.length));
    return { index: i, sentence: s.trim(), score, wordsCount: words.length };
  });

  // Determine number of sentences to pick
  let pickCount = 3;
  if (lengthPref === 'short') pickCount = Math.min(2, Math.max(1, Math.round(sentences.length * 0.05)));
  if (lengthPref === 'medium') pickCount = Math.min(5, Math.max(1, Math.round(sentences.length * 0.12)));
  if (lengthPref === 'long') pickCount = Math.min(10, Math.max(1, Math.round(sentences.length * 0.25)));
  pickCount = Math.max(1, pickCount);

  // Select top scored sentences, then sort by original order for coherence
  const top = scored.slice().sort((a,b) => b.score - a.score).slice(0, pickCount).sort((a,b) => a.index - b.index);

  const summary = top.map(t => t.sentence).join(' ');
  card.querySelector('#sum-output').value = summary;

  // Explain picks if requested
  const explainList = card.querySelector('#sum-explain-list');
  const explainItems = card.querySelector('#sum-explain-items');
  explainItems.innerHTML = "";
  if (explain) {
    explainList.style.display = "";
    top.forEach(t => {
      const li = document.createElement('li');
      li.textContent = `${t.sentence} — score ${t.score.toFixed(2)}; ${t.wordsCount} words.`;
      explainItems.appendChild(li);
    });
  } else {
    explainList.style.display = "none";
  }
}

/* Utility functions */

function splitSentences(text) {
  // Basic sentence splitter: split on .!? followed by space and capital letter or line break
  // Keep punctuation with sentence
  const raw = text.replace(/\r\n/g, '\n').replace(/\n+/g, ' ');
  const parts = raw.match(/[^.!?]+[.!?]?/g) || [];
  return parts.map(p => p.trim()).filter(Boolean);
}

function buildFrequencyMap(text) {
  const stopwords = new Set([
    'the','and','is','in','to','of','a','that','it','for','on','with','as','are','was','were','be','by','this','an','or','from','at','which','but','not','have','has','had','they','their','them','its','if','we','you','I','he','she','his','her','will','can'
  ]);
  const words = (text.toLowerCase().match(/\b[a-z0-9']+\b/g) || []).filter(w => !stopwords.has(w));
  const freq = {};
  words.forEach(w => freq[w] = (freq[w] || 0) + 1);
  // normalize frequencies (divide by max)
  const max = Math.max(1, ...Object.values(freq));
  Object.keys(freq).forEach(k => freq[k] = freq[k] / max);
  return freq;
}
</script>
