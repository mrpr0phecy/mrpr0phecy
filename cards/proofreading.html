<h2 id="proofreading-title" style="margin-top:0;">Proofreading & Style Checker</h2>

<form aria-describedby="proofreading-desc">
  <p id="proofreading-desc" class="small">Run a quick proofreading pass for clarity, concision, passive voice, sentence length, repeated words, and basic style consistency. Suggestions are non‑destructive until applied.</p>

  <div class="row">
    <div class="field" style="flex:1;">
      <label for="pf-text">Text</label>
      <textarea id="pf-text" rows="10" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit;" placeholder="Paste your paragraph, essay, or article here..."></textarea>
    </div>
  </div>

  <div class="row" style="margin-top:8px;align-items:center;gap:12px;">
    <div class="field">
      <label style="display:inline-flex;align-items:center;gap:8px;">
        <input id="pf-explain" type="checkbox" />
        <span class="small">Explain suggestions</span>
      </label>
    </div>

    <div class="field">
      <label style="display:inline-flex;align-items:center;gap:8px;">
        <input id="pf-check-passive" type="checkbox" checked />
        <span class="small">Flag passive voice</span>
      </label>
    </div>

    <div class="field" style="margin-left:auto;">
      <label for="pf-max-sent" class="small">Max sentence length</label>
      <input id="pf-max-sent" type="number" min="20" max="200" value="28" style="width:80px;" />
    </div>
  </div>

  <div class="actions" style="margin-top:10px;">
    <button type="button" onclick="pfCheck(this)">Run Proofread</button>
    <button type="button" class="secondary" onclick="pfReset(this)">Reset</button>
    <button type="button" onclick="pfApplyAll(this)">Apply All Safe Fixes</button>
    <button type="button" onclick="pfCopy(this)">Copy Text</button>
  </div>
</form>

<div class="results" aria-live="polite" style="margin-top:12px;">
  <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
    <div class="small">Readability (Flesch): <strong id="pf-flesch">–</strong></div>
    <div class="small">Avg sentence length: <strong id="pf-avg-sent">–</strong></div>
    <div class="small">Word count: <strong id="pf-wordcount">0</strong></div>
    <div class="small">Passive sentences: <strong id="pf-passive-count">0</strong></div>
  </div>

  <h3 class="small" style="margin-top:12px;">Suggestions</h3>
  <ul id="pf-suggestions" class="small" style="list-style:none;padding-left:0;max-height:360px;overflow:auto;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;"></ul>
</div>

<script>
/*
  Proofreading & Style Checker
  - Client-side heuristics for clarity and style: passive voice, long sentences, wordiness, repeated words, filler words, weak verbs, and simple readability scoring (Flesch Reading Ease).
  - Suggestions are presented and can be applied individually or all safe fixes at once.
  - All DOM queries scoped via btn.closest('.card') so multiple instances are safe.
*/

function pfReset(btn) {
  const card = btn.closest('.card');
  card.querySelector('#pf-text').value = "";
  card.querySelector('#pf-suggestions').innerHTML = "";
  card.querySelector('#pf-flesch').textContent = "–";
  card.querySelector('#pf-avg-sent').textContent = "–";
  card.querySelector('#pf-wordcount').textContent = "0";
  card.querySelector('#pf-passive-count').textContent = "0";
}

function pfCopy(btn) {
  const card = btn.closest('.card');
  const text = card.querySelector('#pf-text').value || "";
  if (!text.trim()) return;
  navigator.clipboard?.writeText(text).then(() => {
    const prev = card.querySelector('#pf-flesch').textContent;
    card.querySelector('#pf-flesch').textContent = "Copied";
    setTimeout(() => { card.querySelector('#pf-flesch').textContent = prev; }, 1200);
  }).catch(() => {
    alert("Copy failed — select the text and copy manually.");
  });
}

function pfCheck(btn) {
  const card = btn.closest('.card');
  const text = (card.querySelector('#pf-text').value || "").trim();
  const explain = card.querySelector('#pf-explain').checked;
  const flagPassive = card.querySelector('#pf-check-passive').checked;
  const maxSent = parseInt(card.querySelector('#pf-max-sent').value, 10) || 28;

  if (!text) {
    card.querySelector('#pf-suggestions').innerHTML = `<li class="small" style="padding:8px;">Paste some text to proofread.</li>`;
    return;
  }

  const sentences = splitSentences(text);
  const words = text.split(/\s+/).filter(Boolean);
  const syllables = words.reduce((sum, w) => sum + countSyllables(w), 0);
  const avgSentLen = (words.length / Math.max(1, sentences.length)).toFixed(1);

  // Flesch Reading Ease: 206.835 - 1.015*(words/sentences) - 84.6*(syllables/words)
  const flesch = Math.round(206.835 - 1.015 * (words.length / Math.max(1, sentences.length)) - 84.6 * (syllables / Math.max(1, words.length)));

  card.querySelector('#pf-flesch').textContent = flesch;
  card.querySelector('#pf-avg-sent').textContent = avgSentLen;
  card.querySelector('#pf-wordcount').textContent = words.length.toString();

  const suggestions = [];

  // 1) Long sentences
  sentences.forEach((s, i) => {
    const wcount = s.split(/\s+/).filter(Boolean).length;
    if (wcount > maxSent) {
      suggestions.push({
        index: text.indexOf(s),
        length: s.length,
        original: s,
        replacement: null,
        message: `Long sentence (${wcount} words). Consider splitting into shorter sentences.`,
        severity: 'suggestion',
        type: 'long-sentence',
        meta: { sentenceIndex: i, words: wcount }
      });
    }
  });

  // 2) Passive voice detection (simple heuristics)
  const passiveMatches = [];
  if (flagPassive) {
    const passiveRegex = /\b(am|is|are|was|were|be|been|being)\s+([a-z]+ed|[a-z]+en|[a-z]+n)\b/gi;
    let m;
    while ((m = passiveRegex.exec(text)) !== null) {
      // capture a short surrounding context
      const start = Math.max(0, m.index - 30);
      const end = Math.min(text.length, m.index + m[0].length + 30);
      const context = text.slice(start, end);
      passiveMatches.push({ index: m.index, length: m[0].length, original: m[0], context });
    }
    passiveMatches.forEach(p => {
      suggestions.push({
        index: p.index,
        length: p.length,
        original: p.original,
        replacement: null,
        message: `Possible passive voice: "${p.original.trim()}". Consider using an active verb (who performed the action?).`,
        severity: 'note',
        type: 'passive',
        meta: { context: p.context }
      });
    });
  }
  card.querySelector('#pf-passive-count').textContent = passiveMatches.length;

  // 3) Wordiness / filler words
  const filler = ['very', 'really', 'actually', 'basically', 'literally', 'just', 'quite', 'that'];
  const fillerRegex = new RegExp('\\b(' + filler.join('|') + ')\\b', 'gi');
  let fm;
  while ((fm = fillerRegex.exec(text)) !== null) {
    suggestions.push({
      index: fm.index,
      length: fm[0].length,
      original: fm[0],
      replacement: null,
      message: `Consider removing or replacing the filler word "${fm[0]}" to tighten prose.`,
      severity: 'minor',
      type: 'filler'
    });
  }

  // 4) Repeated words (adjacent or close repeats)
  const repeatRegex = /\b([A-Za-z']+)\b(?:[\s\S]{0,30}?\b\1\b)/gi;
  // We'll detect adjacent repeats first
  const adjacentRepeat = /\b([A-Za-z']+)\s+\1\b/gi;
  let ar;
  while ((ar = adjacentRepeat.exec(text)) !== null) {
    suggestions.push({
      index: ar.index,
      length: ar[0].length,
      original: ar[0],
      replacement: ar[1],
      message: `Repeated word "${ar[1]}". Remove duplicate.`,
      severity: 'minor',
      type: 'repeat'
    });
  }

  // 5) Weak verbs -> suggest stronger alternatives (small curated map)
  const weakMap = {
    "make": ["create","produce","form"],
    "get": ["obtain","receive","acquire"],
    "have": ["possess","contain"],
    "do": ["perform","execute"],
    "show": ["demonstrate","reveal","illustrate"]
  };
  Object.keys(weakMap).forEach(w => {
    const rx = new RegExp('\\b' + w + '\\b', 'gi');
    let wm;
    while ((wm = rx.exec(text)) !== null) {
      suggestions.push({
        index: wm.index,
        length: wm[0].length,
        original: wm[0],
        replacement: null,
        message: `Consider a stronger verb than "${wm[0]}". Suggestions: ${weakMap[w].slice(0,3).join(', ')}.`,
        severity: 'note',
        type: 'weak-verb'
      });
    }
  });

  // 6) Passive punctuation/spacing issues (safe fixes)
  const spaceBeforePunct = /\s+([,.;:!?])/g;
  let sp;
  while ((sp = spaceBeforePunct.exec(text)) !== null) {
    suggestions.push({
      index: sp.index,
      length: sp[0].length,
      original: sp[0],
      replacement: sp[1],
      message: 'Remove space before punctuation',
      severity: 'minor',
      type: 'spacing'
    });
  }

  // 7) Sentence starters: many sentences starting with "And", "But", "So" — flag if frequent
  const starterRegex = /(?:^|[.!?]\s+)(\b(And|But|So|Also)\b)/g;
  let starters = 0;
  while ((m = starterRegex.exec(text)) !== null) starters++;
  if (starters > Math.max(2, Math.round(sentences.length * 0.08))) {
    suggestions.push({
      index: 0,
      length: 0,
      original: '',
      replacement: null,
      message: `Frequent sentence starters like "And/But/So" detected (${starters}). Consider varying sentence openings for flow.`,
      severity: 'note',
      type: 'starters'
    });
  }

  // Deduplicate suggestions by index+original
  const unique = [];
  const seen = new Set();
  suggestions.forEach(s => {
    const key = `${s.index}:${s.length}:${s.original}:${s.replacement || ''}:${s.message}`;
    if (!seen.has(key)) {
      unique.push(s);
      seen.add(key);
    }
  });

  renderPfSuggestions(card, unique, explain);
}

function renderPfSuggestions(card, suggestions, explain) {
  const list = card.querySelector('#pf-suggestions');
  list.innerHTML = "";

  if (!suggestions.length) {
    list.innerHTML = `<li class="small" style="padding:8px;">No suggestions found by this quick pass.</li>`;
    return;
  }

  // sort by index
  suggestions.sort((a,b) => a.index - b.index);

  suggestions.forEach((s, i) => {
    const li = document.createElement('li');
    li.style.padding = "10px";
    li.style.borderBottom = "1px solid rgba(255,255,255,0.03)";
    li.style.display = "flex";
    li.style.justifyContent = "space-between";
    li.style.alignItems = "flex-start";

    const left = document.createElement('div');
    left.style.flex = "1";

    const title = document.createElement('div');
    title.innerHTML = `<strong>${escapeHtml(s.message)}</strong>`;
    title.className = "small";
    left.appendChild(title);

    const context = document.createElement('div');
    context.className = "small";
    context.style.opacity = "0.9";
    const preview = s.original.length > 120 ? s.original.slice(0,120) + "…" : s.original;
    context.textContent = s.original ? `Context: "${preview}"` : '';
    left.appendChild(context);

    if (explain) {
      const explainDiv = document.createElement('div');
      explainDiv.className = "small";
      explainDiv.style.marginTop = "6px";
      explainDiv.style.opacity = "0.85";
      // provide tailored explanation for some types
      let explText = '';
      switch (s.type) {
        case 'long-sentence':
          explText = `Long sentences can reduce clarity. Try splitting at a natural pause or turning a clause into a separate sentence.`;
          break;
        case 'passive':
          explText = `Passive voice hides the actor. Rewriting with an active subject often improves clarity and directness.`;
          break;
        case 'filler':
          explText = `Filler words often add little meaning; removing them tightens the sentence.`;
          break;
        case 'repeat':
          explText = `Duplicate words are usually accidental; remove the extra occurrence.`;
          break;
        case 'weak-verb':
          explText = `Stronger verbs make writing more vivid and precise.`;
          break;
        case 'spacing':
          explText = `Spacing before punctuation is a typographic error; remove the extra space.`;
          break;
        default:
          explText = s.message;
      }
      explainDiv.textContent = explText;
      left.appendChild(explainDiv);
    }

    const actions = document.createElement('div');
    actions.style.display = "flex";
    actions.style.flexDirection = "column";
    actions.style.gap = "8px";
    actions.style.alignItems = "flex-end";

    if (s.replacement !== null) {
      const applyBtn = document.createElement('button');
      applyBtn.className = "tiny";
      applyBtn.textContent = `Apply`;
      applyBtn.onclick = () => applyPfSuggestion(card, s);
      actions.appendChild(applyBtn);
    } else {
      // offer a "Suggest" button that inserts a suggested rewrite into a prompt area (non-destructive)
      const suggestBtn = document.createElement('button');
      suggestBtn.className = "tiny";
      suggestBtn.textContent = "Mark for rewrite";
      suggestBtn.onclick = () => {
        // highlight the sentence in the textarea for manual editing
        highlightSentenceInTextarea(card, s);
      };
      actions.appendChild(suggestBtn);
    }

    li.appendChild(left);
    li.appendChild(actions);
    list.appendChild(li);
  });
}

/* Apply single suggestion (safe replacements only) */
function applyPfSuggestion(card, s) {
  const textEl = card.querySelector('#pf-text');
  let text = textEl.value || "";

  const current = text.slice(s.index, s.index + s.length);
  if (current !== s.original) {
    // try to find a nearby match
    const foundAt = text.indexOf(s.original);
    if (foundAt !== -1) {
      text = text.slice(0, foundAt) + (s.replacement !== null ? s.replacement : s.original) + text.slice(foundAt + s.length);
    } else {
      alert('Could not apply suggestion automatically because the text changed. Please apply manually.');
      return;
    }
  } else {
    text = text.slice(0, s.index) + (s.replacement !== null ? s.replacement : s.original) + text.slice(s.index + s.length);
  }

  textEl.value = text;
  // re-run check
  pfCheck(card.querySelector('button'));
}

/* Apply all safe fixes (replacements provided) */
function pfApplyAll(btn) {
  const card = btn.closest('.card');
  const textEl = card.querySelector('#pf-text');
  let text = textEl.value || "";

  // re-run analysis to get current suggestions
  const tempBtn = { closest: () => card };
  pfCheck(tempBtn); // updates suggestions in DOM
  const listEl = card.querySelector('#pf-suggestions');

  // collect suggestions with replacements by re-analyzing programmatically
  // safer: call pfCheck logic indirectly by parsing current suggestions in DOM and applying replacements left-to-right
  const replacements = [];
  listEl.querySelectorAll('li').forEach(li => {
    const msg = li.querySelector('div strong')?.textContent || '';
    const applyBtn = li.querySelector('button');
    // if apply button exists, we assume a replacement is available and stored in the suggestion object previously rendered
    // but DOM doesn't hold replacement text; instead, re-run analysis and gather programmatic suggestions
  });

  // Instead, re-run pfCheck logic to get programmatic suggestions
  // We'll call the internal analyzer by simulating a button context
  const cardContext = card;
  // Recompute suggestions programmatically (duplicate of pfCheck internals but returning array)
  const programmatic = computePfSuggestions(cardContext);
  // apply replacements sorted by index descending to avoid shifting indices
  programmatic
    .filter(s => s.replacement !== null)
    .sort((a,b) => b.index - a.index)
    .forEach(s => {
      text = text.slice(0, s.index) + s.replacement + text.slice(s.index + s.length);
    });

  textEl.value = text;
  // re-run check
  pfCheck(card.querySelector('button'));
}

/* Helper to compute suggestions programmatically (used by Apply All) */
function computePfSuggestions(card) {
  const text = (card.querySelector('#pf-text').value || "").trim();
  const flagPassive = card.querySelector('#pf-check-passive').checked;
  const maxSent = parseInt(card.querySelector('#pf-max-sent').value, 10) || 28;
  if (!text) return [];

  const sentences = splitSentences(text);
  const suggestions = [];

  // spacing fixes
  const spaceBeforePunct = /\s+([,.;:!?])/g;
  let sp;
  while ((sp = spaceBeforePunct.exec(text)) !== null) {
    suggestions.push({ index: sp.index, length: sp[0].length, original: sp[0], replacement: sp[1], message: 'Remove space before punctuation', type: 'spacing' });
  }

  // adjacent repeated words
  const adjacentRepeat = /\b([A-Za-z']+)\s+\1\b/gi;
  let ar;
  while ((ar = adjacentRepeat.exec(text)) !== null) {
    suggestions.push({ index: ar.index, length: ar[0].length, original: ar[0], replacement: ar[1], message: `Remove repeated word "${ar[1]}"`, type: 'repeat' });
  }

  // other suggestions (non-replacement) are not included here
  // return unique by index+original
  const unique = [];
  const seen = new Set();
  suggestions.forEach(s => {
    const key = `${s.index}:${s.length}:${s.original}:${s.replacement || ''}`;
    if (!seen.has(key)) {
      unique.push(s);
      seen.add(key);
    }
  });
  return unique;
}

/* Utility: highlight sentence in textarea for manual edit */
function highlightSentenceInTextarea(card, s) {
  const ta = card.querySelector('#pf-text');
  if (!ta) return;
  // try to find the original substring in current text
  const text = ta.value || "";
  const foundAt = text.indexOf(s.original);
  if (foundAt === -1) {
    alert('Could not locate the sentence to highlight. Please edit manually.');
    return;
  }
  ta.focus();
  ta.setSelectionRange(foundAt, foundAt + s.length);
}

/* Basic sentence splitter */
function splitSentences(text) {
  const raw = text.replace(/\r\n/g, '\n').replace(/\n+/g, ' ');
  const parts = raw.match(/[^.!?]+[.!?]?/g) || [];
  return parts.map(p => p.trim()).filter(Boolean);
}

/* Very small syllable counter heuristic */
function countSyllables(word) {
  if (!word) return 0;
  word = word.toLowerCase().replace(/[^a-z]/g, '');
  if (word.length <= 3) return 1;
  // remove silent e
  word = word.replace(/e$/,'');
  const matches = word.match(/[aeiouy]{1,2}/g);
  return matches ? matches.length : 1;
}

/* small utility */
function escapeHtml(s) {
  if (!s) return "";
  return s.replace(/[&<>"']/g, function (m) {
    return ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[m];
  });
}

/* Initialize: nothing to run automatically; functions are invoked by buttons */
</script>
