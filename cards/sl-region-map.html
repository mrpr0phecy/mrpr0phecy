<h2 id="sl-region-map-viewer" style="margin-top:0;">SL Region Map Viewer</h2>

<form aria-describedby="sl-region-map-desc">
  <p id="sl-region-map-desc" class="small">
    Enter a Second Life region name and view its map from slgrid. The tool will try single-image endpoints first, then a tile-based approach. Use a CORS proxy if direct fetches fail.
  </p>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
    <div class="field">
      <label for="sl-region-name">Region Name</label>
      <input id="sl-region-name" type="text" placeholder="e.g. Solace" style="width:100%;" />
    </div>

    <div class="field">
      <label for="sl-proxy">CORS Proxy (optional)</label>
      <select id="sl-proxy" style="width:100%;">
        <option value="">None (direct)</option>
        <option value="https://api.allorigins.win/raw?url=">AllOrigins (public)</option>
        <option value="https://cors.bridged.cc/">bridged.cc (public)</option>
      </select>
    </div>

    <div class="field">
      <label for="sl-x">Marker X (0–255)</label>
      <input id="sl-x" type="number" min="0" max="255" placeholder="optional" style="width:100%;" />
    </div>

    <div class="field">
      <label for="sl-y">Marker Y (0–255)</label>
      <input id="sl-y" type="number" min="0" max="255" placeholder="optional" style="width:100%;" />
    </div>
  </div>

  <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
    <button type="button" onclick="slLoadMap(this)">Load Map</button>
    <button type="button" class="secondary" onclick="slResetMap(this)">Reset</button>
  </div>
</form>

<div style="margin-top:12px;">
  <div id="sl-map-container" style="position:relative;border:1px solid rgba(0,0,0,0.08);overflow:hidden;">
    <canvas id="sl-map-canvas" style="display:block;width:100%;height:auto;max-height:640px;background:#111;"></canvas>
  </div>
  <div id="sl-map-hint" class="small" style="margin-top:8px;opacity:0.9;"></div>
</div>

<script>
/* SL Region Map Viewer (single-image + tile fallback)
   - Tries common slgrid single-image endpoints first.
   - If single-image fetch fails, attempts tile mode using common tile URL patterns.
   - Supports optional CORS proxy prefix.
   - Renders to a high-resolution canvas and supports pan/zoom and a region marker (0-255 coords).
*/

const canvas = document.getElementById('sl-map-canvas');
const ctx = canvas.getContext('2d');
let img = null;
let tileMode = false;
let tiles = {}; // cache loaded tiles keyed by z/x/y
let tileSize = 256;
let baseZoom = 0; // zoom level used for tiles
let mapWidth = 0, mapHeight = 0;
let scale = 1, offsetX = 0, offsetY = 0;
let isPanning = false, panStart = {}, panOrigin = {};

function slResetMap(btn){
  const card = btn.closest('.card') || document;
  card.querySelector('form').reset();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  document.getElementById('sl-map-hint').textContent = "";
  img = null;
  tileMode = false;
  tiles = {};
  scale = 1; offsetX = 0; offsetY = 0;
}

function buildSingleImageCandidates(region){
  const r = encodeURIComponent(region.trim());
  return [
    `https://slgrid.org/map/${r}.png`,
    `https://slgrid.org/map/${r}.jpg`,
    `https://slgrid.org/map/${r}.gif`,
    `https://maps.secondlife.com/map/${r}.png`,
    `https://secondlife.com/map/${r}.png`,
    // older or alternate hosts
    `https://slurl.com/region/${r}/map.png`
  ];
}

function buildTileUrlCandidates(region, z, x, y){
  // Try several plausible tile URL patterns used by SL grids (best-effort)
  const r = encodeURIComponent(region.trim());
  return [
    `https://slgrid.org/tiles/${r}/${z}/${x}/${y}.png`,
    `https://slgrid.org/tiles/${z}/${x}/${y}.png?region=${r}`,
    `https://slgrid.org/map/${r}/${z}/${x}/${y}.png`,
    `https://maps.secondlife.com/tiles/${z}/${x}/${y}.png?region=${r}`,
    `https://secondlife.com/tiles/${z}/${x}/${y}.png?region=${r}`
  ];
}

async function tryFetchImageAsObjectUrl(url, proxyPrefix){
  try {
    const fetchUrl = proxyPrefix ? proxyPrefix + encodeURIComponent(url) : url;
    const res = await fetch(fetchUrl, {mode:'cors'});
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const blob = await res.blob();
    if(!blob.type.startsWith('image/')) throw new Error('Not an image');
    return URL.createObjectURL(blob);
  } catch (e) {
    return null;
  }
}

async function slLoadMap(btn){
  const card = btn.closest('.card') || document;
  const region = card.querySelector('#sl-region-name').value.trim();
  const proxy = card.querySelector('#sl-proxy').value || "";
  const xVal = card.querySelector('#sl-x').value;
  const yVal = card.querySelector('#sl-y').value;
  const hint = card.querySelector('#sl-map-hint');

  if(!region){
    hint.textContent = "Please enter a region name.";
    return;
  }

  hint.textContent = "Attempting to load single-image map from slgrid…";
  const singleCandidates = buildSingleImageCandidates(region);
  let objectUrl = null;

  // Try single-image endpoints
  for(const u of singleCandidates){
    objectUrl = await tryFetchImageAsObjectUrl(u, "");
    if(objectUrl){ hint.textContent = `Loaded map image from ${u}`; break; }
  }

  // If direct single-image failed and proxy selected, try via proxy
  if(!objectUrl && proxy){
    for(const u of singleCandidates){
      objectUrl = await tryFetchImageAsObjectUrl(u, proxy);
      if(objectUrl){ hint.textContent = `Loaded map image via proxy from ${u}`; break; }
    }
  }

  if(objectUrl){
    tileMode = false;
    loadSingleImage(objectUrl, xVal, yVal);
    return;
  }

  // Single-image failed — try tile mode
  hint.textContent = "Single-image not available; attempting tile-based map (this may take a moment)…";
  tileMode = true;
  tiles = {};
  baseZoom = 0; // start with zoom 0 (single tile) and increase if needed

  // We'll attempt a small set of zoom levels to find tiles that exist
  const tryZooms = [0,1,2,3,4];
  let found = false;
  for(const z of tryZooms){
    // try to fetch a single tile at center coordinates (x=0,y=0) using candidate patterns
    const x = 0, y = 0;
    const candidates = buildTileUrlCandidates(region, z, x, y);
    for(const c of candidates){
      const obj = await tryFetchImageAsObjectUrl(c, "");
      if(obj){
        found = true;
        baseZoom = z;
        hint.textContent = `Tile server responded at zoom ${z} using pattern ${c}`;
        // release object URL after using as test
        URL.revokeObjectURL(obj);
        break;
      }
    }
    if(found) break;
    // try via proxy if not found
    if(proxy){
      for(const c of candidates){
        const obj = await tryFetchImageAsObjectUrl(c, proxy);
        if(obj){
          found = true;
          baseZoom = z;
          hint.textContent = `Tile server responded via proxy at zoom ${z} using pattern ${c}`;
          URL.revokeObjectURL(obj);
          break;
        }
      }
      if(found) break;
    }
  }

  if(!found){
    hint.textContent = "Unable to reach slgrid single-image or tile endpoints. Try a different region name or enable a CORS proxy.";
    return;
  }

  // If we found a working zoom, render tiles around a center tile to form a map
  // We'll render a 4x4 tile grid centered at (0,0) at baseZoom as a reasonable default
  mapWidth = tileSize * 4;
  mapHeight = tileSize * 4;
  canvas.width = mapWidth;
  canvas.height = mapHeight;
  canvas.style.width = Math.min(mapWidth, window.innerWidth - 80) + 'px';
  canvas.style.height = Math.round(canvas.width / (mapWidth / mapHeight)) + 'px';
  scale = 1; offsetX = 0; offsetY = 0;

  // load tiles for a small grid centered at tileX=0,tileY=0
  const centerX = 0, centerY = 0;
  const radius = 2; // 4x4
  const loadPromises = [];
  for(let dx = -radius; dx < radius; dx++){
    for(let dy = -radius; dy < radius; dy++){
      const tx = centerX + dx;
      const ty = centerY + dy;
      loadPromises.push(loadTile(region, baseZoom, tx, ty, proxy));
    }
  }
  await Promise.all(loadPromises);
  drawTilesAndMarker(xVal, yVal);
}

// Load a single tile into cache (tries candidate patterns)
async function loadTile(region, z, x, y, proxy){
  const key = `${z}/${x}/${y}`;
  if(tiles[key]) return tiles[key];
  const candidates = buildTileUrlCandidates(region, z, x, y);
  for(const c of candidates){
    const obj = await tryFetchImageAsObjectUrl(c, "");
    if(obj){
      const image = await createImageFromObjectUrl(obj);
      tiles[key] = {image, z, x, y};
      return tiles[key];
    }
  }
  // try via proxy if provided
  if(proxy){
    for(const c of candidates){
      const obj = await tryFetchImageAsObjectUrl(c, proxy);
      if(obj){
        const image = await createImageFromObjectUrl(obj);
        tiles[key] = {image, z, x, y};
        return tiles[key];
      }
    }
  }
  // tile not found — leave empty placeholder
  tiles[key] = null;
  return null;
}

function createImageFromObjectUrl(objUrl){
  return new Promise((resolve, reject) => {
    const i = new Image();
    i.crossOrigin = "anonymous";
    i.onload = () => { resolve(i); URL.revokeObjectURL(objUrl); };
    i.onerror = () => { URL.revokeObjectURL(objUrl); resolve(null); };
    i.src = objUrl;
  });
}

function loadSingleImage(objectUrl, xVal, yVal){
  img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = () => {
    // set canvas to image natural size for crispness, scale to container width
    mapWidth = img.naturalWidth;
    mapHeight = img.naturalHeight;
    canvas.width = mapWidth;
    canvas.height = mapHeight;
    canvas.style.width = Math.min(mapWidth, window.innerWidth - 80) + 'px';
    canvas.style.height = Math.round(canvas.width / (mapWidth / mapHeight)) + 'px';
    scale = 1; offsetX = 0; offsetY = 0;
    drawSingleImageAndMarker(xVal, yVal);
    document.getElementById('sl-map-hint').textContent += " · Use mouse wheel to zoom and drag to pan.";
  };
  img.onerror = () => {
    document.getElementById('sl-map-hint').textContent = "Failed to decode the map image.";
  };
  img.src = objectUrl;
}

function drawSingleImageAndMarker(xVal, yVal){
  if(!img || !img.complete) return;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
  ctx.drawImage(img, 0, 0);

  // optional grid overlay
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1/scale;
  const cell = canvas.width / 256;
  for(let i=0;i<=256;i+=32){
    ctx.beginPath();
    ctx.moveTo(i*cell, 0);
    ctx.lineTo(i*cell, canvas.height);
    ctx.stroke();
  }
  for(let j=0;j<=256;j+=32){
    ctx.beginPath();
    ctx.moveTo(0, j*cell);
    ctx.lineTo(canvas.width, j*cell);
    ctx.stroke();
  }

  if(xVal !== "" && yVal !== ""){
    const x = clamp(Number(xVal), 0, 255);
    const y = clamp(Number(yVal), 0, 255);
    const px = (x / 256) * canvas.width;
    const py = (y / 256) * canvas.height;
    drawMarker(px, py);
  }
}

function drawTilesAndMarker(xVal, yVal){
  // draw loaded tiles into canvas grid
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);

  // determine tile grid bounds from loaded tiles keys
  const keys = Object.keys(tiles).filter(k => tiles[k] && tiles[k].image);
  if(keys.length === 0){
    // nothing loaded
    ctx.fillStyle = "#111";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    return;
  }

  // For simplicity we render tiles relative to a center tile at canvas center
  // Find min/max x/y among loaded tiles
  let xs = [], ys = [];
  keys.forEach(k => {
    const [z,x,y] = k.split('/').map(Number);
    xs.push(x); ys.push(y);
  });
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const cols = maxX - minX + 1;
  const rows = maxY - minY + 1;
  const gridW = cols * tileSize;
  const gridH = rows * tileSize;

  // center grid on canvas
  const startX = Math.round((canvas.width - gridW)/2);
  const startY = Math.round((canvas.height - gridH)/2);

  for(const key of keys){
    const t = tiles[key];
    if(!t || !t.image) continue;
    const [z,x,y] = key.split('/').map(Number);
    const col = x - minX;
    const row = y - minY;
    const dx = startX + col * tileSize;
    const dy = startY + row * tileSize;
    ctx.drawImage(t.image, dx, dy, tileSize, tileSize);
  }

  // draw faint grid lines
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1/scale;
  for(let c=0;c<=cols;c++){
    const x = startX + c*tileSize;
    ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, startY + gridH); ctx.stroke();
  }
  for(let r=0;r<=rows;r++){
    const y = startY + r*tileSize;
    ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(startX + gridW, y); ctx.stroke();
  }

  // marker: map region coords (0-255) to grid pixel coordinates
  if(xVal !== "" && yVal !== ""){
    const x = clamp(Number(xVal), 0, 255);
    const y = clamp(Number(yVal), 0, 255);
    // map 0-255 to grid area
    const px = startX + (x/256) * gridW;
    const py = startY + (y/256) * gridH;
    drawMarker(px, py);
  }
}

function drawMarker(px, py){
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,80,80,0.95)';
  ctx.arc(px, py, 10/scale, 0, Math.PI*2);
  ctx.fill();
  ctx.lineWidth = 2/scale;
  ctx.strokeStyle = '#fff';
  ctx.stroke();
  ctx.restore();
}

// Canvas interactions: pan & zoom
canvas.addEventListener('wheel', e => {
  if((!img || !img.complete) && !tileMode) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
  const delta = -e.deltaY;
  const zoomFactor = delta > 0 ? 1.12 : 0.88;
  const newScale = clamp(scale * zoomFactor, 0.25, 8);
  offsetX = cx - (cx - offsetX) * (newScale / scale);
  offsetY = cy - (cy - offsetY) * (newScale / scale);
  scale = newScale;
  if(tileMode) drawTilesAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
  else drawSingleImageAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
});

canvas.addEventListener('mousedown', e => {
  isPanning = true;
  panStart = {x: e.clientX, y: e.clientY};
  panOrigin = {x: offsetX, y: offsetY};
  canvas.style.cursor = 'grabbing';
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  canvas.style.cursor = 'default';
});
window.addEventListener('mousemove', e => {
  if(!isPanning) return;
  const dx = e.clientX - panStart.x;
  const dy = e.clientY - panStart.y;
  offsetX = panOrigin.x + dx;
  offsetY = panOrigin.y + dy;
  if(tileMode) drawTilesAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
  else drawSingleImageAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
});

// Utility
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
</script>
