<h2 id="sl-region-map-title" style="margin-top:0;">SL Region Map Viewer</h2>

<form aria-describedby="sl-region-map-desc">
  <p id="sl-region-map-desc" class="small">
    Enter a Second Life region name and view its map from slgrid. Optionally add an X,Y marker (region coordinates 0–255).
  </p>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
    <div class="field">
      <label for="sl-region">Region Name</label>
      <input id="sl-region" type="text" placeholder="e.g. Solace" style="width:100%;" />
    </div>

    <div class="field">
      <label for="sl-proxy">Use CORS proxy (if needed)</label>
      <select id="sl-proxy" style="width:100%;">
        <option value="">None (direct)</option>
        <option value="https://api.allorigins.win/raw?url=">AllOrigins (public)</option>
        <option value="https://cors.bridged.cc/">bridged.cc (public)</option>
      </select>
    </div>

    <div class="field">
      <label for="sl-x">Marker X (0–255)</label>
      <input id="sl-x" type="number" min="0" max="255" placeholder="optional" style="width:100%;" />
    </div>

    <div class="field">
      <label for="sl-y">Marker Y (0–255)</label>
      <input id="sl-y" type="number" min="0" max="255" placeholder="optional" style="width:100%;" />
    </div>
  </div>

  <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
    <button type="button" onclick="slMapLoad(this)">Load Map</button>
    <button type="button" class="secondary" onclick="slMapReset(this)">Reset</button>
  </div>
</form>

<div style="margin-top:12px;">
  <div id="sl-map-wrap" style="position:relative;border:1px solid rgba(0,0,0,0.08);overflow:hidden;">
    <canvas id="sl-map-canvas" style="display:block;width:100%;height:auto;max-height:640px;background:#111;"></canvas>
  </div>
  <div id="sl-map-hint" class="small" style="margin-top:8px;opacity:0.9;"></div>
</div>

<script>
/*
  SL Region Map Viewer
  - Attempts to fetch a region map image from slgrid endpoints.
  - If CORS blocks the request, user can select a proxy from the dropdown.
  - Displays image on canvas with pan/zoom and optional marker at region X,Y (0-255).
*/

const slCanvas = document.getElementById('sl-map-canvas');
const slCtx = slCanvas.getContext('2d');
let slImg = new Image();
let scale = 1;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let startPan = {x:0,y:0};
let lastMouse = {x:0,y:0};

function slMapReset(btn){
  const card = btn.closest('.card') || document;
  card.querySelector('form').reset();
  slCtx.clearRect(0,0,slCanvas.width,slCanvas.height);
  document.getElementById('sl-map-hint').textContent = "";
  slImg = new Image();
  scale = 1; offsetX = 0; offsetY = 0;
}

function buildSlgridUrls(region){
  // Try common slgrid map endpoints (best-effort). These are attempted in order.
  const r = encodeURIComponent(region.trim());
  return [
    `https://slgrid.org/map/${r}.png`,
    `https://slgrid.org/map/${r}.jpg`,
    `https://slgrid.org/map/${r}.gif`,
    `https://maps.secondlife.com/map/${r}.png`,
    `https://secondlife.com/map/${r}.png`,
    // generic slurl fallback (may not return raw map image)
    `https://maps.secondlife.com/secondlife/${r}/128/128/0`
  ];
}

async function tryFetchImage(url, proxyPrefix){
  try {
    const fetchUrl = proxyPrefix ? proxyPrefix + encodeURIComponent(url) : url;
    const res = await fetch(fetchUrl, {mode: 'cors'});
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const blob = await res.blob();
    // quick check: ensure it's an image
    if(!blob.type.startsWith('image/')) throw new Error('Not an image');
    return URL.createObjectURL(blob);
  } catch (err) {
    return null;
  }
}

async function slMapLoad(btn){
  const card = btn.closest('.card') || document;
  const region = card.querySelector('#sl-region').value.trim();
  const proxy = card.querySelector('#sl-proxy').value || "";
  const xVal = card.querySelector('#sl-x').value;
  const yVal = card.querySelector('#sl-y').value;
  const hint = card.querySelector('#sl-map-hint');

  if(!region){
    hint.textContent = "Please enter a region name.";
    return;
  }

  hint.textContent = "Fetching map…";
  const urls = buildSlgridUrls(region);
  let objectUrl = null;

  // Try direct endpoints first, then with proxy if selected
  for(const u of urls){
    objectUrl = await tryFetchImage(u, "");
    if(objectUrl) { hint.textContent = `Loaded from ${u}`; break; }
  }

  if(!objectUrl && proxy){
    for(const u of urls){
      objectUrl = await tryFetchImage(u, proxy);
      if(objectUrl) { hint.textContent = `Loaded via proxy from ${u}`; break; }
    }
  }

  if(!objectUrl){
    hint.textContent = "Unable to fetch map directly. Try selecting a CORS proxy or check the region name.";
    return;
  }

  // Load image into canvas
  slImg = new Image();
  slImg.onload = () => {
    // Set canvas pixel size to image natural size for crispness, but scale to container width
    const containerWidth = Math.min(slImg.naturalWidth, Math.max(600, window.innerWidth - 80));
    const aspect = slImg.naturalWidth / slImg.naturalHeight;
    const displayW = containerWidth;
    const displayH = Math.round(displayW / aspect);

    slCanvas.width = slImg.naturalWidth;
    slCanvas.height = slImg.naturalHeight;
    slCanvas.style.width = displayW + 'px';
    slCanvas.style.height = displayH + 'px';

    // reset transforms
    scale = 1;
    offsetX = 0;
    offsetY = 0;

    drawMapAndMarker(xVal, yVal);
    hint.textContent += " · Use mouse wheel to zoom, drag to pan. Right-click image to save.";
  };
  slImg.onerror = () => {
    hint.textContent = "Loaded resource is not a valid image or failed to decode.";
  };
  slImg.src = objectUrl;
}

// Draw image and optional marker (region coords 0-255)
function drawMapAndMarker(xVal, yVal){
  if(!slImg || !slImg.complete) return;
  // clear
  slCtx.setTransform(1,0,0,1,0,0);
  slCtx.clearRect(0,0,slCanvas.width,slCanvas.height);

  // apply scale and offset (transform in canvas pixel space)
  slCtx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
  slCtx.drawImage(slImg, 0, 0);

  // draw grid overlay (optional faint)
  slCtx.strokeStyle = 'rgba(255,255,255,0.06)';
  slCtx.lineWidth = 1/scale;
  const cell = slImg.naturalWidth / 256; // assume 256x256 region grid
  for(let i=0;i<=256;i+=32){
    slCtx.beginPath();
    slCtx.moveTo(i*cell, 0);
    slCtx.lineTo(i*cell, slImg.naturalHeight);
    slCtx.stroke();
  }
  for(let j=0;j<=256;j+=32){
    slCtx.beginPath();
    slCtx.moveTo(0, j*cell);
    slCtx.lineTo(slImg.naturalWidth, j*cell);
    slCtx.stroke();
  }

  // marker
  if(xVal !== "" && yVal !== ""){
    const x = clamp(Number(xVal), 0, 255);
    const y = clamp(Number(yVal), 0, 255);
    const px = (x / 256) * slImg.naturalWidth;
    const py = (y / 256) * slImg.naturalHeight;
    slCtx.fillStyle = 'rgba(255,80,80,0.95)';
    slCtx.beginPath();
    slCtx.arc(px, py, 8/scale, 0, Math.PI*2);
    slCtx.fill();
    slCtx.strokeStyle = '#fff';
    slCtx.lineWidth = 2/scale;
    slCtx.stroke();
  }
}

// Canvas interaction: pan & zoom
slCanvas.addEventListener('wheel', e => {
  if(!slImg.complete) return;
  e.preventDefault();
  const rect = slCanvas.getBoundingClientRect();
  const cx = (e.clientX - rect.left) * (slCanvas.width / rect.width);
  const cy = (e.clientY - rect.top) * (slCanvas.height / rect.height);

  const delta = -e.deltaY;
  const zoomFactor = delta > 0 ? 1.12 : 0.88;
  const newScale = clamp(scale * zoomFactor, 0.25, 8);

  // adjust offset so zoom centers on cursor
  offsetX = cx - (cx - offsetX) * (newScale / scale);
  offsetY = cy - (cy - offsetY) * (newScale / scale);
  scale = newScale;
  drawMapAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
});

slCanvas.addEventListener('mousedown', e => {
  isPanning = true;
  startPan = {x: e.clientX, y: e.clientY};
  lastMouse = {x: offsetX, y: offsetY};
  slCanvas.style.cursor = 'grabbing';
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  slCanvas.style.cursor = 'default';
});
window.addEventListener('mousemove', e => {
  if(!isPanning) return;
  const dx = e.clientX - startPan.x;
  const dy = e.clientY - startPan.y;
  offsetX = lastMouse.x + dx;
  offsetY = lastMouse.y + dy;
  drawMapAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
});

// Utility
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
</script>
