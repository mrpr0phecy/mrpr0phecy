<h2 id="sl-region-map-card" style="margin-top:0;">SL Region Map Viewer</h2>

<!--
  Manifest metadata
  id: sl-region-map-card
  title: SL Region Map Viewer
  path: cards/sl-region-map-card.html
  category: Second Life Tools
  version: 1.1
-->

<form aria-describedby="sl-region-map-desc">
  <p id="sl-region-map-desc" class="small">
    Enter a Second Life region name and view its map from slgrid. This debug card attempts single-image endpoints, falls back to tile probes, and includes a direct URL override and a debug log to diagnose CORS or endpoint issues.
  </p>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
    <div class="field">
      <label for="sl-region-name">Region Name</label>
      <input id="sl-region-name" type="text" placeholder="e.g. Solace" style="width:100%;" />
    </div>

    <div class="field">
      <label for="sl-proxy">CORS Proxy (optional)</label>
      <select id="sl-proxy" style="width:100%;">
        <option value="">None (direct)</option>
        <option value="https://api.allorigins.win/raw?url=">AllOrigins (public)</option>
        <option value="https://cors.bridged.cc/">bridged.cc (public)</option>
      </select>
    </div>

    <div class="field">
      <label for="sl-direct-url">Direct map image URL (optional)</label>
      <input id="sl-direct-url" type="url" placeholder="https://example.com/region.png" style="width:100%;" />
    </div>

    <div class="field">
      <label for="sl-x">Marker X (0–255)</label>
      <input id="sl-x" type="number" min="0" max="255" placeholder="optional" style="width:100%;" />
    </div>

    <div class="field">
      <label for="sl-y">Marker Y (0–255)</label>
      <input id="sl-y" type="number" min="0" max="255" placeholder="optional" style="width:100%;" />
    </div>
  </div>

  <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;">
    <button type="button" onclick="slLoadMapDebug(this)">Load Map</button>
    <button type="button" onclick="slResetMap(this)" class="secondary">Reset</button>
  </div>
</form>

<div style="margin-top:12px;">
  <div id="sl-map-container" style="position:relative;border:1px solid rgba(0,0,0,0.08);overflow:hidden;">
    <canvas id="sl-map-canvas" style="display:block;width:100%;height:auto;max-height:640px;background:#111;"></canvas>
  </div>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px;">
    <div id="sl-map-hint" class="small" style="padding:8px;background:#fafafa;border-radius:6px;min-height:48px;"></div>
    <div id="sl-debug-log" class="small" style="white-space:pre-wrap;background:#111;color:#fff;padding:8px;border-radius:6px;max-height:160px;overflow:auto;"></div>
  </div>
</div>

<script>
/* SL Region Map Viewer Debug Card
   - Attempts single-image endpoints first, then tile probes
   - Direct URL override and detailed debug log for CORS/HTTP diagnostics
   - Pan/zoom and optional marker at region coords (0-255)
*/

const canvas = document.getElementById('sl-map-canvas');
const ctx = canvas.getContext('2d');
let img = null;
let tileMode = false;
let tiles = {};
let tileSize = 256;
let mapWidth = 0, mapHeight = 0;
let scale = 1, offsetX = 0, offsetY = 0;
let isPanning = false, panStart = {}, panOrigin = {};

function resizeCanvasToDisplay(){
  const rect = canvas.getBoundingClientRect();
  const DPR = window.devicePixelRatio || 1;
  canvas.width = Math.max(600, Math.floor(rect.width * DPR));
  canvas.height = Math.max(400, Math.floor(Math.min(640, rect.height) * DPR));
}
resizeCanvasToDisplay();
window.addEventListener('resize', ()=>{ resizeCanvasToDisplay(); if(img && img.complete) redrawCurrent(); });

function slResetMap(btn){
  const card = btn.closest('.card') || document;
  card.querySelector('form').reset();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  document.getElementById('sl-map-hint').textContent = "";
  document.getElementById('sl-debug-log').textContent = "";
  img = null;
  tileMode = false;
  tiles = {};
  scale = 1; offsetX = 0; offsetY = 0;
}

function buildSingleImageCandidates(region){
  const r = encodeURIComponent(region.trim());
  return [
    `https://slgrid.org/map/${r}.png`,
    `https://slgrid.org/map/${r}.jpg`,
    `https://slgrid.org/map/${r}.gif`,
    `https://maps.secondlife.com/map/${r}.png`,
    `https://secondlife.com/map/${r}.png`,
    `https://slurl.com/region/${r}/map.png`
  ];
}

function buildTileUrlCandidates(region, z, x, y){
  const r = encodeURIComponent(region.trim());
  return [
    `https://slgrid.org/tiles/${r}/${z}/${x}/${y}.png`,
    `https://slgrid.org/tiles/${z}/${x}/${y}.png?region=${r}`,
    `https://maps.secondlife.com/tiles/${z}/${x}/${y}.png?region=${r}`,
    `https://secondlife.com/tiles/${z}/${x}/${y}.png?region=${r}`
  ];
}

async function tryFetchImageAsObjectUrlDebug(url, proxyPrefix){
  const log = (m)=>{ const el=document.getElementById('sl-debug-log'); el.textContent += m + "\\n"; el.scrollTop = el.scrollHeight; };
  try {
    const fetchUrl = proxyPrefix ? proxyPrefix + encodeURIComponent(url) : url;
    log(`Attempting: ${fetchUrl}`);
    const res = await fetch(fetchUrl, {mode:'cors'});
    log(`→ HTTP ${res.status} ${res.statusText}`);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    const blob = await res.blob();
    log(`→ Received blob type: ${blob.type}`);
    if(!blob.type.startsWith('image/')) throw new Error('Response is not an image (type=' + blob.type + ')');
    const obj = URL.createObjectURL(blob);
    log('→ Image object URL created');
    return obj;
  } catch (err) {
    log('✖ Error: ' + err.message);
    return null;
  }
}

async function slLoadMapDebug(btn){
  const card = btn.closest('.card') || document;
  const region = card.querySelector('#sl-region-name').value.trim();
  const proxy = card.querySelector('#sl-proxy').value || "";
  const direct = card.querySelector('#sl-direct-url').value.trim();
  const xVal = card.querySelector('#sl-x').value;
  const yVal = card.querySelector('#sl-y').value;
  const hint = card.querySelector('#sl-map-hint');
  const logEl = document.getElementById('sl-debug-log');
  logEl.textContent = ''; // clear previous log

  if(direct){
    logEl.textContent = 'Using direct URL override.\\n';
    const obj = await tryFetchImageAsObjectUrlDebug(direct, '');
    if(obj){
      hint.textContent = 'Loaded direct image URL.';
      loadSingleImage(obj, xVal, yVal);
      return;
    } else {
      hint.textContent = 'Direct URL failed; see debug log.';
      return;
    }
  }

  if(!region){
    hint.textContent = "Please enter a region name or paste a direct image URL.";
    return;
  }

  hint.textContent = "Fetching map (debug mode)…";
  const singleCandidates = buildSingleImageCandidates(region);
  let objectUrl = null;

  // Try single-image endpoints (direct)
  for(const u of singleCandidates){
    objectUrl = await tryFetchImageAsObjectUrlDebug(u, "");
    if(objectUrl){ hint.textContent = `Loaded map image from ${u}`; break; }
  }

  // If direct single-image failed and proxy selected, try via proxy
  if(!objectUrl && proxy){
    for(const u of singleCandidates){
      objectUrl = await tryFetchImageAsObjectUrlDebug(u, proxy);
      if(objectUrl){ hint.textContent = `Loaded map image via proxy from ${u}`; break; }
    }
  }

  if(objectUrl){
    tileMode = false;
    loadSingleImage(objectUrl, xVal, yVal);
    return;
  }

  // Single-image failed — try tile mode probes
  logEl.textContent += '\\nSingle-image attempts failed. Probing tile endpoints...\\n';
  tileMode = true;
  tiles = {};
  let found = false;
  const tryZooms = [0,1,2,3];
  for(const z of tryZooms){
    const x = 0, y = 0;
    const candidates = buildTileUrlCandidates(region, z, x, y);
    for(const c of candidates){
      const obj = await tryFetchImageAsObjectUrlDebug(c, "");
      if(obj){
        found = true;
        logEl.textContent += `Tile server responded at zoom ${z} using pattern ${c}\\n`;
        URL.revokeObjectURL(obj);
        break;
      }
    }
    if(found) break;
    if(proxy){
      for(const c of candidates){
        const obj = await tryFetchImageAsObjectUrlDebug(c, proxy);
        if(obj){
          found = true;
          logEl.textContent += `Tile server responded via proxy at zoom ${z} using pattern ${c}\\n`;
          URL.revokeObjectURL(obj);
          break;
        }
      }
      if(found) break;
    }
  }

  if(!found){
    hint.textContent = "Unable to reach slgrid single-image or tile endpoints. Check debug log, try a different region name, or enable a CORS proxy.";
    return;
  }

  // Render a small tile grid around center as a fallback preview
  mapWidth = tileSize * 4;
  mapHeight = tileSize * 4;
  canvas.width = mapWidth;
  canvas.height = mapHeight;
  canvas.style.width = Math.min(mapWidth, window.innerWidth - 80) + 'px';
  canvas.style.height = Math.round(canvas.width / (mapWidth / mapHeight)) + 'px';
  scale = 1; offsetX = 0; offsetY = 0;

  // load tiles for a 4x4 grid centered at (0,0)
  const centerX = 0, centerY = 0;
  const radius = 2;
  const loadPromises = [];
  for(let dx = -radius; dx < radius; dx++){
    for(let dy = -radius; dy < radius; dy++){
      const tx = centerX + dx;
      const ty = centerY + dy;
      loadPromises.push(loadTile(region, 0, tx, ty, proxy));
    }
  }
  await Promise.all(loadPromises);
  drawTilesAndMarker(xVal, yVal);
  hint.textContent = "Tile preview rendered. See debug log for attempted URLs.";
}

async function loadTile(region, z, x, y, proxy){
  const key = `${z}/${x}/${y}`;
  if(tiles[key]) return tiles[key];
  const candidates = buildTileUrlCandidates(region, z, x, y);
  for(const c of candidates){
    const obj = await tryFetchImageAsObjectUrlDebug(c, "");
    if(obj){
      const image = await createImageFromObjectUrl(obj);
      tiles[key] = {image, z, x, y};
      return tiles[key];
    }
  }
  if(proxy){
    for(const c of candidates){
      const obj = await tryFetchImageAsObjectUrlDebug(c, proxy);
      if(obj){
        const image = await createImageFromObjectUrl(obj);
        tiles[key] = {image, z, x, y};
        return tiles[key];
      }
    }
  }
  tiles[key] = null;
  return null;
}

function createImageFromObjectUrl(objUrl){
  return new Promise((resolve) => {
    const i = new Image();
    i.crossOrigin = "anonymous";
    i.onload = () => { resolve(i); URL.revokeObjectURL(objUrl); };
    i.onerror = () => { URL.revokeObjectURL(objUrl); resolve(null); };
    i.src = objUrl;
  });
}

function loadSingleImage(objectUrl, xVal, yVal){
  img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = () => {
    mapWidth = img.naturalWidth;
    mapHeight = img.naturalHeight;
    // set canvas to image natural size for crispness, scale to container width
    canvas.width = mapWidth;
    canvas.height = mapHeight;
    canvas.style.width = Math.min(mapWidth, window.innerWidth - 80) + 'px';
    canvas.style.height = Math.round(canvas.width / (mapWidth / mapHeight)) + 'px';
    scale = 1; offsetX = 0; offsetY = 0;
    drawSingleImageAndMarker(xVal, yVal);
    document.getElementById('sl-map-hint').textContent += " · Use mouse wheel to zoom and drag to pan.";
  };
  img.onerror = () => {
    document.getElementById('sl-map-hint').textContent = "Failed to decode the map image.";
  };
  img.src = objectUrl;
}

function drawSingleImageAndMarker(xVal, yVal){
  if(!img || !img.complete) return;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
  ctx.drawImage(img, 0, 0);

  // faint grid overlay
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1/scale;
  const cell = canvas.width / 256;
  for(let i=0;i<=256;i+=32){
    ctx.beginPath();
    ctx.moveTo(i*cell, 0);
    ctx.lineTo(i*cell, canvas.height);
    ctx.stroke();
  }
  for(let j=0;j<=256;j+=32){
    ctx.beginPath();
    ctx.moveTo(0, j*cell);
    ctx.lineTo(canvas.width, j*cell);
    ctx.stroke();
  }

  if(xVal !== "" && yVal !== ""){
    const x = clamp(Number(xVal), 0, 255);
    const y = clamp(Number(yVal), 0, 255);
    const px = (x / 256) * canvas.width;
    const py = (y / 256) * canvas.height;
    drawMarker(px, py);
  }
}

function drawTilesAndMarker(xVal, yVal){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);

  const keys = Object.keys(tiles).filter(k => tiles[k] && tiles[k].image);
  if(keys.length === 0){
    ctx.fillStyle = "#111";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    return;
  }

  let xs = [], ys = [];
  keys.forEach(k => {
    const [z,x,y] = k.split('/').map(Number);
    xs.push(x); ys.push(y);
  });
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const cols = maxX - minX + 1;
  const rows = maxY - minY + 1;
  const gridW = cols * tileSize;
  const gridH = rows * tileSize;
  const startX = Math.round((canvas.width - gridW)/2);
  const startY = Math.round((canvas.height - gridH)/2);

  for(const key of keys){
    const t = tiles[key];
    if(!t || !t.image) continue;
    const [z,x,y] = key.split('/').map(Number);
    const col = x - minX;
    const row = y - minY;
    const dx = startX + col * tileSize;
    const dy = startY + row * tileSize;
    ctx.drawImage(t.image, dx, dy, tileSize, tileSize);
  }

  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  ctx.lineWidth = 1/scale;
  for(let c=0;c<=cols;c++){
    const x = startX + c*tileSize;
    ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, startY + gridH); ctx.stroke();
  }
  for(let r=0;r<=rows;r++){
    const y = startY + r*tileSize;
    ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(startX + gridW, y); ctx.stroke();
  }

  if(xVal !== "" && yVal !== ""){
    const x = clamp(Number(xVal), 0, 255);
    const y = clamp(Number(yVal), 0, 255);
    const px = startX + (x/256) * gridW;
    const py = startY + (y/256) * gridH;
    drawMarker(px, py);
  }
}

function drawMarker(px, py){
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = 'rgba(255,80,80,0.95)';
  ctx.arc(px, py, 10/scale, 0, Math.PI*2);
  ctx.fill();
  ctx.lineWidth = 2/scale;
  ctx.strokeStyle = '#fff';
  ctx.stroke();
  ctx.restore();
}

// Canvas pan & zoom
canvas.addEventListener('wheel', e => {
  if((!img || !img.complete) && !tileMode) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const cy = (e.clientY - rect.top) * (canvas.height / rect.height);
  const delta = -e.deltaY;
  const zoomFactor = delta > 0 ? 1.12 : 0.88;
  const newScale = clamp(scale * zoomFactor, 0.25, 8);
  offsetX = cx - (cx - offsetX) * (newScale / scale);
  offsetY = cy - (cy - offsetY) * (newScale / scale);
  scale = newScale;
  redrawCurrent();
});

canvas.addEventListener('mousedown', e => {
  isPanning = true;
  panStart = {x: e.clientX, y: e.clientY};
  panOrigin = {x: offsetX, y: offsetY};
  canvas.style.cursor = 'grabbing';
});
window.addEventListener('mouseup', () => {
  isPanning = false;
  canvas.style.cursor = 'default';
});
window.addEventListener('mousemove', e => {
  if(!isPanning) return;
  const dx = e.clientX - panStart.x;
  const dy = e.clientY - panStart.y;
  offsetX = panOrigin.x + dx;
  offsetY = panOrigin.y + dy;
  redrawCurrent();
});

function redrawCurrent(){
  if(tileMode) drawTilesAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
  else drawSingleImageAndMarker(document.getElementById('sl-x').value, document.getElementById('sl-y').value);
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
</script>
