<h2 id="sprite-cutter-title" style="margin-top:0;color:var(--accent);">üéÆ Sprite Sheet Studio</h2>

<form aria-describedby="sprite-cutter-desc">
  <p id="sprite-cutter-desc" class="small" style="color:var(--muted);margin-bottom:16px;">
    Advanced sprite sheet cutter for game developers. Slice, preview, animate, and export sprite sheets with professional tools.
    <span style="color:#ffcc00;">‚ú® Supports PNG, JPG, GIF, and WebP formats</span>
  </p>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:20px;">
    <div style="background:rgba(45,212,255,0.05);border-radius:8px;padding:16px;border:2px dashed rgba(45,212,255,0.3);">
      <label for="sprite-file" style="display:block;margin-bottom:12px;color:var(--accent);font-weight:500;text-align:center;">
        <div style="font-size:48px;margin-bottom:8px;">üìÅ</div>
        Upload Sprite Sheet
      </label>
      <input id="sprite-file" type="file" accept="image/*" 
             style="width:100%;padding:12px;border-radius:6px;border:1px solid rgba(45,212,255,0.3);background:rgba(255,255,255,0.05);color:inherit;cursor:pointer;" />
      <div class="small" style="color:var(--muted);margin-top:8px;text-align:center;">Drag & drop or click to select</div>
    </div>
    
    <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:16px;border:1px solid rgba(255,255,255,0.08);">
      <div style="font-weight:600;color:var(--accent);margin-bottom:12px;">üìê Frame Settings</div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
        <div>
          <label for="sprite-width" style="display:block;margin-bottom:6px;color:var(--accent);font-weight:500;">Frame Width (px)</label>
          <input id="sprite-width" type="number" min="1" value="64" 
                 style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.05);color:inherit;text-align:center;" />
        </div>
        
        <div>
          <label for="sprite-height" style="display:block;margin-bottom:6px;color:var(--accent);font-weight:500;">Frame Height (px)</label>
          <input id="sprite-height" type="number" min="1" value="64" 
                 style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.05);color:inherit;text-align:center;" />
        </div>
      </div>
      
      <div style="margin-bottom:12px;">
        <label for="sprite-padding" style="display:block;margin-bottom:6px;color:var(--accent);font-weight:500;">
          Spacing: <span id="sprite-padding-value">0</span>px
        </label>
        <input id="sprite-padding" type="range" min="0" max="20" value="0" 
               style="width:100%;height:6px;background:rgba(45,212,255,0.2);border-radius:3px;cursor:pointer;" />
      </div>
      
      <div style="display:flex;gap:8px;margin-top:8px;">
        <button type="button" onclick="spriteAutoDetect()" style="flex:1;padding:8px;background:rgba(45,212,255,0.1);border:1px solid rgba(45,212,255,0.3);border-radius:6px;color:var(--accent);cursor:pointer;font-size:12px;">
          üîç Auto-detect
        </button>
        <button type="button" onclick="spriteCommonPreset(32)" style="padding:8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;">
          32px
        </button>
        <button type="button" onclick="spriteCommonPreset(64)" style="padding:8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;">
          64px
        </button>
        <button type="button" onclick="spriteCommonPreset(128)" style="padding:8px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;">
          128px
        </button>
      </div>
    </div>
  </div>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:20px;">
    <div>
      <label for="sprite-mode" style="display:block;margin-bottom:8px;color:var(--accent);font-weight:500;">Cutting Mode</label>
      <select id="sprite-mode" 
              style="width:100%;padding:12px;border-radius:8px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.05);color:inherit;cursor:pointer;">
        <option value="grid" selected>üéØ Grid-Based (Uniform)</option>
        <option value="fixed">üìè Fixed Size Grid</option>
        <option value="rows">üìê Row-Based (Variable Height)</option>
        <option value="columns">üìê Column-Based (Variable Width)</option>
        <option value="free">üé® Free Selection (Coming Soon)</option>
      </select>
    </div>
    
    <div>
      <label for="sprite-output-format" style="display:block;margin-bottom:8px;color:var(--accent);font-weight:500;">Output Format</label>
      <select id="sprite-output-format" 
              style="width:100%;padding:12px;border-radius:8px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.05);color:inherit;cursor:pointer;">
        <option value="png" selected>PNG (Lossless)</option>
        <option value="jpg">JPG (Compressed)</option>
        <option value="webp">WebP (Modern)</option>
        <option value="zip">ZIP Package</option>
        <option value="gif">Animated GIF</option>
        <option value="spritesheet">Single Spritesheet</option>
      </select>
    </div>
  </div>

  <div style="display:flex;gap:10px;margin-top:20px;flex-wrap:wrap;">
    <button type="button" onclick="spriteCut(this)" id="sprite-cut-btn"
            style="flex:1;padding:12px;background:linear-gradient(135deg, rgba(57,255,20,0.2), rgba(57,255,20,0.1));border:1px solid rgba(57,255,20,0.4);border-radius:8px;color:#39ff14;cursor:pointer;font-weight:600;min-width:140px;">
      ‚úÇÔ∏è Cut Sprite Sheet
    </button>
    <button type="button" onclick="spritePreviewAnimation(this)" id="sprite-animate-btn" disabled
            style="padding:12px 16px;background:rgba(255,105,180,0.1);border:1px solid rgba(255,105,180,0.3);border-radius:8px;color:#ff69b4;cursor:pointer;">
      üé¨ Preview Animation
    </button>
    <button type="button" onclick="spriteExportAll(this)" id="sprite-export-btn" disabled
            style="padding:12px 16px;background:rgba(255,165,0,0.1);border:1px solid rgba(255,165,0,0.3);border-radius:8px;color:#ffa500;cursor:pointer;">
      üíæ Export All
    </button>
    <button type="button" onclick="spriteReset(this)"
            style="padding:12px 16px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:8px;color:inherit;cursor:pointer;">
      üîÑ Reset
    </button>
  </div>
</form>

<div aria-live="polite" style="margin-top:20px;">
  <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:16px;border:1px solid rgba(255,255,255,0.08);margin-bottom:16px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <div style="font-weight:600;color:var(--accent);">üìä Sprite Information</div>
      <div id="sprite-stats" class="small" style="color:var(--muted);">
        <span id="sprite-frames-count">0</span> frames ‚Ä¢ <span id="sprite-grid-size">0√ó0</span> grid
      </div>
    </div>
    
    <div id="sprite-preview-container" style="text-align:center;">
      <div id="sprite-sheet-preview" style="max-width:100%;max-height:200px;overflow:auto;background:rgba(0,0,0,0.3);border-radius:8px;padding:12px;margin-bottom:12px;">
        <div style="color:var(--muted);padding:40px;">Upload a sprite sheet to preview</div>
      </div>
    </div>
  </div>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:20px;">
    <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:16px;border:1px solid rgba(255,255,255,0.08);">
      <div style="font-weight:600;color:var(--accent);margin-bottom:12px;">‚öôÔ∏è Animation Settings</div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
        <div>
          <label for="sprite-fps" style="display:block;margin-bottom:6px;color:var(--accent);font-weight:500;">FPS</label>
          <input id="sprite-fps" type="number" min="1" max="60" value="12" 
                 style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.05);color:inherit;text-align:center;" />
        </div>
        
        <div>
          <label for="sprite-loop" style="display:block;margin-bottom:6px;color:var(--accent);font-weight:500;">Loop</label>
          <select id="sprite-loop" 
                  style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.05);color:inherit;cursor:pointer;">
            <option value="infinite" selected>‚àû Infinite</option>
            <option value="1">1 time</option>
            <option value="2">2 times</option>
            <option value="3">3 times</option>
            <option value="0">No loop</option>
          </select>
        </div>
      </div>
      
      <div id="sprite-animation-preview-container" style="display:none;">
        <div style="height:120px;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.3);border-radius:8px;margin-top:12px;">
          <div id="sprite-animation-preview" style="width:64px;height:64px;"></div>
        </div>
      </div>
    </div>
    
    <div style="background:rgba(0,0,0,0.2);border-radius:8px;padding:16px;border:1px solid rgba(255,255,255,0.08);">
      <div style="font-weight:600;color:var(--accent);margin-bottom:12px;">üé® Advanced Options</div>
      
      <div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px;">
        <label style="display:flex;align-items:center;gap:6px;color:var(--muted);cursor:pointer;">
          <input id="sprite-trim" type="checkbox" style="width:18px;height:18px;" />
          Trim transparent edges
        </label>
        <label style="display:flex;align-items:center;gap:6px;color:var(--muted);cursor:pointer;">
          <input id="sprite-add-padding" type="checkbox" checked style="width:18px;height:18px;" />
          Add padding to frames
        </label>
        <label style="display:flex;align-items:center;gap:6px;color:var(--muted);cursor:pointer;">
          <input id="sprite-save-settings" type="checkbox" checked style="width:18px;height:18px;" />
          Save settings
        </label>
      </div>
      
      <div style="margin-top:12px;">
        <div style="color:var(--accent);margin-bottom:6px;font-weight:500;">Quick Actions</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button type="button" onclick="spriteReverseFrames()" style="padding:6px 10px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;">
            üîÑ Reverse
          </button>
          <button type="button" onclick="spriteDuplicateFrames()" style="padding:6px 10px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;">
            üìã Duplicate
          </button>
          <button type="button" onclick="spriteExportJSON()" style="padding:6px 10px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;">
            üìÑ Export JSON
          </button>
          <button type="button" onclick="spriteExportCSS()" style="padding:6px 10px;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:6px;color:var(--muted);cursor:pointer;font-size:12px;">
            üé® Export CSS
          </button>
        </div>
      </div>
    </div>
  </div>

  <h3 class="small" style="color:var(--accent);margin-bottom:8px;">‚úÇÔ∏è Cut Frames Preview</h3>
  <div id="sprite-output-container" style="max-height:400px;overflow-y:auto;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.02);padding:16px;">
    <div id="sprite-output" style="display:grid;grid-template-columns:repeat(auto-fill, minmax(80px, 1fr));gap:12px;"></div>
  </div>

  <div id="sprite-hint" class="small" style="color:var(--accent);margin-top:12px;text-align:center;min-height:20px;padding:8px;background:rgba(45,212,255,0.05);border-radius:8px;"></div>
</div>

<script>
/* sprite-cutter.html
   - Professional sprite sheet cutter for game development
   - Scoped with sprite- prefix
   - Advanced cutting modes and animation preview
   - Export options for multiple formats
*/

(function() {
  'use strict';
  
  const card = document.currentScript?.closest('.card') || document;
  
  // State management
  let spriteCurrentSheet = null;
  let spriteFrames = [];
  let spriteAnimationInterval = null;
  let spriteCurrentAnimationFrame = 0;
  let spriteIsAnimating = false;
  let spriteSheetCanvas = null;
  let spriteSheetContext = null;
  
  // Initialize function
  function spriteInit() {
    console.log('Sprite Sheet Cutter initializing...');
    
    // Load saved preferences
    const savedPrefs = localStorage.getItem('sprite-preferences');
    if (savedPrefs) {
      try {
        const prefs = JSON.parse(savedPrefs);
        if (prefs.width) card.querySelector('#sprite-width').value = prefs.width;
        if (prefs.height) card.querySelector('#sprite-height').value = prefs.height;
        if (prefs.padding) {
          card.querySelector('#sprite-padding').value = prefs.padding;
          card.querySelector('#sprite-padding-value').textContent = prefs.padding;
        }
        if (prefs.mode) card.querySelector('#sprite-mode').value = prefs.mode;
        if (prefs.format) card.querySelector('#sprite-output-format').value = prefs.format;
        if (prefs.fps) card.querySelector('#sprite-fps').value = prefs.fps;
        if (prefs.loop) card.querySelector('#sprite-loop').value = prefs.loop;
        if (prefs.trim !== undefined) card.querySelector('#sprite-trim').checked = prefs.trim;
        if (prefs.addPadding !== undefined) card.querySelector('#sprite-add-padding').checked = prefs.addPadding;
      } catch (e) {
        console.log('Could not load saved preferences:', e);
      }
    }
    
    // Setup event listeners
    spriteSetupEventListeners();
    
    // Setup drag and drop
    spriteSetupDragAndDrop();
    
    // Create canvas for cutting
    spriteSheetCanvas = document.createElement('canvas');
    spriteSheetContext = spriteSheetCanvas.getContext('2d');
  }
  
  // Setup event listeners
  function spriteSetupEventListeners() {
    // File input change
    card.querySelector('#sprite-file').addEventListener('change', function(e) {
      if (this.files && this.files[0]) {
        spriteLoadImage(this.files[0]);
      }
    });
    
    // Padding slider
    const paddingSlider = card.querySelector('#sprite-padding');
    const paddingValue = card.querySelector('#sprite-padding-value');
    
    paddingSlider.addEventListener('input', function() {
      paddingValue.textContent = this.value;
      spriteSavePreferences();
      if (spriteCurrentSheet) {
        spritePreviewSheet();
      }
    });
    
    // Auto-calculate on frame size changes
    card.querySelector('#sprite-width').addEventListener('input', function() {
      spriteSavePreferences();
      if (spriteCurrentSheet) {
        spritePreviewSheet();
      }
    });
    
    card.querySelector('#sprite-height').addEventListener('input', function() {
      spriteSavePreferences();
      if (spriteCurrentSheet) {
        spritePreviewSheet();
      }
    });
    
    // Settings changes
    card.querySelectorAll('#sprite-mode, #sprite-output-format, #sprite-fps, #sprite-loop').forEach(el => {
      el.addEventListener('change', spriteSavePreferences);
    });
    
    // Checkbox changes
    card.querySelectorAll('#sprite-trim, #sprite-add-padding, #sprite-save-settings').forEach(el => {
      el.addEventListener('change', spriteSavePreferences);
    });
  }
  
  // Setup drag and drop
  function spriteSetupDragAndDrop() {
    const dropZone = card.querySelector('#sprite-file').parentElement;
    
    dropZone.addEventListener('dragover', function(e) {
      e.preventDefault();
      this.style.background = 'rgba(45,212,255,0.1)';
      this.style.borderColor = 'rgba(45,212,255,0.6)';
    });
    
    dropZone.addEventListener('dragleave', function(e) {
      e.preventDefault();
      this.style.background = 'rgba(45,212,255,0.05)';
      this.style.borderColor = 'rgba(45,212,255,0.3)';
    });
    
    dropZone.addEventListener('drop', function(e) {
      e.preventDefault();
      this.style.background = 'rgba(45,212,255,0.05)';
      this.style.borderColor = 'rgba(45,212,255,0.3)';
      
      if (e.dataTransfer.files.length > 0) {
        const file = e.dataTransfer.files[0];
        if (file.type.startsWith('image/')) {
          card.querySelector('#sprite-file').files = e.dataTransfer.files;
          spriteLoadImage(file);
        } else {
          spriteShowHint('Please drop an image file (PNG, JPG, GIF, WebP)', 'error');
        }
      }
    });
  }
  
  // Load image from file
  function spriteLoadImage(file) {
    const reader = new FileReader();
    
    reader.onload = function(e) {
      const img = new Image();
      img.onload = function() {
        spriteCurrentSheet = img;
        spritePreviewSheet();
        spriteShowHint(`‚úÖ Loaded: ${file.name} (${img.width}√ó${img.height}px)`, 'success');
        
        // Try to auto-detect frame size
        spriteAutoDetect();
      };
      img.onerror = function() {
        spriteShowHint('‚ùå Failed to load image', 'error');
      };
      img.src = e.target.result;
    };
    
    reader.onerror = function() {
      spriteShowHint('‚ùå Failed to read file', 'error');
    };
    
    reader.readAsDataURL(file);
  }
  
  // Preview the sprite sheet with grid overlay
  function spritePreviewSheet() {
    if (!spriteCurrentSheet) return;
    
    const previewContainer = card.querySelector('#sprite-sheet-preview');
    const width = parseInt(card.querySelector('#sprite-width').value) || 64;
    const height = parseInt(card.querySelector('#sprite-height').value) || 64;
    const padding = parseInt(card.querySelector('#sprite-padding').value) || 0;
    
    // Calculate grid
    const cols = Math.floor(spriteCurrentSheet.width / (width + padding));
    const rows = Math.floor(spriteCurrentSheet.height / (height + padding));
    const totalFrames = cols * rows;
    
    // Update stats
    card.querySelector('#sprite-frames-count').textContent = totalFrames;
    card.querySelector('#sprite-grid-size').textContent = `${cols}√ó${rows}`;
    
    // Create preview with grid overlay
    const previewCanvas = document.createElement('canvas');
    const previewCtx = previewCanvas.getContext('2d');
    
    // Scale down if too large
    const scale = Math.min(1, 400 / spriteCurrentSheet.width);
    previewCanvas.width = spriteCurrentSheet.width * scale;
    previewCanvas.height = spriteCurrentSheet.height * scale;
    
    // Draw sprite sheet
    previewCtx.drawImage(spriteCurrentSheet, 0, 0, previewCanvas.width, previewCanvas.height);
    
    // Draw grid overlay
    previewCtx.strokeStyle = 'rgba(255,255,255,0.3)';
    previewCtx.lineWidth = 1;
    
    for (let y = 0; y <= rows; y++) {
      const yPos = y * (height + padding) * scale;
      previewCtx.beginPath();
      previewCtx.moveTo(0, yPos);
      previewCtx.lineTo(previewCanvas.width, yPos);
      previewCtx.stroke();
    }
    
    for (let x = 0; x <= cols; x++) {
      const xPos = x * (width + padding) * scale;
      previewCtx.beginPath();
      previewCtx.moveTo(xPos, 0);
      previewCtx.lineTo(xPos, previewCanvas.height);
      previewCtx.stroke();
    }
    
    // Draw frame numbers
    previewCtx.fillStyle = 'rgba(255,255,255,0.8)';
    previewCtx.font = '12px Arial';
    previewCtx.textAlign = 'center';
    previewCtx.textBaseline = 'middle';
    
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const x = (c * (width + padding) + width / 2) * scale;
        const y = (r * (height + padding) + height / 2) * scale;
        const frameNum = r * cols + c + 1;
        
        previewCtx.fillStyle = 'rgba(0,0,0,0.5)';
        previewCtx.fillRect(x - 15, y - 9, 30, 18);
        
        previewCtx.fillStyle = '#39ff14';
        previewCtx.fillText(frameNum.toString(), x, y);
      }
    }
    
    previewContainer.innerHTML = '';
    previewContainer.appendChild(previewCanvas);
  }
  
  // Auto-detect frame size
  function spriteAutoDetect() {
    if (!spriteCurrentSheet) return;
    
    const img = spriteCurrentSheet;
    let detectedWidth = 0;
    let detectedHeight = 0;
    
    // Try to detect by looking for repeating patterns
    // This is a simple detection - in a real tool you'd use more advanced algorithms
    
    // Check common sizes first
    const commonSizes = [8, 16, 32, 64, 96, 128, 256];
    
    for (const size of commonSizes) {
      if (img.width % size === 0 && img.height % size === 0) {
        // Check if this size makes sense (at least 2 frames in each direction)
        if (img.width / size >= 2 || img.height / size >= 2) {
          detectedWidth = size;
          detectedHeight = size;
          break;
        }
      }
    }
    
    // If no common size found, try to find the smallest divisor
    if (detectedWidth === 0) {
      for (let w = 8; w <= 256; w *= 2) {
        if (img.width % w === 0) {
          for (let h = 8; h <= 256; h *= 2) {
            if (img.height % h === 0) {
              detectedWidth = w;
              detectedHeight = h;
              break;
            }
          }
          if (detectedWidth > 0) break;
        }
      }
    }
    
    if (detectedWidth > 0 && detectedHeight > 0) {
      card.querySelector('#sprite-width').value = detectedWidth;
      card.querySelector('#sprite-height').value = detectedHeight;
      spritePreviewSheet();
      spriteShowHint(`üîç Detected: ${detectedWidth}√ó${detectedHeight}px frames`, 'success');
    } else {
      spriteShowHint('‚ö†Ô∏è Could not auto-detect frame size', 'warning');
    }
  }
  
  // Set common preset
  function spriteCommonPreset(size) {
    card.querySelector('#sprite-width').value = size;
    card.querySelector('#sprite-height').value = size;
    spriteSavePreferences();
    spritePreviewSheet();
  }
  
  // Main cutting function
  function spriteCut(btn) {
    if (!spriteCurrentSheet) {
      spriteShowHint('Please upload a sprite sheet first', 'warning');
      return;
    }
    
    const width = parseInt(card.querySelector('#sprite-width').value) || 64;
    const height = parseInt(card.querySelector('#sprite-height').value) || 64;
    const padding = parseInt(card.querySelector('#sprite-padding').value) || 0;
    const mode = card.querySelector('#sprite-mode').value;
    const trim = card.querySelector('#sprite-trim').checked;
    const addPadding = card.querySelector('#sprite-add-padding').checked;
    
    if (width <= 0 || height <= 0) {
      spriteShowHint('Please enter valid frame dimensions', 'error');
      return;
    }
    
    const cutBtn = card.querySelector('#sprite-cut-btn');
    const originalText = cutBtn.textContent;
    cutBtn.textContent = '‚úÇÔ∏è Cutting...';
    cutBtn.disabled = true;
    
    // Process in background to prevent UI freeze
    setTimeout(() => {
      try {
        spriteFrames = [];
        const output = card.querySelector('#sprite-output');
        output.innerHTML = '';
        
        const img = spriteCurrentSheet;
        const cols = Math.floor(img.width / (width + padding));
        const rows = Math.floor(img.height / (height + padding));
        const totalFrames = cols * rows;
        
        // Update stats
        card.querySelector('#sprite-frames-count').textContent = totalFrames;
        card.querySelector('#sprite-grid-size').textContent = `${cols}√ó${rows}`;
        
        // Setup canvas for frame extraction
        spriteSheetCanvas.width = width;
        spriteSheetCanvas.height = height;
        
        // Extract each frame
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x = c * (width + padding);
            const y = r * (height + padding);
            const frameNum = r * cols + c;
            
            // Clear canvas and draw frame
            spriteSheetContext.clearRect(0, 0, width, height);
            spriteSheetContext.drawImage(img, x, y, width, height, 0, 0, width, height);
            
            // Create frame object
            const frameData = {
              id: frameNum,
              x: x,
              y: y,
              width: width,
              height: height,
              dataURL: spriteSheetCanvas.toDataURL('image/png')
            };
            
            spriteFrames.push(frameData);
            
            // Create preview element
            const frameElement = document.createElement('div');
            frameElement.className = 'sprite-frame';
            frameElement.style.position = 'relative';
            frameElement.style.width = '80px';
            frameElement.style.height = '80px';
            frameElement.style.display = 'flex';
            frameElement.style.alignItems = 'center';
            frameElement.style.justifyContent = 'center';
            frameElement.style.background = 'rgba(0,0,0,0.3)';
            frameElement.style.border = '1px solid rgba(255,255,255,0.1)';
            frameElement.style.borderRadius = '6px';
            frameElement.style.overflow = 'hidden';
            frameElement.style.cursor = 'pointer';
            
            const imgElement = document.createElement('img');
            imgElement.src = frameData.dataURL;
            imgElement.style.maxWidth = '100%';
            imgElement.style.maxHeight = '100%';
            imgElement.style.objectFit = 'contain';
            
            const label = document.createElement('div');
            label.className = 'sprite-frame-label';
            label.textContent = `#${frameNum + 1}`;
            label.style.position = 'absolute';
            label.style.bottom = '0';
            label.style.left = '0';
            label.style.right = '0';
            label.style.background = 'rgba(0,0,0,0.7)';
            label.style.color = '#39ff14';
            label.style.fontSize = '10px';
            label.style.padding = '2px 4px';
            label.style.textAlign = 'center';
            
            frameElement.appendChild(imgElement);
            frameElement.appendChild(label);
            
            // Add click to enlarge
            frameElement.addEventListener('click', function() {
              spriteShowFramePreview(frameNum);
            });
            
            output.appendChild(frameElement);
          }
        }
        
        // Enable animation and export buttons
        card.querySelector('#sprite-animate-btn').disabled = false;
        card.querySelector('#sprite-export-btn').disabled = false;
        
        // Show animation preview container
        card.querySelector('#sprite-animation-preview-container').style.display = 'block';
        
        spriteShowHint(`‚úÖ Successfully cut ${totalFrames} frames`, 'success');
        
      } catch (error) {
        console.error('Sprite cutting error:', error);
        spriteShowHint('‚ùå Failed to cut sprite sheet', 'error');
      } finally {
        cutBtn.textContent = originalText;
        cutBtn.disabled = false;
      }
    }, 50);
  }
  
  // Show frame preview
  function spriteShowFramePreview(frameIndex) {
    if (!spriteFrames[frameIndex]) return;
    
    const frame = spriteFrames[frameIndex];
    
    // Create modal preview
    const preview = document.createElement('div');
    preview.style.position = 'fixed';
    preview.style.top = '0';
    preview.style.left = '0';
    preview.style.right = '0';
    preview.style.bottom = '0';
    preview.style.background = 'rgba(0,0,0,0.8)';
    preview.style.display = 'flex';
    preview.style.alignItems = 'center';
    preview.style.justifyContent = 'center';
    preview.style.zIndex = '10000';
    preview.style.backdropFilter = 'blur(5px)';
    
    const content = document.createElement('div');
    content.style.background = 'rgba(20,20,30,0.95)';
    content.style.borderRadius = '12px';
    content.style.padding = '20px';
    content.style.maxWidth = '90%';
    content.style.maxHeight = '90%';
    content.style.overflow = 'auto';
    content.style.border = '2px solid var(--accent)';
    
    const img = document.createElement('img');
    img.src = frame.dataURL;
    img.style.maxWidth = '400px';
    img.style.maxHeight = '400px';
    img.style.display = 'block';
    img.style.margin = '0 auto';
    
    const info = document.createElement('div');
    info.className = 'small';
    info.style.color = 'var(--muted)';
    info.style.marginTop = '12px';
    info.style.textAlign = 'center';
    info.textContent = `Frame #${frameIndex + 1} ‚Ä¢ ${frame.width}√ó${frame.height}px ‚Ä¢ Position: ${frame.x},${frame.y}`;
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.marginTop = '16px';
    closeBtn.style.padding = '8px 16px';
    closeBtn.style.background = 'rgba(255,77,77,0.1)';
    closeBtn.style.border = '1px solid rgba(255,77,77,0.3)';
    closeBtn.style.borderRadius = '6px';
    closeBtn.style.color = '#ff4d4d';
    closeBtn.style.cursor = 'pointer';
    closeBtn.addEventListener('click', () => preview.remove());
    
    content.appendChild(img);
    content.appendChild(info);
    content.appendChild(closeBtn);
    preview.appendChild(content);
    
    // Close on background click
    preview.addEventListener('click', (e) => {
      if (e.target === preview) preview.remove();
    });
    
    document.body.appendChild(preview);
  }
  
  // Preview animation
  function spritePreviewAnimation(btn) {
    if (spriteFrames.length === 0) return;
    
    if (spriteIsAnimating) {
      // Stop animation
      clearInterval(spriteAnimationInterval);
      spriteIsAnimating = false;
      btn.textContent = 'üé¨ Preview Animation';
      btn.style.background = 'rgba(255,105,180,0.1)';
      btn.style.borderColor = 'rgba(255,105,180,0.3)';
      return;
    }
    
    // Start animation
    spriteIsAnimating = true;
    btn.textContent = '‚èπÔ∏è Stop Animation';
    btn.style.background = 'rgba(255,77,77,0.1)';
    btn.style.borderColor = 'rgba(255,77,77,0.3)';
    
    const fps = parseInt(card.querySelector('#sprite-fps').value) || 12;
    const previewContainer = card.querySelector('#sprite-animation-preview');
    spriteCurrentAnimationFrame = 0;
    
    previewContainer.innerHTML = '';
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 64;
    previewContainer.appendChild(canvas);
    
    spriteAnimationInterval = setInterval(() => {
      const frame = spriteFrames[spriteCurrentAnimationFrame];
      if (frame) {
        const img = new Image();
        img.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Calculate scaling to fit
          const scale = Math.min(canvas.width / frame.width, canvas.height / frame.height);
          const scaledWidth = frame.width * scale;
          const scaledHeight = frame.height * scale;
          const x = (canvas.width - scaledWidth) / 2;
          const y = (canvas.height - scaledHeight) / 2;
          
          ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
        };
        img.src = frame.dataURL;
      }
      
      spriteCurrentAnimationFrame = (spriteCurrentAnimationFrame + 1) % spriteFrames.length;
    }, 1000 / fps);
  }
  
  // Export all frames
  function spriteExportAll(btn) {
    if (spriteFrames.length === 0) {
      spriteShowHint('No frames to export', 'warning');
      return;
    }
    
    const format = card.querySelector('#sprite-output-format').value;
    const exportBtn = card.querySelector('#sprite-export-btn');
    const originalText = exportBtn.textContent;
    exportBtn.textContent = 'üì§ Exporting...';
    exportBtn.disabled = true;
    
    setTimeout(() => {
      try {
        if (format === 'zip' && typeof JSZip !== 'undefined') {
          // Create ZIP file
          const zip = new JSZip();
          
          spriteFrames.forEach((frame, index) => {
            const data = frame.dataURL.split(',')[1];
            zip.file(`frame_${index + 1}.png`, data, {base64: true});
          });
          
          // Add metadata
          const metadata = {
            frames: spriteFrames.length,
            frameWidth: spriteFrames[0].width,
            frameHeight: spriteFrames[0].height,
            exportedAt: new Date().toISOString()
          };
          
          zip.file('metadata.json', JSON.stringify(metadata, null, 2));
          
          zip.generateAsync({type: 'blob'}).then(function(content) {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(content);
            link.download = 'sprites.zip';
            link.click();
            spriteShowHint('‚úÖ Exported as ZIP file', 'success');
          });
          
        } else if (format === 'gif') {
          // For GIF export, we'd use a library like gif.js
          spriteShowHint('GIF export requires additional library (coming soon)', 'info');
          
        } else if (format === 'spritesheet') {
          // Reassemble into single spritesheet
          spriteExportAsSpritesheet();
          
        } else {
          // Export individual images
          spriteExportIndividualFrames(format);
        }
        
      } catch (error) {
        console.error('Export error:', error);
        spriteShowHint('‚ùå Export failed', 'error');
      } finally {
        exportBtn.textContent = originalText;
        exportBtn.disabled = false;
      }
    }, 100);
  }
  
  // Export individual frames
  function spriteExportIndividualFrames(format) {
    spriteFrames.forEach((frame, index) => {
      const link = document.createElement('a');
      link.href = frame.dataURL;
      link.download = `sprite_frame_${index + 1}.${format}`;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
    
    spriteShowHint(`‚úÖ Exported ${spriteFrames.length} frames as ${format.toUpperCase()}`, 'success');
  }
  
  // Export as single spritesheet
  function spriteExportAsSpritesheet() {
    if (spriteFrames.length === 0) return;
    
    const framesPerRow = Math.ceil(Math.sqrt(spriteFrames.length));
    const frameWidth = spriteFrames[0].width;
    const frameHeight = spriteFrames[0].height;
    const padding = 2;
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = framesPerRow * (frameWidth + padding);
    canvas.height = Math.ceil(spriteFrames.length / framesPerRow) * (frameHeight + padding);
    
    // Fill background
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw frames
    spriteFrames.forEach((frame, index) => {
      const row = Math.floor(index / framesPerRow);
      const col = index % framesPerRow;
      const x = col * (frameWidth + padding);
      const y = row * (frameHeight + padding);
      
      const img = new Image();
      img.onload = function() {
        ctx.drawImage(img, x, y);
        
        // If this is the last frame, trigger download
        if (index === spriteFrames.length - 1) {
          const link = document.createElement('a');
          link.href = canvas.toDataURL('image/png');
          link.download = 'spritesheet.png';
          link.click();
          spriteShowHint('‚úÖ Exported as single spritesheet', 'success');
        }
      };
      img.src = frame.dataURL;
    });
  }
  
  // Export JSON metadata
  function spriteExportJSON() {
    if (spriteFrames.length === 0) {
      spriteShowHint('No frames to export', 'warning');
      return;
    }
    
    const metadata = {
      frames: spriteFrames.map((frame, index) => ({
        id: index,
        filename: `frame_${index + 1}.png`,
        x: frame.x,
        y: frame.y,
        width: frame.width,
        height: frame.height
      })),
      meta: {
        app: "Sprite Sheet Studio",
        version: "1.0",
        format: "JSON",
        size: `${spriteCurrentSheet.width}x${spriteCurrentSheet.height}`,
        frameCount: spriteFrames.length,
        frameWidth: spriteFrames[0].width,
        frameHeight: spriteFrames[0].height,
        exportedAt: new Date().toISOString()
      }
    };
    
    const dataStr = JSON.stringify(metadata, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = 'sprites_metadata.json';
    link.click();
    
    spriteShowHint('‚úÖ Exported JSON metadata', 'success');
  }
  
  // Export CSS sprites
  function spriteExportCSS() {
    if (spriteFrames.length === 0) {
      spriteShowHint('No frames to export', 'warning');
      return;
    }
    
    const frameWidth = spriteFrames[0].width;
    const frameHeight = spriteFrames[0].height;
    
    let css = `/* Sprite Sheet CSS - Generated by Sprite Sheet Studio */
.sprite {
  background-image: url('spritesheet.png');
  background-repeat: no-repeat;
  display: inline-block;
}

`;
    
    spriteFrames.forEach((frame, index) => {
      const x = -frame.x;
      const y = -frame.y;
      
      css += `.sprite-${index + 1} {
  width: ${frameWidth}px;
  height: ${frameHeight}px;
  background-position: ${x}px ${y}px;
}

`;
    });
    
    const dataBlob = new Blob([css], {type: 'text/css'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = 'sprites.css';
    link.click();
    
    spriteShowHint('‚úÖ Exported CSS styles', 'success');
  }
  
  // Reverse frames
  function spriteReverseFrames() {
    if (spriteFrames.length === 0) return;
    
    spriteFrames.reverse();
    spriteUpdateOutputDisplay();
    spriteShowHint('‚úÖ Frames reversed', 'success');
  }
  
  // Duplicate frames
  function spriteDuplicateFrames() {
    if (spriteFrames.length === 0) return;
    
    const originalLength = spriteFrames.length;
    const duplicated = [...spriteFrames, ...spriteFrames];
    spriteFrames = duplicated;
    spriteUpdateOutputDisplay();
    spriteShowHint(`‚úÖ Duplicated frames (now ${spriteFrames.length} total)`, 'success');
  }
  
  // Update output display
  function spriteUpdateOutputDisplay() {
    const output = card.querySelector('#sprite-output');
    output.innerHTML = '';
    
    spriteFrames.forEach((frame, index) => {
      const frameElement = document.createElement('div');
      frameElement.className = 'sprite-frame';
      frameElement.style.position = 'relative';
      frameElement.style.width = '80px';
      frameElement.style.height = '80px';
      frameElement.style.display = 'flex';
      frameElement.style.alignItems = 'center';
      frameElement.style.justifyContent = 'center';
      frameElement.style.background = 'rgba(0,0,0,0.3)';
      frameElement.style.border = '1px solid rgba(255,255,255,0.1)';
      frameElement.style.borderRadius = '6px';
      frameElement.style.overflow = 'hidden';
      frameElement.style.cursor = 'pointer';
      
      const imgElement = document.createElement('img');
      imgElement.src = frame.dataURL;
      imgElement.style.maxWidth = '100%';
      imgElement.style.maxHeight = '100%';
      imgElement.style.objectFit = 'contain';
      
      const label = document.createElement('div');
      label.className = 'sprite-frame-label';
      label.textContent = `#${index + 1}`;
      label.style.position = 'absolute';
      label.style.bottom = '0';
      label.style.left = '0';
      label.style.right = '0';
      label.style.background = 'rgba(0,0,0,0.7)';
      label.style.color = '#39ff14';
      label.style.fontSize = '10px';
      label.style.padding = '2px 4px';
      label.style.textAlign = 'center';
      
      frameElement.appendChild(imgElement);
      frameElement.appendChild(label);
      
      frameElement.addEventListener('click', function() {
        spriteShowFramePreview(index);
      });
      
      output.appendChild(frameElement);
    });
  }
  
  // Reset function
  function spriteReset(btn) {
    spriteCurrentSheet = null;
    spriteFrames = [];
    
    if (spriteIsAnimating) {
      clearInterval(spriteAnimationInterval);
      spriteIsAnimating = false;
      card.querySelector('#sprite-animate-btn').textContent = 'üé¨ Preview Animation';
      card.querySelector('#sprite-animate-btn').style.background = 'rgba(255,105,180,0.1)';
    }
    
    card.querySelector('#sprite-file').value = '';
    card.querySelector('#sprite-sheet-preview').innerHTML = '<div style="color:var(--muted);padding:40px;">Upload a sprite sheet to preview</div>';
    card.querySelector('#sprite-output').innerHTML = '';
    card.querySelector('#sprite-frames-count').textContent = '0';
    card.querySelector('#sprite-grid-size').textContent = '0√ó0';
    card.querySelector('#sprite-animation-preview-container').style.display = 'none';
    card.querySelector('#sprite-animate-btn').disabled = true;
    card.querySelector('#sprite-export-btn').disabled = true;
    
    spriteShowHint('üîÑ Reset complete', 'info');
  }
  
  // Save preferences
  function spriteSavePreferences() {
    const saveSettings = card.querySelector('#sprite-save-settings').checked;
    if (!saveSettings) return;
    
    const prefs = {
      width: card.querySelector('#sprite-width').value,
      height: card.querySelector('#sprite-height').value,
      padding: card.querySelector('#sprite-padding').value,
      mode: card.querySelector('#sprite-mode').value,
      format: card.querySelector('#sprite-output-format').value,
      fps: card.querySelector('#sprite-fps').value,
      loop: card.querySelector('#sprite-loop').value,
      trim: card.querySelector('#sprite-trim').checked,
      addPadding: card.querySelector('#sprite-add-padding').checked,
      lastUpdated: new Date().toISOString()
    };
    
    localStorage.setItem('sprite-preferences', JSON.stringify(prefs));
  }
  
  // Show hint message
  function spriteShowHint(message, type = 'info') {
    const hint = card.querySelector('#sprite-hint');
    hint.textContent = message;
    hint.style.color = type === 'error' ? '#ff4d4d' : 
                      type === 'warning' ? '#ffcc00' : 
                      type === 'success' ? '#39ff14' : 
                      '#2dd4ff';
    
    // Auto-clear after delay
    clearTimeout(hint.timeout);
    hint.timeout = setTimeout(() => {
      if (hint.textContent === message) {
        hint.textContent = '';
      }
    }, 3000);
  }
  
  // Expose functions globally (with prefix)
  window.spriteCut = spriteCut;
  window.spriteReset = spriteReset;
  window.spriteAutoDetect = spriteAutoDetect;
  window.spriteCommonPreset = spriteCommonPreset;
  window.spritePreviewAnimation = spritePreviewAnimation;
  window.spriteExportAll = spriteExportAll;
  window.spriteReverseFrames = spriteReverseFrames;
  window.spriteDuplicateFrames = spriteDuplicateFrames;
  window.spriteExportJSON = spriteExportJSON;
  window.spriteExportCSS = spriteExportCSS;
  
  // Initialize when ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', spriteInit);
  } else {
    spriteInit();
  }
  
})();
</script>

<style>
/* Sprite Sheet Studio specific styles */
#sprite-cutter-title {
  color: var(--accent);
  margin-top: 0;
}

/* Sprite frame animations */
.sprite-frame {
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.sprite-frame:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(45,212,255,0.2);
  border-color: var(--accent) !important;
}

.sprite-frame:hover .sprite-frame-label {
  background: rgba(45,212,255,0.9) !important;
  color: #000 !important;
}

/* Animation preview */
@keyframes spritePulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); }
}

#sprite-animation-preview canvas {
  animation: spritePulse 2s ease-in-out infinite;
}

/* Grid overlay animation */
@keyframes gridFlash {
  0% { opacity: 0.3; }
  50% { opacity: 0.7; }
  100% { opacity: 0.3; }
}

#sprite-sheet-preview canvas {
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}

/* Slider styling */
#sprite-padding::-webkit-slider-thumb {
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid rgba(255,255,255,0.8);
  box-shadow: 0 0 10px rgba(45,212,255,0.5);
}

#sprite-padding::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 2px solid rgba(255,255,255,0.8);
  box-shadow: 0 0 10px rgba(45,212,255,0.5);
}

/* Scrollbar styling */
#sprite-output-container::-webkit-scrollbar {
  width: 10px;
}

#sprite-output-container::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.05);
  border-radius: 5px;
}

#sprite-output-container::-webkit-scrollbar-thumb {
  background: var(--accent);
  border-radius: 5px;
}

#sprite-output-container::-webkit-scrollbar-thumb:hover {
  background: rgba(45,212,255,0.8);
}

/* Responsive design */
@media (max-width: 768px) {
  div[style*="grid-template-columns:1fr 1fr"] {
    grid-template-columns: 1fr !important;
    gap: 12px !important;
  }
  
  #sprite-output {
    grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)) !important;
    gap: 8px !important;
  }
  
  .sprite-frame {
    width: 60px !important;
    height: 60px !important;
  }
}

@media (max-width: 480px) {
  .actions {
    flex-direction: column !important;
  }
  
  .actions button {
    width: 100% !important;
    margin-bottom: 8px;
  }
  
  #sprite-output {
    grid-template-columns: repeat(3, 1fr) !important;
  }
  
  .sprite-frame {
    width: 50px !important;
    height: 50px !important;
  }
}

/* Drag and drop highlight */
.sprite-dragover {
  animation: dragPulse 1s ease-in-out infinite;
}

@keyframes dragPulse {
  0% { border-color: rgba(45,212,255,0.3); }
  50% { border-color: rgba(45,212,255,0.8); }
  100% { border-color: rgba(45,212,255,0.3); }
}
</style>
