<!-- 
===========================================
FILE: cards/second-life-texture-alignment.html
DESCRIPTION: Calculate texture repeats, offsets, and rotations for Second Life prims
FOLLOWS: Sacred Tool Template & Design Canon
STATUS: Perfected
===========================================
-->

<!-- ===== 1. TITLE & DESCRIPTION (Required per Sacred Template) ===== -->
<h2 id="tt-title">üñºÔ∏è Second Life Texture Alignment Tool</h2>
<p id="tt-desc" class="small">
    Calculate texture repeats, offsets, and rotations for Second Life prims. 
    Perfect alignment for builders and creators. Works with any texture and prim size.
    <em>This site is supported by 
        <a href="#contributionsPanel" onclick="showContributionsPanel()">
            user contributions
        </a>.
    </em>
</p>

<!-- ===== 2. INPUT INTERFACE (Minimal, intuitive) ===== -->
<form id="tt-form" aria-labelledby="tt-title" style="margin-bottom: var(--space-major);">

    <!-- Texture Presets -->
    <div class="button-row" style="display: flex; gap: var(--space-micro); margin-bottom: var(--space-major);">
        <button type="button" onclick="ttSetTexturePreset(256)" class="btn btn-secondary btn-sm" style="flex: 1;">
            256√ó256
        </button>
        <button type="button" onclick="ttSetTexturePreset(512)" class="btn btn-secondary btn-sm active" style="flex: 1;">
            512√ó512
        </button>
        <button type="button" onclick="ttSetTexturePreset(1024)" class="btn btn-secondary btn-sm" style="flex: 1;">
            1024√ó1024
        </button>
        <button type="button" onclick="ttSetTexturePreset(2048)" class="btn btn-secondary btn-sm" style="flex: 1;">
            2048√ó2048
        </button>
    </div>

    <!-- Texture Dimensions -->
    <div class="form-group" style="margin-bottom: var(--space-major);">
        <label for="tt-texture-width" style="display: block; margin-bottom: var(--space-micro);">
            <span style="font-size: var(--text-sm); font-weight: var(--weight-medium); color: var(--text);">
                Texture Dimensions (Pixels)
            </span>
            <span style="display: block; font-size: var(--text-xs); color: var(--text-secondary);">
                Standard sizes: 32, 64, 128, 256, 512, 1024, 2048
            </span>
        </label>
        
        <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: var(--space-minor); align-items: center;">
            <input 
                type="number" 
                id="tt-texture-width"
                class="glass glass-md"
                value="512"
                min="1"
                max="4096"
                step="1"
                style="
                    width: 100%;
                    height: 44px;
                    padding: 0 var(--space-minor);
                    border: 2px solid var(--border);
                    border-radius: var(--radius-md);
                    background: var(--bg-glass);
                    color: var(--text);
                    font-family: var(--font-primary);
                    font-size: var(--text-base);
                    font-weight: var(--weight-semibold);
                    text-align: center;
                    transition: var(--transition-base);
                "
                oninput="ttUpdate()"
                aria-label="Texture width in pixels"
            >
            
            <span style="font-size: var(--text-lg); color: var(--text-tertiary); font-weight: var(--weight-light); text-align: center;">√ó</span>
            
            <input 
                type="number" 
                id="tt-texture-height"
                class="glass glass-md"
                value="512"
                min="1"
                max="4096"
                step="1"
                style="
                    width: 100%;
                    height: 44px;
                    padding: 0 var(--space-minor);
                    border: 2px solid var(--border);
                    border-radius: var(--radius-md);
                    background: var(--bg-glass);
                    color: var(--text);
                    font-family: var(--font-primary);
                    font-size: var(--text-base);
                    font-weight: var(--weight-semibold);
                    text-align: center;
                    transition: var(--transition-base);
                "
                oninput="ttUpdate()"
                aria-label="Texture height in pixels"
            >
        </div>
    </div>

    <!-- Prim Dimensions -->
    <div class="form-group" style="margin-bottom: var(--space-major);">
        <label for="tt-prim-width" style="display: block; margin-bottom: var(--space-micro);">
            <span style="font-size: var(--text-sm); font-weight: var(--weight-medium); color: var(--text);">
                Prim Face Dimensions (Meters)
            </span>
            <span style="display: block; font-size: var(--text-xs); color: var(--text-secondary);">
                Common sizes: 0.5, 1.0, 2.0, 4.0, 10.0
            </span>
        </label>
        
        <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: var(--space-minor); align-items: center;">
            <input 
                type="number" 
                id="tt-prim-width"
                class="glass glass-md"
                value="1.0"
                min="0.01"
                max="100"
                step="0.01"
                style="
                    width: 100%;
                    height: 44px;
                    padding: 0 var(--space-minor);
                    border: 2px solid var(--border);
                    border-radius: var(--radius-md);
                    background: var(--bg-glass);
                    color: var(--text);
                    font-family: var(--font-primary);
                    font-size: var(--text-base);
                    font-weight: var(--weight-semibold);
                    text-align: center;
                    transition: var(--transition-base);
                "
                oninput="ttUpdate()"
                aria-label="Prim width in meters"
            >
            
            <span style="font-size: var(--text-lg); color: var(--text-tertiary); font-weight: var(--weight-light); text-align: center;">√ó</span>
            
            <input 
                type="number" 
                id="tt-prim-height"
                class="glass glass-md"
                value="1.0"
                min="0.01"
                max="100"
                step="0.01"
                style="
                    width: 100%;
                    height: 44px;
                    padding: 0 var(--space-minor);
                    border: 2px solid var(--border);
                    border-radius: var(--radius-md);
                    background: var(--bg-glass);
                    color: var(--text);
                    font-family: var(--font-primary);
                    font-size: var(--text-base);
                    font-weight: var(--weight-semibold);
                    text-align: center;
                    transition: var(--transition-base);
                "
                oninput="ttUpdate()"
                aria-label="Prim height in meters"
            >
        </div>
    </div>

    <!-- Rotation Control -->
    <div class="form-group" style="margin-bottom: var(--space-major);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-minor);">
            <label for="tt-rotation" style="font-size: var(--text-sm); font-weight: var(--weight-medium); color: var(--text);">
                Texture Rotation
            </label>
            <span id="tt-rotation-value" style="font-size: var(--text-base); font-weight: var(--weight-bold); color: var(--accent); min-width: 60px; text-align: right;">
                0¬∞
            </span>
        </div>
        
        <!-- Rotation Slider -->
        <input 
            type="range" 
            id="tt-rotation"
            min="-180"
            max="180"
            value="0"
            step="0.1"
            style="
                width: 100%;
                height: 8px;
                margin: 0 0 var(--space-micro);
                -webkit-appearance: none;
                background: linear-gradient(to right, var(--border-light), var(--accent) 50%, var(--border-light));
                border-radius: 4px;
                outline: none;
            "
            oninput="ttUpdateRotation(this.value)"
            aria-label="Texture rotation in degrees"
        >
        
        <div style="display: flex; justify-content: space-between; font-size: var(--text-xs); color: var(--text-tertiary);">
            <span>-180¬∞</span>
            <span>0¬∞</span>
            <span>180¬∞</span>
        </div>
        
        <!-- Rotation Presets -->
        <div style="display: flex; gap: var(--space-micro); margin-top: var(--space-minor);">
            <button type="button" onclick="ttSetRotation(0)" class="btn btn-ghost btn-sm active" style="flex: 1;">
                0¬∞
            </button>
            <button type="button" onclick="ttSetRotation(90)" class="btn btn-ghost btn-sm" style="flex: 1;">
                90¬∞
            </button>
            <button type="button" onclick="ttSetRotation(180)" class="btn btn-ghost btn-sm" style="flex: 1;">
                180¬∞
            </button>
            <button type="button" onclick="ttSetRotation(270)" class="btn btn-ghost btn-sm" style="flex: 1;">
                270¬∞
            </button>
            <button type="button" onclick="ttSetRotation(45)" class="btn btn-ghost btn-sm" style="flex: 1;">
                45¬∞
            </button>
        </div>
    </div>

    <!-- Action Buttons -->
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: var(--space-minor); margin-bottom: var(--space-major);">
        <button type="button" onclick="ttCalculate()" class="btn btn-secondary btn-sm" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
            <span>üî¢</span>
            <span>Calculate</span>
        </button>
        <button type="button" onclick="ttReset()" class="btn btn-secondary btn-sm" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
            <span>üîÑ</span>
            <span>Reset</span>
        </button>
        <button type="button" onclick="ttCopyResults()" class="btn btn-secondary btn-sm" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
            <span>üìã</span>
            <span>Copy</span>
        </button>
    </div>
</form>

<!-- ===== 3. RESULTS (Clear, copyable, beautiful) ===== -->
<div class="results" id="tt-results" style="margin-top: var(--space-lg);">
    
    <!-- Main Results Grid -->
    <div class="result-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: var(--space-minor); margin-bottom: var(--space-major);">
        
        <!-- Repeat Values -->
        <div class="result-item" style="background: linear-gradient(145deg, rgba(45, 212, 255, 0.1), rgba(45, 212, 255, 0.05)); border: 1px solid var(--accent);">
            <div class="result-label" style="font-size: var(--text-xs); color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Repeat Values</div>
            <div class="result-value" id="tt-repeat-x" style="font-family: var(--font-mono); font-size: var(--text-xl); font-weight: var(--weight-bold); color: var(--accent); margin-bottom: var(--space-micro);">
                1.000
            </div>
            <div class="result-value" id="tt-repeat-y" style="font-family: var(--font-mono); font-size: var(--text-xl); font-weight: var(--weight-bold); color: var(--accent);">
                1.000
            </div>
            <div class="result-unit" style="font-size: var(--text-xs); color: var(--text-secondary);">
                Scale factor
            </div>
        </div>
        
        <!-- Offset Values -->
        <div class="result-item" style="background: var(--bg-card); border: 1px solid var(--border);">
            <div class="result-label" style="font-size: var(--text-xs); color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Offset Values</div>
            <div class="result-value" id="tt-offset-x" style="font-family: var(--font-mono); font-size: var(--text-xl); font-weight: var(--weight-bold); color: var(--accent); margin-bottom: var(--space-micro);">
                0.000
            </div>
            <div class="result-value" id="tt-offset-y" style="font-family: var(--font-mono); font-size: var(--text-xl); font-weight: var(--weight-bold); color: var(--accent);">
                0.000
            </div>
            <div class="result-unit" style="font-size: var(--text-xs); color: var(--text-secondary);">
                Position (0-1)
            </div>
        </div>
        
        <!-- Rotation Result -->
        <div class="result-item" style="background: var(--bg-card); border: 1px solid var(--border);">
            <div class="result-label" style="font-size: var(--text-xs); color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px;">Rotation</div>
            <div class="result-value" id="tt-result-rotation" style="font-family: var(--font-mono); font-size: var(--text-xl); font-weight: var(--weight-bold); color: var(--accent); margin-bottom: var(--space-micro);">
                0.0¬∞
            </div>
            <div class="result-value" style="font-family: var(--font-mono); font-size: var(--text-sm); font-weight: var(--weight-medium); color: var(--text-secondary);">
                Normalized: <span id="tt-rotation-norm">0.0¬∞</span>
            </div>
            <div class="result-unit" style="font-size: var(--text-xs); color: var(--text-secondary);">
                Degrees
            </div>
        </div>
    </div>
    
    <!-- Additional Metrics -->
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--space-minor); margin-bottom: var(--space-major);">
        <div class="info-card" style="background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--space-minor);">
            <div style="font-size: var(--text-xs); color: var(--text-tertiary); margin-bottom: var(--space-micro);">Texture Scale</div>
            <div style="font-family: var(--font-mono); font-size: var(--text-sm); color: var(--text);" id="tt-pixels-per-meter">
                512 px/m
            </div>
            <div style="font-size: var(--text-xs); color: var(--text-secondary); margin-top: 2px;">
                Pixels per meter
            </div>
        </div>
        
        <div class="info-card" style="background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--space-minor);">
            <div style="font-size: var(--text-xs); color: var(--text-tertiary); margin-bottom: var(--space-micro);">Coverage</div>
            <div style="font-family: var(--font-mono); font-size: var(--text-sm); color: var(--text);" id="tt-coverage">
                1.00√ó
            </div>
            <div style="font-size: var(--text-xs); color: var(--text-secondary); margin-top: 2px;">
                Texture coverage
            </div>
        </div>
    </div>
    
    <!-- Quick Copy Formats -->
    <div style="background: rgba(255, 255, 255, 0.02); border: 1px solid var(--border); border-radius: var(--radius-md); padding: var(--space-minor); margin-bottom: var(--space-major);">
        <div style="font-size: var(--text-xs); color: var(--text-secondary); margin-bottom: var(--space-micro);">
            Copy as:
        </div>
        <div style="display: flex; gap: var(--space-micro);">
            <button type="button" onclick="ttCopySLFormat()" class="btn btn-ghost btn-sm" style="flex: 1;">
                SL Format
            </button>
            <button type="button" onclick="ttCopyJSON()" class="btn btn-ghost btn-sm" style="flex: 1;">
                JSON
            </button>
            <button type="button" onclick="ttCopyCSV()" class="btn btn-ghost btn-sm" style="flex: 1;">
                CSV
            </button>
        </div>
    </div>
</div>

<!-- ===== 4. SHARING & EMBED (Always included) ===== -->
<div class="share-temple" style="margin-top: var(--space-lg); padding-top: var(--space-md); border-top: 1px solid var(--border-light);">
    <div style="display: flex; gap: var(--space-minor);">
        <button onclick="ttShare()" class="btn btn-secondary" style="flex: 1;">
            üì§ Share Tool
        </button>
        <button onclick="ttEmbed()" class="btn btn-secondary" style="flex: 1;">
            üîó Embed Tool
        </button>
    </div>
</div>

<!-- ===== 5. JAVASCRIPT (Self-contained, prefixed, robust) ===== -->
<script>
// TOOL-SPECIFIC FUNCTIONS (prefix with tt-)
const ttState = {
    textureWidth: 512,
    textureHeight: 512,
    primWidth: 1.0,
    primHeight: 1.0,
    rotation: 0,
    
    // Constants
    SL_SCALE: 256, // 256 pixels = 1 meter in Second Life
    RESULTS: null
};

// Load saved settings from localStorage
function ttLoadSettings() {
    try {
        const saved = localStorage.getItem('ttTextureAlignmentSettings');
        if (saved) {
            const settings = JSON.parse(saved);
            Object.assign(ttState, settings);
            
            // Update UI
            document.getElementById('tt-texture-width').value = ttState.textureWidth;
            document.getElementById('tt-texture-height').value = ttState.textureHeight;
            document.getElementById('tt-prim-width').value = ttState.primWidth;
            document.getElementById('tt-prim-height').value = ttState.primHeight;
            document.getElementById('tt-rotation').value = ttState.rotation;
            document.getElementById('tt-rotation-value').textContent = ttState.rotation + '¬∞';
            
            // Update preset buttons
            ttUpdatePresetButtons();
        }
    } catch (e) {
        console.log('Using default texture alignment settings');
    }
}

// Save settings to localStorage
function ttSaveSettings() {
    try {
        localStorage.setItem('ttTextureAlignmentSettings', JSON.stringify({
            textureWidth: ttState.textureWidth,
            textureHeight: ttState.textureHeight,
            primWidth: ttState.primWidth,
            primHeight: ttState.primHeight,
            rotation: ttState.rotation
        }));
    } catch (e) {
        console.log('Failed to save settings');
    }
}

// Update preset buttons
function ttUpdatePresetButtons() {
    const presetButtons = document.querySelectorAll('.button-row .btn');
    presetButtons.forEach(btn => {
        btn.classList.remove('active');
        const size = parseInt(btn.textContent.split('√ó')[0]);
        if (size === ttState.textureWidth && size === ttState.textureHeight) {
            btn.classList.add('active');
        }
    });
}

// Update rotation from slider
function ttUpdateRotation(value) {
    ttState.rotation = parseFloat(value);
    document.getElementById('tt-rotation-value').textContent = value + '¬∞';
    
    // Update rotation preset buttons
    const rotationButtons = document.querySelectorAll('.form-group .btn-ghost');
    rotationButtons.forEach(btn => {
        btn.classList.remove('active');
        const rotation = parseInt(btn.textContent.replace('¬∞', ''));
        if (rotation === ttState.rotation) {
            btn.classList.add('active');
        }
    });
    
    ttSaveSettings();
    ttCalculate();
}

// Set specific rotation
function ttSetRotation(degrees) {
    document.getElementById('tt-rotation').value = degrees;
    ttUpdateRotation(degrees);
}

// Set texture preset
function ttSetTexturePreset(size) {
    ttState.textureWidth = size;
    ttState.textureHeight = size;
    document.getElementById('tt-texture-width').value = size;
    document.getElementById('tt-texture-height').value = size;
    
    ttUpdatePresetButtons();
    ttCalculate();
}

// Calculate alignment
function ttCalculate() {
    // Get current values
    ttState.textureWidth = parseFloat(document.getElementById('tt-texture-width').value) || 512;
    ttState.textureHeight = parseFloat(document.getElementById('tt-texture-height').value) || 512;
    ttState.primWidth = parseFloat(document.getElementById('tt-prim-width').value) || 1.0;
    ttState.primHeight = parseFloat(document.getElementById('tt-prim-height').value) || 1.0;
    ttState.rotation = parseFloat(document.getElementById('tt-rotation').value) || 0;
    
    // Validate inputs
    if (!ttValidateInputs()) {
        return;
    }
    
    // Calculate repeats (SL uses repeats = primSize / (textureSize / 256))
    const repeatX = (ttState.primWidth / (ttState.textureWidth / ttState.SL_SCALE)).toFixed(3);
    const repeatY = (ttState.primHeight / (ttState.textureHeight / ttState.SL_SCALE)).toFixed(3);
    
    // Calculate offsets (centered by default)
    const offsetX = '0.000';
    const offsetY = '0.000';
    
    // Calculate normalized rotation (0-360)
    let normalizedRotation = ttState.rotation;
    while (normalizedRotation < 0) normalizedRotation += 360;
    while (normalizedRotation >= 360) normalizedRotation -= 360;
    
    // Calculate texture scale (pixels per meter)
    const pixelsPerMeter = (ttState.textureWidth / ttState.SL_SCALE).toFixed(1);
    
    // Calculate coverage
    const coverageX = parseFloat(repeatX).toFixed(2);
    const coverageY = parseFloat(repeatY).toFixed(2);
    
    // Store results
    ttState.RESULTS = {
        repeatX,
        repeatY,
        offsetX,
        offsetY,
        rotation: ttState.rotation,
        normalizedRotation: normalizedRotation.toFixed(1),
        pixelsPerMeter,
        coverageX,
        coverageY,
        textureWidth: ttState.textureWidth,
        textureHeight: ttState.textureHeight,
        primWidth: ttState.primWidth,
        primHeight: ttState.primHeight
    };
    
    // Display results
    ttDisplayResults();
    
    // Save settings
    ttSaveSettings();
}

// Validate inputs
function ttValidateInputs() {
    const errors = [];
    
    if (ttState.textureWidth < 1 || ttState.textureWidth > 4096 || isNaN(ttState.textureWidth)) {
        errors.push('Texture width must be between 1 and 4096 pixels');
    }
    
    if (ttState.textureHeight < 1 || ttState.textureHeight > 4096 || isNaN(ttState.textureHeight)) {
        errors.push('Texture height must be between 1 and 4096 pixels');
    }
    
    if (ttState.primWidth < 0.01 || ttState.primWidth > 100 || isNaN(ttState.primWidth)) {
        errors.push('Prim width must be between 0.01 and 100 meters');
    }
    
    if (ttState.primHeight < 0.01 || ttState.primHeight > 100 || isNaN(ttState.primHeight)) {
        errors.push('Prim height must be between 0.01 and 100 meters');
    }
    
    if (errors.length > 0) {
        showNotification(errors.join('. '), 'error');
        return false;
    }
    
    return true;
}

// Display results
function ttDisplayResults() {
    if (!ttState.RESULTS) return;
    
    // Update main results
    document.getElementById('tt-repeat-x').textContent = ttState.RESULTS.repeatX;
    document.getElementById('tt-repeat-y').textContent = ttState.RESULTS.repeatY;
    document.getElementById('tt-offset-x').textContent = ttState.RESULTS.offsetX;
    document.getElementById('tt-offset-y').textContent = ttState.RESULTS.offsetY;
    document.getElementById('tt-result-rotation').textContent = ttState.RESULTS.rotation + '¬∞';
    document.getElementById('tt-rotation-norm').textContent = ttState.RESULTS.normalizedRotation + '¬∞';
    
    // Update metrics
    document.getElementById('tt-pixels-per-meter').textContent = 
        ttState.RESULTS.pixelsPerMeter + ' px/m';
    document.getElementById('tt-coverage').textContent = 
        ttState.RESULTS.coverageX + '√ó' + ttState.RESULTS.coverageY;
    
    // Visual feedback
    showNotification('Alignment calculated successfully', 'success');
}

// Copy results to clipboard
function ttCopyResults() {
    if (!ttState.RESULTS) {
        showNotification('Calculate alignment first', 'warning');
        return;
    }
    
    const text = `Texture Alignment Results:
Repeat X: ${ttState.RESULTS.repeatX}
Repeat Y: ${ttState.RESULTS.repeatY}
Offset X: ${ttState.RESULTS.offsetX}
Offset Y: ${ttState.RESULTS.offsetY}
Rotation: ${ttState.RESULTS.rotation}¬∞
Texture: ${ttState.RESULTS.textureWidth}√ó${ttState.RESULTS.textureHeight}px
Prim: ${ttState.RESULTS.primWidth}√ó${ttState.RESULTS.primHeight}m`;
    
    navigator.clipboard.writeText(text).then(() => {
        showNotification('Results copied to clipboard', 'success');
    }).catch(err => {
        showNotification('Failed to copy results', 'error');
    });
}

// Copy as SL format
function ttCopySLFormat() {
    if (!ttState.RESULTS) {
        showNotification('Calculate alignment first', 'warning');
        return;
    }
    
    const text = `<0.000, 0.000, ${ttState.RESULTS.repeatX}, ${ttState.RESULTS.repeatY}, ${ttState.RESULTS.rotation}>`;
    
    navigator.clipboard.writeText(text).then(() => {
        showNotification('SL format copied to clipboard', 'success');
    }).catch(err => {
        showNotification('Failed to copy SL format', 'error');
    });
}

// Copy as JSON
function ttCopyJSON() {
    if (!ttState.RESULTS) {
        showNotification('Calculate alignment first', 'warning');
        return;
    }
    
    const data = {
        texture: {
            width: ttState.RESULTS.textureWidth,
            height: ttState.RESULTS.textureHeight
        },
        prim: {
            width: ttState.RESULTS.primWidth,
            height: ttState.RESULTS.primHeight
        },
        alignment: {
            repeatX: parseFloat(ttState.RESULTS.repeatX),
            repeatY: parseFloat(ttState.RESULTS.repeatY),
            offsetX: parseFloat(ttState.RESULTS.offsetX),
            offsetY: parseFloat(ttState.RESULTS.offsetY),
            rotation: ttState.RESULTS.rotation,
            rotationNormalized: parseFloat(ttState.RESULTS.normalizedRotation)
        },
        scale: {
            pixelsPerMeter: parseFloat(ttState.RESULTS.pixelsPerMeter)
        }
    };
    
    navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(() => {
        showNotification('JSON copied to clipboard', 'success');
    }).catch(err => {
        showNotification('Failed to copy JSON', 'error');
    });
}

// Copy as CSV
function ttCopyCSV() {
    if (!ttState.RESULTS) {
        showNotification('Calculate alignment first', 'warning');
        return;
    }
    
    const csv = `Parameter,Value
Texture Width,${ttState.RESULTS.textureWidth}
Texture Height,${ttState.RESULTS.textureHeight}
Prim Width,${ttState.RESULTS.primWidth}
Prim Height,${ttState.RESULTS.primHeight}
Repeat X,${ttState.RESULTS.repeatX}
Repeat Y,${ttState.RESULTS.repeatY}
Offset X,${ttState.RESULTS.offsetX}
Offset Y,${ttState.RESULTS.offsetY}
Rotation,${ttState.RESULTS.rotation}`;
    
    navigator.clipboard.writeText(csv).then(() => {
        showNotification('CSV copied to clipboard', 'success');
    }).catch(err => {
        showNotification('Failed to copy CSV', 'error');
    });
}

// Reset to defaults
function ttReset() {
    ttState.textureWidth = 512;
    ttState.textureHeight = 512;
    ttState.primWidth = 1.0;
    ttState.primHeight = 1.0;
    ttState.rotation = 0;
    ttState.RESULTS = null;
    
    // Update UI
    document.getElementById('tt-texture-width').value = 512;
    document.getElementById('tt-texture-height').value = 512;
    document.getElementById('tt-prim-width').value = 1.0;
    document.getElementById('tt-prim-height').value = 1.0;
    document.getElementById('tt-rotation').value = 0;
    document.getElementById('tt-rotation-value').textContent = '0¬∞';
    
    // Update preset buttons
    ttUpdatePresetButtons();
    ttSetRotation(0);
    
    // Clear results display
    document.getElementById('tt-repeat-x').textContent = '1.000';
    document.getElementById('tt-repeat-y').textContent = '1.000';
    document.getElementById('tt-offset-x').textContent = '0.000';
    document.getElementById('tt-offset-y').textContent = '0.000';
    document.getElementById('tt-result-rotation').textContent = '0.0¬∞';
    document.getElementById('tt-rotation-norm').textContent = '0.0¬∞';
    document.getElementById('tt-pixels-per-meter').textContent = '512 px/m';
    document.getElementById('tt-coverage').textContent = '1.00√ó';
    
    ttSaveSettings();
    showNotification('Reset to defaults', 'success');
}

// Update calculation (auto-calc)
function ttUpdate() {
    clearTimeout(ttState.updateTimer);
    ttState.updateTimer = setTimeout(() => {
        ttCalculate();
    }, 300);
}

// Share tool
function ttShare() {
    const shareText = `üñºÔ∏è Second Life Texture Alignment Tool\n` +
                     `Calculate perfect texture alignment for SL builds\n\n` +
                     `From The Most Useful Site`;
    
    if (navigator.share) {
        navigator.share({
            title: 'SL Texture Alignment Tool',
            text: shareText,
            url: window.location.href
        });
    } else {
        navigator.clipboard.writeText(shareText);
        showNotification('Share text copied to clipboard!', 'success');
    }
}

// Embed tool
function ttEmbed() {
    const embedCode = `<iframe src="${window.location.origin}/cards/second-life-texture-alignment.html" width="100%" height="600" style="border:none;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);" title="SL Texture Alignment Tool - The Most Useful Site"></iframe>`;
    
    navigator.clipboard.writeText(embedCode);
    showNotification('Embed code copied to clipboard!', 'success');
    
    // Track in analytics
    if (window.plausible) {
        window.plausible('Embed Generated', { props: { tool: 'second-life-texture-alignment' } });
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    console.log('üñºÔ∏è SL Texture Alignment Tool loaded');
    
    // Load saved settings
    ttLoadSettings();
    
    // Initial calculation
    ttCalculate();
    
    // Auto-update on input with debounce
    ['tt-texture-width', 'tt-texture-height', 'tt-prim-width', 'tt-prim-height'].forEach(id => {
        document.getElementById(id).addEventListener('input', ttUpdate);
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            ttReset();
        }
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            ttCalculate();
        }
        if (e.key === 'r' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            ttReset();
        }
    });
});
</script>

<!-- ===== 6. CARD-SCOPED STYLES (Only if absolutely necessary) ===== -->
<style>
/* Only add styles that MUST override global styles */
#tt-title { 
    color: var(--accent); 
    margin-bottom: var(--space-sm);
    font-size: var(--text-xl);
    font-weight: var(--weight-bold);
}

/* Enhanced result item styling */
.result-item {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    padding: var(--space-minor);
    text-align: center;
    transition: var(--transition-base);
}

.result-item:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-sm);
}

/* Custom slider styling */
#tt-rotation {
    -webkit-appearance: none;
    background: linear-gradient(to right, 
        var(--border-light) 0%, 
        var(--border-light) 50%, 
        var(--accent) 50%, 
        var(--accent) 100%);
    background-size: 200% 100%;
    background-position: 100% 0;
    transition: background-position 0.3s ease;
}

#tt-rotation::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--accent);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid var(--bg-card);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    transition: var(--transition-base);
}

#tt-rotation::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    background: var(--accent-dark);
}

/* Info card styling */
.info-card:hover {
    border-color: var(--accent);
    transform: translateY(-1px);
}

/* Responsive adjustments */
@media (max-width: 480px) {
    .result-grid {
        grid-template-columns: 1fr !important;
        gap: var(--space-minor) !important;
    }
    
    .button-row {
        flex-wrap: wrap;
    }
    
    .button-row button {
        flex: 1 0 calc(50% - var(--space-micro));
    }
}

@media (max-width: 360px) {
    .result-grid {
        grid-template-columns: 1fr !important;
    }
    
    .button-row button {
        flex: 1 0 100%;
    }
}

/* Print styles */
@media print {
    button, .share-temple {
        display: none !important;
    }
    
    .result-item {
        break-inside: avoid;
        border: 1px solid #ccc !important;
        background: white !important;
    }
    
    .result-value {
        color: #000 !important;
    }
}

/* Focus states for accessibility */
input:focus, select:focus, button:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
}

/* Loading state for calculations */
.calculating {
    position: relative;
    opacity: 0.7;
    pointer-events: none;
}

.calculating::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid var(--accent);
    border-radius: 50%;
    border-top-color: transparent;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Notification styling for this card */
#tt-results {
    position: relative;
}

#tt-results::before {
    content: '';
    position: absolute;
    top: -2px;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, 
        transparent, 
        var(--accent), 
        transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
}

#tt-results.updated::before {
    opacity: 1;
    animation: pulse-glow 2s ease-in-out;
}

@keyframes pulse-glow {
    0%, 100% { opacity: 0; }
    50% { opacity: 1; }
}
</style>

<!-- ===== 7. METADATA FOR CARD LOADER (Hidden) ===== -->
<div style="display: none;" data-card-metadata>
    <div data-title="Second Life Texture Alignment Tool"></div>
    <div data-description="Calculate texture repeats, offsets, and rotations for Second Life prims. Perfect alignment for builders and creators. Works with any texture and prim size."></div>
    <div data-tags="second-life, sl, linden-lab, texture, alignment, repeat, offset, rotation, prim, building, 3d, virtual-world"></div>
    <div data-category="3D & Virtual Worlds"></div>
    <div data-icon="üñºÔ∏è"></div>
    <div data-version="2.0.0"></div>
    <div data-author="The Most Useful Site"></div>
    <div data-load-time="150ms"></div>
    <div data-second-life-compatible="true"></div>
</div>
