<h2>Evolution AI Walker</h2>
<p class="description">Watch AI creatures evolve to walk better over time! Creatures improve through natural selection.</p>

<form class="tool-form">
  <!-- Control Panel -->
  <div class="control-panel">
    <div class="row">
      <div class="field">
        <label for="evo-population">Population Size</label>
        <select id="evo-population" class="input">
          <option value="8">8 Creatures (Fast)</option>
          <option value="12" selected>12 Creatures (Balanced)</option>
          <option value="16">16 Creatures (Detailed)</option>
          <option value="20">20 Creatures (Advanced)</option>
        </select>
      </div>
      
      <div class="field">
        <label for="evo-terrain">Terrain Type</label>
        <select id="evo-terrain" class="input">
          <option value="flat" selected>Flat Ground</option>
          <option value="hills">Gentle Hills</option>
          <option value="mountains">Steep Mountains</option>
          <option value="obstacles">With Obstacles</option>
        </select>
      </div>
    </div>

    <div class="field">
      <label for="evo-mutation-slider">Mutation Rate</label>
      <div class="slider-group">
        <input type="range" id="evo-mutation-slider" min="1" max="30" value="15" class="slider" />
        <div class="slider-info">
          <span id="evo-mutation-value">15%</span>
          <span class="helper">Higher = more diversity</span>
        </div>
      </div>
    </div>
  </div>

  <div class="actions">
    <button type="button" class="start-btn" onclick="startEvolution()">Start Evolution</button>
    <button type="button" class="pause-btn" onclick="pauseEvolution()" disabled>Pause</button>
    <button type="button" class="reset-btn" onclick="resetEvolution()">Reset</button>
  </div>
</form>

<!-- Simulation Container -->
<div class="simulation-container">
  <div id="evo-canvas-container">
    <!-- Loading State -->
    <div class="loading-state" id="evo-loading-state">
      <div class="loading-icon">üß¨</div>
      <h3>Evolution AI Walker</h3>
      <p>Click "Start Evolution" to begin!</p>
      <div class="loading-progress">
        <div class="progress-bar" id="evo-progress-bar"></div>
      </div>
    </div>
    
    <!-- Canvas will be inserted here -->
  </div>
  
  <!-- Overlay Stats -->
  <div class="stats-overlay" id="evo-overlay-stats">
    <div class="stats-grid">
      <div class="stat-item">
        <span class="stat-label">Best:</span>
        <span class="stat-value" id="evo-overlay-best">0 m</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Average:</span>
        <span class="stat-value" id="evo-overlay-avg">0 m</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Generation:</span>
        <span class="stat-value" id="evo-overlay-gen">1</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">Alive:</span>
        <span class="stat-value" id="evo-overlay-alive">0</span>
      </div>
    </div>
  </div>
  
  <!-- Performance Indicator -->
  <div class="performance-indicator" id="evo-performance-indicator">
    <span class="fps-label">FPS:</span>
    <span class="fps-value" id="evo-fps-counter">0</span>
  </div>
</div>

<!-- Results & Stats -->
<div class="results">
  <!-- Key Metrics -->
  <div class="metrics-grid">
    <div class="metric-card">
      <div class="metric-icon">üèÜ</div>
      <div class="metric-content">
        <div class="metric-label">Best Distance</div>
        <div class="metric-value" id="evo-best-distance">0 m</div>
        <div class="metric-sub" id="evo-best-time">Time: 0s</div>
      </div>
    </div>
    
    <div class="metric-card">
      <div class="metric-icon">üß¨</div>
      <div class="metric-content">
        <div class="metric-label">Generation</div>
        <div class="metric-value" id="evo-generation">1</div>
        <div class="metric-sub" id="evo-mutations">Mutations: 0</div>
      </div>
    </div>
    
    <div class="metric-card">
      <div class="metric-icon">üë•</div>
      <div class="metric-content">
        <div class="metric-label">Population</div>
        <div class="metric-value" id="evo-population-count">0</div>
        <div class="metric-sub" id="evo-alive-count">Alive: 0</div>
      </div>
    </div>
    
    <div class="metric-card">
      <div class="metric-icon">‚è±Ô∏è</div>
      <div class="metric-content">
        <div class="metric-label">Time</div>
        <div class="metric-value" id="evo-time">0s</div>
        <div class="metric-sub" id="evo-bonus-display">Bonus: 0%</div>
      </div>
    </div>
  </div>

  <!-- Performance Chart -->
  <div class="chart-section">
    <div class="section-header">
      <h3 class="section-title">Performance Evolution</h3>
      <span class="chart-scale" id="evo-chart-scale">Max: 0m</span>
    </div>
    <canvas id="evo-performance-chart"></canvas>
  </div>

  <!-- Leaderboard -->
  <div class="leaderboard-section" id="evo-leaderboard">
    <h3 class="section-title">Current Leaders</h3>
    <div class="leaderboard-list" id="evo-leaderboard-list">
      <!-- Will be populated by JavaScript -->
    </div>
  </div>

  <!-- Advanced Controls -->
  <div class="advanced-controls">
    <button class="control-btn" onclick="speedUp()" id="evo-speed-up">
      <span class="control-icon">‚ö°</span>
      <span class="control-text">Speed (1x)</span>
    </button>
    
    <button class="control-btn" onclick="toggleAutoBreed()" id="evo-auto-breed">
      <span class="control-icon">üîÑ</span>
      <span class="control-text">Auto-Breed: ON</span>
    </button>
    
    <button class="control-btn" onclick="saveEvolution()" id="evo-save-btn">
      <span class="control-icon">üíæ</span>
      <span class="control-text">Save State</span>
    </button>
  </div>
</div>

<!-- Information Panel -->
<details class="info-panel">
  <summary>How Evolution Works</summary>
  <div class="info-content">
    <div class="info-grid">
      <div class="info-card">
        <h4>Natural Selection</h4>
        <p>Creatures with better walking ability survive and reproduce.</p>
      </div>
      
      <div class="info-card">
        <h4>Neural Networks</h4>
        <p>Each creature has a brain that controls its movements.</p>
      </div>
      
      <div class="info-card">
        <h4>Genetic Mutation</h4>
        <p>Random mutations introduce new traits and behaviors.</p>
      </div>
      
      <div class="info-card">
        <h4>Crossover</h4>
        <p>Successful traits are combined in offspring.</p>
      </div>
    </div>
    
    <div class="info-tips">
      <h4>Tips for Better Evolution</h4>
      <ul>
        <li>Higher mutation rates increase diversity</li>
        <li>More creatures = faster evolution</li>
        <li>Challenging terrain drives adaptation</li>
        <li>Let it run longer for better results</li>
      </ul>
    </div>
  </div>
</details>

<script>
/* Evolution AI Walker - Enhanced Version */
class EvolutionWalker {
  constructor() {
    // Core Three.js objects
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    
    // Game state
    this.creatures = [];
    this.isRunning = false;
    this.isInitialized = false;
    this.generation = 1;
    this.mutations = 0;
    this.startTime = 0;
    
    // Performance tracking
    this.fps = 0;
    this.frameCount = 0;
    this.lastFpsUpdate = 0;
    this.lastFrameTime = 0;
    
    // Statistics
    this.bestFitnessHistory = [];
    this.averageFitnessHistory = [];
    this.allTimeBest = 0;
    this.permanentBonus = 0;
    this.totalTimeSpent = 0;
    
    // Configuration
    this.config = {
      POPULATION_SIZE: 12,
      MUTATION_RATE: 0.15,
      SPEED_MULTIPLIER: 1.0,
      AUTO_BREED: true,
      TERRAIN_TYPE: 'flat'
    };
    
    // Three.js objects
    this.ground = null;
    this.obstacles = [];
    this.lights = [];
    
    // Bind methods
    this.start = this.start.bind(this);
    this.pause = this.pause.bind(this);
    this.reset = this.reset.bind(this);
    this.animate = this.animate.bind(this);
  }
  
  // Initialize the simulation
  async initialize() {
    try {
      // Show loading state
      this.showLoading(true);
      
      // Load Three.js if not available
      if (typeof THREE === 'undefined') {
        await this.loadThreeJS();
      }
      
      // Create scene
      this.scene = new THREE.Scene();
      this.scene.fog = new THREE.Fog(0x0b0f1a, 50, 300);
      
      // Setup camera
      this.setupCamera();
      
      // Setup renderer
      this.setupRenderer();
      
      // Setup lighting
      this.setupLighting();
      
      // Create terrain
      this.createTerrain();
      
      // Create initial population
      this.createPopulation();
      
      // Setup event listeners
      this.setupEventListeners();
      
      // Load saved data
      this.loadSavedData();
      
      // Mark as initialized
      this.isInitialized = true;
      
      // Hide loading state
      this.showLoading(false);
      
      // Start animation loop
      this.animate();
      
      console.log('Evolution Walker initialized successfully');
      return true;
      
    } catch (error) {
      console.error('Initialization failed:', error);
      this.showError('Failed to initialize 3D engine');
      return false;
    }
  }
  
  setupCamera() {
    const container = document.getElementById('evo-canvas-container');
    const aspect = container.clientWidth / container.clientHeight;
    
    this.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
    this.camera.position.set(0, 25, 40);
    this.camera.lookAt(0, 0, 0);
  }
  
  setupRenderer() {
    const container = document.getElementById('evo-canvas-container');
    
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
      powerPreference: "high-performance"
    });
    
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    this.renderer.setClearColor(0x000000, 0);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    // Add canvas to container
    container.appendChild(this.renderer.domElement);
  }
  
  setupLighting() {
    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    this.scene.add(ambientLight);
    this.lights.push(ambientLight);
    
    // Directional light (sun)
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(30, 50, 30);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.far = 200;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    this.scene.add(directionalLight);
    this.lights.push(directionalLight);
    
    // Accent light
    const accentLight = new THREE.PointLight(0x2dd4ff, 0.3, 100);
    accentLight.position.set(0, 20, 0);
    this.scene.add(accentLight);
    this.lights.push(accentLight);
  }
  
  createTerrain() {
    // Remove old terrain
    if (this.ground) {
      this.scene.remove(this.ground);
    }
    this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
    this.obstacles = [];
    
    const terrainType = this.config.TERRAIN_TYPE;
    
    // Create ground geometry
    const groundGeometry = new THREE.PlaneGeometry(1000, 200, 50, 20);
    
    // Modify geometry based on terrain type
    const vertices = groundGeometry.attributes.position.array;
    
    for (let i = 0; i < vertices.length; i += 3) {
      const x = vertices[i];
      const z = vertices[i + 2];
      
      switch(terrainType) {
        case 'hills':
          vertices[i + 1] = Math.sin(x * 0.02) * Math.cos(z * 0.02) * 5;
          break;
        case 'mountains':
          vertices[i + 1] = Math.sin(x * 0.01) * Math.cos(z * 0.01) * 10;
          vertices[i + 1] += Math.sin(x * 0.05) * 2;
          break;
        case 'obstacles':
          vertices[i + 1] = 0;
          // Add obstacles later
          break;
        default: // flat
          vertices[i + 1] = 0;
      }
    }
    
    groundGeometry.attributes.position.needsUpdate = true;
    groundGeometry.computeVertexNormals();
    
    // Create ground material
    const groundMaterial = new THREE.MeshLambertMaterial({
      color: terrainType === 'mountains' ? 0x5a5a5a : 0x2a5c2a,
      emissive: terrainType === 'mountains' ? 0x2a2a2a : 0x0a2a0a,
      emissiveIntensity: 0.1
    });
    
    // Create ground mesh
    this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
    this.ground.rotation.x = -Math.PI / 2;
    this.ground.receiveShadow = true;
    this.scene.add(this.ground);
    
    // Add obstacles if selected
    if (terrainType === 'obstacles') {
      for (let i = 0; i < 15; i++) {
        const height = Math.random() * 4 + 1;
        const geometry = new THREE.CylinderGeometry(1, 1, height, 8);
        const material = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const obstacle = new THREE.Mesh(geometry, material);
        
        obstacle.position.x = Math.random() * 200 - 100;
        obstacle.position.z = Math.random() * 100 - 50;
        obstacle.position.y = height / 2;
        obstacle.castShadow = true;
        obstacle.receiveShadow = true;
        
        this.scene.add(obstacle);
        this.obstacles.push(obstacle);
      }
    }
  }
  
  createPopulation() {
    // Clear existing creatures
    this.creatures.forEach(creature => creature.dispose());
    this.creatures = [];
    
    // Create new creatures
    for (let i = 0; i < this.config.POPULATION_SIZE; i++) {
      const z = (i - this.config.POPULATION_SIZE / 2) * 3;
      const creature = new Creature(0, z);
      this.creatures.push(creature);
      this.scene.add(creature.group);
    }
  }
  
  start() {
    if (!this.isInitialized) {
      this.initialize();
      return;
    }
    
    this.isRunning = true;
    this.startTime = Date.now();
    
    // Update UI
    document.getElementById('evo-start-btn').disabled = true;
    document.getElementById('evo-pause-btn').disabled = false;
    document.querySelector('.stats-overlay').style.display = 'block';
    document.querySelector('.performance-indicator').style.display = 'block';
    
    // Update button text
    const startBtn = document.querySelector('.start-btn');
    startBtn.innerHTML = 'Evolving...';
    startBtn.classList.add('active');
  }
  
  pause() {
    this.isRunning = false;
    
    // Update UI
    document.getElementById('evo-start-btn').disabled = false;
    document.getElementById('evo-pause-btn').disabled = true;
    
    const startBtn = document.querySelector('.start-btn');
    startBtn.innerHTML = 'Resume Evolution';
    startBtn.classList.remove('active');
  }
  
  reset() {
    if (confirm('Reset evolution? This will clear all current creatures.')) {
      this.pause();
      
      // Reset state
      this.generation = 1;
      this.mutations = 0;
      this.bestFitnessHistory = [];
      this.averageFitnessHistory = [];
      
      // Clear creatures
      this.creatures.forEach(creature => creature.dispose());
      this.creatures = [];
      
      // Create new population
      this.createPopulation();
      
      // Reset camera
      this.camera.position.set(0, 25, 40);
      this.camera.lookAt(0, 0, 0);
      
      // Update UI
      this.updateUI();
      this.updateChart();
      
      // Hide overlay
      document.querySelector('.stats-overlay').style.display = 'none';
      document.querySelector('.leaderboard-section').style.display = 'none';
    }
  }
  
  animate() {
    requestAnimationFrame(this.animate);
    
    // Calculate delta time
    const now = performance.now() / 1000;
    const dt = this.lastFrameTime ? Math.min(now - this.lastFrameTime, 0.1) : 0.016;
    this.lastFrameTime = now;
    
    // Update FPS
    this.updateFPS(now, dt);
    
    if (this.isRunning) {
      // Update creatures
      this.creatures.forEach(creature => {
        if (creature.alive) {
          creature.update(dt * this.config.SPEED_MULTIPLIER);
        }
      });
      
      // Update evolution
      this.updateEvolution(dt);
      
      // Update camera
      this.updateCamera();
      
      // Update UI periodically
      if (this.frameCount % 30 === 0) {
        this.updateUI();
      }
    }
    
    // Render scene
    if (this.renderer && this.scene && this.camera) {
      this.renderer.render(this.scene, this.camera);
    }
  }
  
  updateFPS(now, dt) {
    this.frameCount++;
    
    if (now - this.lastFpsUpdate >= 1) {
      this.fps = Math.round(this.frameCount / (now - this.lastFpsUpdate));
      this.frameCount = 0;
      this.lastFpsUpdate = now;
      
      const fpsElement = document.getElementById('evo-fps-counter');
      if (fpsElement) {
        fpsElement.textContent = this.fps;
        
        // Color code based on FPS
        if (this.fps < 30) {
          fpsElement.style.color = '#ff4444';
        } else if (this.fps < 50) {
          fpsElement.style.color = '#ffa500';
        } else {
          fpsElement.style.color = '#39ff14';
        }
      }
    }
  }
  
  updateEvolution(dt) {
    // Filter alive creatures
    const aliveCreatures = this.creatures.filter(c => c.alive);
    
    // Update permanent bonus
    this.totalTimeSpent += dt;
    this.updatePermanentBonus();
    
    // Auto-breed if enabled
    if (aliveCreatures.length >= 2 && this.config.AUTO_BREED && Math.random() < 0.03) {
      this.breedCreatures(aliveCreatures);
    }
    
    // Update all-time best
    const currentBest = Math.max(...this.creatures.map(c => c.fitness || 0));
    if (currentBest > this.allTimeBest) {
      this.allTimeBest = currentBest;
      this.saveData();
    }
  }
  
  breedCreatures(aliveCreatures) {
    // Select top performers
    const sorted = [...aliveCreatures].sort((a, b) => b.fitness - a.fitness);
    const parents = sorted.slice(0, Math.min(3, sorted.length));
    
    if (parents.length >= 2) {
      const parent1 = parents[0];
      const parent2 = parents[Math.floor(Math.random() * (parents.length - 1)) + 1];
      
      // Create child position
      const childX = (parent1.position.x + parent2.position.x) / 2;
      const childZ = (parent1.position.z + parent2.position.z) / 2 + (Math.random() - 0.5) * 5;
      
      // Create child creature
      const child = new Creature(childX, childZ, parent1, parent2);
      
      // Add to scene and population
      this.scene.add(child.group);
      this.creatures.push(child);
      
      // Update stats
      this.mutations++;
      this.generation++;
      
      // Limit population size
      const maxPopulation = this.config.POPULATION_SIZE * 1.5;
      if (this.creatures.length > maxPopulation) {
        const sortedAll = [...this.creatures].sort((a, b) => a.fitness - b.fitness);
        const weakest = sortedAll[0];
        weakest.dispose();
        this.creatures = this.creatures.filter(c => c !== weakest);
      }
    }
  }
  
  updateCamera() {
    const aliveCreatures = this.creatures.filter(c => c.alive);
    if (aliveCreatures.length === 0) return;
    
    // Find leader
    const leader = aliveCreatures.reduce((best, c) => 
      c.distance > best.distance ? c : best, aliveCreatures[0]
    );
    
    // Smooth camera follow
    const targetX = leader.position.x + 20;
    const targetY = Math.max(15, 20 + leader.position.y * 0.2);
    const targetZ = 40;
    
    this.camera.position.x += (targetX - this.camera.position.x) * 0.05;
    this.camera.position.y += (targetY - this.camera.position.y) * 0.05;
    this.camera.position.z = targetZ;
    
    this.camera.lookAt(leader.position.x, leader.position.y + 5, leader.position.z);
  }
  
  updateUI() {
    const aliveCreatures = this.creatures.filter(c => c.alive);
    const aliveCount = aliveCreatures.length;
    
    // Calculate distances
    let bestDistance = 0;
    let totalDistance = 0;
    
    aliveCreatures.forEach(creature => {
      const distance = creature.distance || 0;
      totalDistance += distance;
      if (distance > bestDistance) bestDistance = distance;
    });
    
    const avgDistance = aliveCount > 0 ? totalDistance / aliveCount : 0;
    
    // Update history
    this.bestFitnessHistory.push(bestDistance);
    this.averageFitnessHistory.push(avgDistance);
    
    // Keep history manageable
    if (this.bestFitnessHistory.length > 100) {
      this.bestFitnessHistory.shift();
      this.averageFitnessHistory.shift();
    }
    
    // Update elapsed time
    const elapsed = this.isRunning ? (Date.now() - this.startTime) / 1000 : 0;
    
    // Update DOM elements
    this.updateElement('evo-time', Math.floor(elapsed) + 's');
    this.updateElement('evo-best-time', `Time: ${Math.floor(elapsed)}s`);
    this.updateElement('evo-population-count', this.creatures.length);
    this.updateElement('evo-alive-count', `Alive: ${aliveCount}`);
    this.updateElement('evo-generation', this.generation);
    this.updateElement('evo-mutations', `Mutations: ${this.mutations}`);
    this.updateElement('evo-best-distance', Math.floor(bestDistance) + ' m');
    this.updateElement('evo-bonus-display', `Bonus: ${this.permanentBonus}%`);
    
    // Update overlay
    this.updateElement('evo-overlay-best', Math.floor(bestDistance) + ' m');
    this.updateElement('evo-overlay-avg', Math.floor(avgDistance) + ' m');
    this.updateElement('evo-overlay-gen', this.generation);
    this.updateElement('evo-overlay-alive', aliveCount);
    
    // Update leaderboard
    if (aliveCount >= 2) {
      this.updateLeaderboard(aliveCreatures);
      document.querySelector('.leaderboard-section').style.display = 'block';
    }
    
    // Update chart every 2 seconds
    if (Date.now() - (this.lastChartUpdate || 0) > 2000) {
      this.updateChart();
      this.lastChartUpdate = Date.now();
    }
  }
  
  updateElement(id, value) {
    const element = document.getElementById(id);
    if (element) element.textContent = value;
  }
  
  updateLeaderboard(creatures) {
    const sorted = [...creatures].sort((a, b) => b.fitness - a.fitness).slice(0, 5);
    const leaderboardHTML = sorted.map((creature, index) => `
      <div class="leaderboard-item ${index === 0 ? 'leader' : ''}">
        <span class="leaderboard-rank">${index + 1}</span>
        <span class="leaderboard-distance">${Math.floor(creature.distance)}m</span>
        <span class="leaderboard-legs">${creature.numLegs} legs</span>
        <span class="leaderboard-age">${Math.floor(creature.age)}s</span>
      </div>
    `).join('');
    
    document.getElementById('evo-leaderboard-list').innerHTML = leaderboardHTML;
  }
  
  updateChart() {
    const canvas = document.getElementById('evo-performance-chart');
    const ctx = canvas.getContext('2d');
    
    if (!ctx || this.bestFitnessHistory.length < 2) return;
    
    // Set canvas size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Find data ranges
    const allData = [...this.bestFitnessHistory, ...this.averageFitnessHistory];
    const maxValue = Math.max(...allData) || 1;
    
    // Update scale indicator
    this.updateElement('evo-chart-scale', `Max: ${Math.floor(maxValue)}m`);
    
    // Draw grid
    ctx.strokeStyle = 'rgba(45, 212, 255, 0.1)';
    ctx.lineWidth = 1;
    
    // Vertical grid
    for (let i = 0; i <= 10; i++) {
      const x = (i / 10) * width;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    
    // Draw best fitness line
    if (this.bestFitnessHistory.length >= 2) {
      ctx.beginPath();
      ctx.strokeStyle = '#39ff14';
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      
      this.bestFitnessHistory.forEach((value, index) => {
        const x = (index / (this.bestFitnessHistory.length - 1)) * width;
        const y = height - (value / maxValue) * height * 0.8;
        
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
    }
    
    // Draw average fitness line
    if (this.averageFitnessHistory.length >= 2) {
      ctx.beginPath();
      ctx.strokeStyle = '#2dd4ff';
      ctx.lineWidth = 1.5;
      ctx.lineJoin = 'round';
      
      this.averageFitnessHistory.forEach((value, index) => {
        const x = (index / (this.averageFitnessHistory.length - 1)) * width;
        const y = height - (value / maxValue) * height * 0.8;
        
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
    }
  }
  
  updatePermanentBonus() {
    // Gain 1% bonus every 2 minutes of total usage
    const minutes = this.totalTimeSpent / 60;
    const newBonus = Math.min(100, Math.floor(minutes / 2));
    
    if (newBonus > this.permanentBonus) {
      this.permanentBonus = newBonus;
      this.updateElement('evo-bonus-display', `Bonus: ${this.permanentBonus}%`);
      this.saveData();
      
      // Visual feedback
      const bonusElement = document.querySelector('.bonus-indicator');
      if (bonusElement) {
        bonusElement.style.animation = 'pulse 0.5s ease-in-out';
        setTimeout(() => bonusElement.style.animation = '', 500);
      }
    }
  }
  
  loadSavedData() {
    try {
      const saved = localStorage.getItem('evolutionWalkerData');
      if (saved) {
        const data = JSON.parse(saved);
        this.permanentBonus = Math.min(data.bonus || 0, 100);
        this.totalTimeSpent = data.totalTime || 0;
        this.allTimeBest = data.allTimeBest || 0;
        
        if (this.permanentBonus > 0) {
          this.updateElement('evo-bonus-display', `Bonus: ${this.permanentBonus}%`);
        }
      }
    } catch (e) {
      console.warn('Could not load saved data:', e);
    }
  }
  
  saveData() {
    try {
      const data = {
        bonus: this.permanentBonus,
        totalTime: this.totalTimeSpent,
        allTimeBest: this.allTimeBest,
        lastUpdated: Date.now()
      };
      localStorage.setItem('evolutionWalkerData', JSON.stringify(data));
    } catch (e) {
      console.warn('Could not save data:', e);
    }
  }
  
  showLoading(show) {
    const loadingState = document.getElementById('evo-loading-state');
    if (loadingState) {
      loadingState.style.display = show ? 'flex' : 'none';
    }
    
    if (show) {
      // Simulate progress
      let progress = 0;
      const interval = setInterval(() => {
        progress += 10;
        const progressBar = document.getElementById('evo-progress-bar');
        if (progressBar) {
          progressBar.style.width = progress + '%';
        }
        if (progress >= 100) clearInterval(interval);
      }, 200);
    }
  }
  
  showError(message) {
    const container = document.getElementById('evo-canvas-container');
    container.innerHTML = `
      <div class="error-state">
        <div class="error-icon">‚ùå</div>
        <h3>Initialization Error</h3>
        <p>${message}</p>
        <button onclick="location.reload()" class="retry-btn">Try Again</button>
      </div>
    `;
  }
  
  setupEventListeners() {
    // Window resize
    window.addEventListener('resize', () => this.handleResize());
    
    // Population change
    document.getElementById('evo-population').addEventListener('change', (e) => {
      this.config.POPULATION_SIZE = parseInt(e.target.value);
    });
    
    // Terrain change
    document.getElementById('evo-terrain').addEventListener('change', (e) => {
      this.config.TERRAIN_TYPE = e.target.value;
      this.createTerrain();
    });
    
    // Mutation slider
    const mutationSlider = document.getElementById('evo-mutation-slider');
    const mutationValue = document.getElementById('evo-mutation-value');
    
    mutationSlider.addEventListener('input', (e) => {
      const value = e.target.value;
      mutationValue.textContent = value + '%';
      this.config.MUTATION_RATE = value / 100;
    });
  }
  
  handleResize() {
    if (this.renderer && this.camera) {
      const container = document.getElementById('evo-canvas-container');
      const width = container.clientWidth;
      const height = container.clientHeight;
      
      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(width, height);
      
      // Update chart
      this.updateChart();
    }
  }
  
  async loadThreeJS() {
    return new Promise((resolve, reject) => {
      if (typeof THREE !== 'undefined') {
        resolve();
        return;
      }
      
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
}

// Creature Class
class Creature {
  constructor(x = 0, z = 0, parent1 = null, parent2 = null) {
    // Genetics
    if (parent1 && parent2) {
      // Inherit traits from parents
      this.bodySize = (parent1.bodySize + parent2.bodySize) / 2;
      this.legLength = (parent1.legLength + parent2.legLength) / 2;
      this.numLegs = Math.random() < 0.5 ? parent1.numLegs : parent2.numLegs;
      this.hasArms = Math.random() < 0.5 ? parent1.hasArms : parent2.hasArms;
    } else {
      // Random initial traits
      this.bodySize = 0.8 + Math.random() * 0.4;
      this.legLength = 1.2 + Math.random() * 0.6;
      this.numLegs = Math.random() < 0.7 ? 2 : 4;
      this.hasArms = Math.random() < 0.5;
    }
    
    // Color
    const hue = 0.6 + Math.random() * 0.2;
    this.color = new THREE.Color().setHSL(hue, 0.8, 0.5);
    
    // Physics
    this.position = new THREE.Vector3(x, this.legLength + 1, z);
    this.velocity = new THREE.Vector3();
    this.rotation = 0;
    this.walkCycle = Math.random() * Math.PI * 2;
    this.grounded = false;
    
    // Stats
    this.fitness = 0;
    this.distance = 0;
    this.alive = true;
    this.age = 0;
    this.energy = 100;
    
    // Create 3D model
    this.createModel();
  }
  
  createModel() {
    this.group = new THREE.Group();
    this.group.position.copy(this.position);
    
    // Body
    const bodyGeometry = new THREE.BoxGeometry(this.bodySize, this.bodySize * 1.2, this.bodySize * 0.8);
    const bodyMaterial = new THREE.MeshLambertMaterial({
      color: this.color.getHex(),
      emissive: this.color.clone().multiplyScalar(0.3).getHex(),
      emissiveIntensity: 0.2
    });
    
    this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    this.body.position.y = this.bodySize * 0.6;
    this.body.castShadow = true;
    this.group.add(this.body);
    
    // Head
    const headGeometry = new THREE.SphereGeometry(this.bodySize * 0.35, 8, 8);
    const headMaterial = new THREE.MeshLambertMaterial({
      color: this.color.clone().multiplyScalar(1.2).getHex()
    });
    
    this.head = new THREE.Mesh(headGeometry, headMaterial);
    this.head.position.y = this.bodySize * 1.3;
    this.head.castShadow = true;
    this.group.add(this.head);
    
    // Legs
    this.legs = [];
    const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, this.legLength, 6);
    const legMaterial = new THREE.MeshLambertMaterial({
      color: this.color.clone().multiplyScalar(0.8).getHex()
    });
    
    for (let i = 0; i < this.numLegs; i++) {
      const angle = (i / this.numLegs) * Math.PI * 2;
      const leg = new THREE.Mesh(legGeometry, legMaterial);
      
      leg.position.x = Math.sin(angle) * this.bodySize * 0.4;
      leg.position.z = Math.cos(angle) * this.bodySize * 0.4;
      leg.position.y = -this.legLength * 0.5;
      leg.castShadow = true;
      
      this.group.add(leg);
      this.legs.push({
        mesh: leg,
        baseAngle: angle,
        phase: (i / this.numLegs) * Math.PI * 2
      });
    }
  }
  
  update(dt) {
    if (!this.alive) return;
    
    this.age += dt;
    this.energy -= dt * 0.1;
    
    // Simple AI: walk forward with some randomness
    this.walkCycle += dt * 5;
    
    // Move forward
    const forwardForce = Math.sin(this.walkCycle) * 4;
    const turnForce = (Math.random() - 0.5) * 0.5;
    
    this.velocity.x += Math.sin(this.rotation) * forwardForce * dt;
    this.velocity.z += Math.cos(this.rotation) * forwardForce * dt;
    this.rotation += turnForce * dt;
    
    // Apply gravity
    this.velocity.y -= 9.8 * dt;
    
    // Apply damping
    this.velocity.multiplyScalar(0.95);
    
    // Update position
    this.position.add(this.velocity.clone().multiplyScalar(dt));
    
    // Ground collision
    if (this.position.y <= 0) {
      this.position.y = 0;
      this.velocity.y = 0;
      this.grounded = true;
    } else {
      this.grounded = false;
    }
    
    // Update group position
    this.group.position.copy(this.position);
    this.group.rotation.y = this.rotation;
    
    // Animate legs
    this.legs.forEach(leg => {
      const phase = this.walkCycle + leg.phase;
      leg.mesh.rotation.x = Math.sin(phase) * 0.8;
      leg.mesh.position.y = -this.legLength * 0.5 + Math.abs(Math.sin(phase)) * 0.2;
    });
    
    // Update distance
    this.distance = this.position.x;
    if (this.distance > this.fitness) {
      this.fitness = this.distance;
    }
    
    // Die if fallen off or out of energy
    if (this.position.y < -50 || this.energy <= 0) {
      this.die();
    }
  }
  
  die() {
    this.alive = false;
  }
  
  dispose() {
    if (this.group && this.group.parent) {
      this.group.parent.remove(this.group);
    }
  }
}

// Global instance
let evolutionWalker = null;

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
  evolutionWalker = new EvolutionWalker();
  
  // Setup mutation slider
  const mutationSlider = document.getElementById('evo-mutation-slider');
  const mutationValue = document.getElementById('evo-mutation-value');
  
  mutationSlider.addEventListener('input', function() {
    mutationValue.textContent = this.value + '%';
  });
});

// Global functions for button clicks
function startEvolution() {
  if (evolutionWalker) {
    evolutionWalker.start();
  }
}

function pauseEvolution() {
  if (evolutionWalker) {
    evolutionWalker.pause();
  }
}

function resetEvolution() {
  if (evolutionWalker) {
    evolutionWalker.reset();
  }
}

function speedUp() {
  if (evolutionWalker) {
    const speeds = [1.0, 2.0, 3.0, 5.0];
    const currentIndex = speeds.indexOf(evolutionWalker.config.SPEED_MULTIPLIER);
    const nextIndex = (currentIndex + 1) % speeds.length;
    
    evolutionWalker.config.SPEED_MULTIPLIER = speeds[nextIndex];
    document.getElementById('evo-speed-up').querySelector('.control-text').textContent = 
      `Speed (${evolutionWalker.config.SPEED_MULTIPLIER}x)`;
  }
}

function toggleAutoBreed() {
  if (evolutionWalker) {
    evolutionWalker.config.AUTO_BREED = !evolutionWalker.config.AUTO_BREED;
    const text = evolutionWalker.config.AUTO_BREED ? 'ON' : 'OFF';
    document.getElementById('evo-auto-breed').querySelector('.control-text').textContent = 
      `Auto-Breed: ${text}`;
  }
}

function saveEvolution() {
  if (evolutionWalker) {
    evolutionWalker.saveData();
    
    // Visual feedback
    const saveBtn = document.getElementById('evo-save-btn');
    saveBtn.classList.add('success');
    setTimeout(() => saveBtn.classList.remove('success'), 1000);
  }
}
</script>

<style>
/* Evolution Walker Specific Styles */
.control-panel {
  background: rgba(45, 212, 255, 0.05);
  border-radius: 12px;
  padding: 20px;
  border: 1px solid rgba(45, 212, 255, 0.1);
  margin-bottom: 20px;
}

.slider-group {
  margin-top: 8px;
}

.slider-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 8px;
  font-size: 0.9em;
  color: #9ccbe0;
}

#evo-mutation-value {
  color: #39ff14;
  font-weight: 600;
}

/* Simulation Container */
.simulation-container {
  position: relative;
  background: #000;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid rgba(45, 212, 255, 0.2);
  min-height: 300px;
  margin-bottom: 20px;
}

#evo-canvas-container {
  width: 100%;
  height: 300px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

#evo-canvas-container canvas {
  display: block;
  width: 100%;
  height: 100%;
  border-radius: 8px;
}

/* Loading State */
.loading-state {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(11, 15, 26, 0.9);
  backdrop-filter: blur(10px);
  z-index: 10;
}

.loading-icon {
  font-size: 48px;
  margin-bottom: 16px;
  animation: float 3s ease-in-out infinite;
}

@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.loading-state h3 {
  color: #2dd4ff;
  margin-bottom: 8px;
  font-size: 1.2em;
}

.loading-state p {
  color: #9ccbe0;
  margin-bottom: 20px;
}

.loading-progress {
  width: 200px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, #2dd4ff, #39ff14);
  border-radius: 2px;
  transition: width 0.3s ease;
}

/* Stats Overlay */
.stats-overlay {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 12px;
  border-radius: 8px;
  border: 1px solid rgba(45, 212, 255, 0.2);
  display: none;
  z-index: 5;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, auto);
  gap: 8px 16px;
}

.stat-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.85em;
}

.stat-label {
  color: #9ccbe0;
  white-space: nowrap;
}

.stat-value {
  color: #e6faff;
  font-weight: 600;
  min-width: 40px;
}

.stat-value:first-of-type {
  color: #39ff14;
}

/* Performance Indicator */
.performance-indicator {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  padding: 6px 12px;
  border-radius: 6px;
  border: 1px solid rgba(45, 212, 255, 0.2);
  display: none;
  z-index: 5;
  font-size: 0.85em;
}

.fps-label {
  color: #9ccbe0;
  margin-right: 6px;
}

.fps-value {
  color: #39ff14;
  font-weight: 600;
}

/* Metrics Grid */
.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.metric-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  padding: 20px;
  border: 1px solid rgba(45, 212, 255, 0.1);
  display: flex;
  align-items: center;
  gap: 16px;
  transition: all 0.3s ease;
}

.metric-card:hover {
  border-color: rgba(45, 212, 255, 0.3);
  transform: translateY(-2px);
}

.metric-icon {
  font-size: 2em;
}

.metric-content {
  flex: 1;
}

.metric-label {
  font-size: 0.9em;
  color: #9ccbe0;
  margin-bottom: 4px;
}

.metric-value {
  font-size: 1.8em;
  font-weight: 700;
  color: #2dd4ff;
  margin: 4px 0;
}

.metric-card:nth-child(1) .metric-value {
  color: #39ff14;
}

.metric-card:nth-child(2) .metric-value {
  color: #2dd4ff;
}

.metric-card:nth-child(3) .metric-value {
  color: #9d4edd;
}

.metric-card:nth-child(4) .metric-value {
  color: #ffa500;
}

.metric-sub {
  font-size: 0.85em;
  color: #9ccbe0;
}

/* Chart Section */
.chart-section {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 12px;
  padding: 20px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  margin-bottom: 24px;
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.chart-scale {
  font-size: 0.85em;
  color: #9ccbe0;
}

#evo-performance-chart {
  width: 100%;
  height: 120px;
  background: transparent;
  display: block;
}

/* Leaderboard */
.leaderboard-section {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 12px;
  padding: 20px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  margin-bottom: 24px;
  display: none;
}

.leaderboard-list {
  max-height: 200px;
  overflow-y: auto;
}

.leaderboard-item {
  display: grid;
  grid-template-columns: 30px 1fr 1fr 1fr;
  gap: 16px;
  padding: 12px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  align-items: center;
  font-size: 0.9em;
}

.leaderboard-item.leader {
  background: rgba(57, 255, 20, 0.1);
  border-radius: 6px;
  padding: 12px;
  margin: 0 -12px;
}

.leaderboard-rank {
  color: #2dd4ff;
  font-weight: 600;
  text-align: center;
}

.leaderboard-item.leader .leaderboard-rank {
  color: #ffcc00;
}

.leaderboard-distance {
  color: #e6faff;
  font-weight: 600;
}

.leaderboard-legs {
  color: #9ccbe0;
}

.leaderboard-age {
  color: #9ccbe0;
  text-align: right;
}

/* Advanced Controls */
.advanced-controls {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 12px;
  margin-bottom: 24px;
}

.control-btn {
  background: rgba(45, 212, 255, 0.1);
  border: 1px solid rgba(45, 212, 255, 0.2);
  border-radius: 8px;
  padding: 12px;
  color: #e6faff;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  font-size: 0.9em;
}

.control-btn:hover {
  background: rgba(45, 212, 255, 0.2);
  border-color: rgba(45, 212, 255, 0.4);
  transform: translateY(-2px);
}

.control-btn.success {
  background: rgba(57, 255, 20, 0.2);
  border-color: rgba(57, 255, 20, 0.4);
}

.control-icon {
  font-size: 1.2em;
}

.control-text {
  font-weight: 500;
}

/* Info Panel */
.info-panel {
  margin-top: 24px;
  border: 1px solid rgba(45, 212, 255, 0.2);
  border-radius: 12px;
  overflow: hidden;
}

.info-panel summary {
  padding: 16px;
  background: rgba(45, 212, 255, 0.05);
  cursor: pointer;
  font-weight: 500;
  color: #2dd4ff;
  list-style: none;
  position: relative;
}

.info-panel summary::after {
  content: '‚ñº';
  position: absolute;
  right: 16px;
  transition: transform 0.3s;
  font-size: 0.8em;
}

.info-panel[open] summary::after {
  transform: rotate(180deg);
}

.info-content {
  padding: 20px;
  background: rgba(45, 212, 255, 0.02);
}

.info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 24px;
}

.info-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  padding: 16px;
  border: 1px solid rgba(45, 212, 255, 0.1);
}

.info-card h4 {
  color: #2dd4ff;
  margin-bottom: 8px;
  font-size: 1.1em;
}

.info-card p {
  color: #9ccbe0;
  font-size: 0.9em;
  line-height: 1.5;
}

.info-tips {
  background: rgba(45, 212, 255, 0.05);
  border-radius: 8px;
  padding: 20px;
  border-left: 4px solid #2dd4ff;
}

.info-tips h4 {
  color: #2dd4ff;
  margin-bottom: 12px;
  font-size: 1.1em;
}

.info-tips ul {
  margin: 0;
  padding-left: 20px;
  color: #9ccbe0;
}

.info-tips li {
  margin-bottom: 8px;
  line-height: 1.5;
}

/* Buttons */
.start-btn {
  background: linear-gradient(135deg, #39ff14, #2dd4ff) !important;
  color: #000 !important;
  font-weight: 600 !important;
}

.start-btn.active {
  background: linear-gradient(135deg, #2dd4ff, #0077b5) !important;
}

.pause-btn {
  background: rgba(255, 165, 0, 0.1) !important;
  border-color: rgba(255, 165, 0, 0.3) !important;
  color: #ffa500 !important;
}

.reset-btn {
  background: rgba(255, 77, 77, 0.1) !important;
  border-color: rgba(255, 77, 77, 0.3) !important;
  color: #ff4d4d !important;
}

/* Error State */
.error-state {
  text-align: center;
  padding: 40px 20px;
  color: #fff;
}

.error-icon {
  font-size: 48px;
  margin-bottom: 16px;
  color: #ff4d4d;
}

.error-state h3 {
  color: #ff4d4d;
  margin-bottom: 12px;
}

.error-state p {
  color: #9ccbe0;
  margin-bottom: 24px;
}

.retry-btn {
  padding: 10px 24px;
  background: #2dd4ff;
  color: #000;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.3s ease;
}

.retry-btn:hover {
  background: #39ff14;
  transform: translateY(-2px);
}

/* Responsive */
@media (max-width: 768px) {
  .simulation-container {
    min-height: 250px;
  }
  
  #evo-canvas-container {
    height: 250px;
  }
  
  .metrics-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .advanced-controls {
    grid-template-columns: 1fr;
  }
  
  .leaderboard-item {
    grid-template-columns: 30px 1fr 1fr;
  }
  
  .leaderboard-age {
    display: none;
  }
}

@media (max-width: 480px) {
  .metrics-grid {
    grid-template-columns: 1fr;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
    gap: 6px;
  }
  
  .info-grid {
    grid-template-columns: 1fr;
  }
}
</style>
