<h2 id="evolution-walker-title">üèÉ Evolution AI Walker</h2>

<form aria-describedby="evolution-walker-desc">
  <p id="evolution-walker-desc" class="small">
    Watch AI creatures evolve to walk better over time! They improve the longer you stay on the site.
    <span id="evo-permanent-bonus" style="color:#39ff14;font-weight:600;display:none;">(+<span id="evo-bonus-value">0</span>% permanent bonus!)</span>
  </p>

  <div class="field" style="margin-bottom:16px;">
    <label for="evo-population" style="display:block;margin-bottom:6px;color:var(--accent);font-weight:500;">
      Population Size
    </label>
    <select id="evo-population" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.05);color:inherit;">
      <option value="10">10 Creatures (Fast)</option>
      <option value="15" selected>15 Creatures (Balanced)</option>
      <option value="20">20 Creatures (Detailed)</option>
    </select>
  </div>

  <div class="field" style="margin-bottom:16px;">
    <label for="evo-mutation" style="display:block;margin-bottom:6px;color:var(--accent);font-weight:500;">
      Mutation Rate
    </label>
    <div style="display:flex;align-items:center;gap:10px;">
      <input type="range" id="evo-mutation-slider" min="1" max="20" value="10" step="1"
             style="flex:1;height:6px;border-radius:3px;background:linear-gradient(to right, #ff4d4d, #ffa500, #39ff14);outline:none;">
      <input type="number" id="evo-mutation" value="10" min="1" max="20" step="1"
             style="width:70px;padding:8px;border-radius:6px;border:1px solid rgba(45,212,255,0.3);background:rgba(45,212,255,0.1);color:#e6faff;text-align:center;">
      <div style="color:rgba(45,212,255,0.8);white-space:nowrap;">%</div>
    </div>
    <div style="font-size:12px;color:rgba(230,250,255,0.6);margin-top:4px;">
      Higher = more diversity, Lower = more stability
    </div>
  </div>

  <div class="actions" style="margin-top:20px;display:flex;gap:10px;">
    <button type="button" onclick="evoStartEvolution()" id="evo-start-btn"
            style="flex:1;padding:12px;background:linear-gradient(135deg, #39ff14, #2dd4ff);color:#000;border:none;border-radius:8px;cursor:pointer;font-weight:600;">
      üöÄ Start Evolution
    </button>
    <button type="button" onclick="evoPauseEvolution()" id="evo-pause-btn" disabled
            style="padding:12px 16px;background:rgba(255,165,0,0.1);border:1px solid rgba(255,165,0,0.3);color:#ffa500;border-radius:8px;cursor:pointer;">
      ‚è∏Ô∏è Pause
    </button>
    <button type="button" onclick="evoResetEvolution()"
            style="padding:12px 16px;background:rgba(255,77,77,0.1);border:1px solid rgba(255,77,77,0.3);color:#ff4d4d;border-radius:8px;cursor:pointer;">
      üîÑ Reset
    </button>
  </div>
</form>

<!-- 3D Canvas Container -->
<div style="margin-top:16px;position:relative;background:#000;border-radius:8px;overflow:hidden;border:1px solid rgba(45,212,255,0.2);">
  <div id="evo-canvas-container" style="width:100%;height:300px;position:relative;">
    <!-- Canvas will be inserted here -->
  </div>
  
  <!-- Overlay Stats -->
  <div id="evo-overlay-stats" style="position:absolute;top:10px;left:10px;color:#fff;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:6px;font-size:12px;display:none;">
    <div>üéØ Best: <span id="evo-overlay-best">0</span>m</div>
    <div>üìä Avg: <span id="evo-overlay-avg">0</span>m</div>
    <div>üß¨ Gen: <span id="evo-overlay-gen">1</span></div>
  </div>
</div>

<!-- Results & Stats -->
<div class="results" aria-live="polite" style="margin-top:16px;">
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;margin-bottom:16px;">
    <div style="background:rgba(45,212,255,0.1);padding:12px;border-radius:8px;border:1px solid rgba(45,212,255,0.2);text-align:center;">
      <div style="color:var(--accent);font-size:12px;">Best Distance</div>
      <div style="font-size:20px;font-weight:600;color:#39ff14;" id="evo-best-distance">0 m</div>
    </div>
    <div style="background:rgba(57,255,20,0.1);padding:12px;border-radius:8px;border:1px solid rgba(57,255,20,0.2);text-align:center;">
      <div style="color:#39ff14;font-size:12px;">Generation</div>
      <div style="font-size:20px;font-weight:600;color:#2dd4ff;" id="evo-generation">1</div>
    </div>
    <div style="background:rgba(157,78,221,0.1);padding:12px;border-radius:8px;border:1px solid rgba(157,78,221,0.2);text-align:center;">
      <div style="color:#9d4edd;font-size:12px;">Population</div>
      <div style="font-size:20px;font-weight:600;color:#e6faff;" id="evo-population-count">15</div>
    </div>
    <div style="background:rgba(255,165,0,0.1);padding:12px;border-radius:8px;border:1px solid rgba(255,165,0,0.2);text-align:center;">
      <div style="color:#ffa500;font-size:12px;">Time</div>
      <div style="font-size:20px;font-weight:600;color:#e6faff;" id="evo-time">0s</div>
    </div>
  </div>

  <!-- Performance Graph -->
  <div style="margin-top:16px;background:rgba(0,0,0,0.3);border-radius:8px;padding:12px;border:1px solid rgba(255,255,255,0.1);">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px;font-size:14px;">üìà Performance Evolution</div>
    <canvas id="evo-performance-chart" style="width:100%;height:100px;background:transparent;"></canvas>
  </div>

  <!-- Leaderboard -->
  <div id="evo-leaderboard" style="display:none;margin-top:16px;">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px;font-size:14px;">üèÜ Current Leaders</div>
    <div id="evo-leaderboard-list" style="font-size:12px;color:rgba(230,250,255,0.8);">
      <!-- Leaderboard entries will appear here -->
    </div>
  </div>
</div>

<script>
/* evolution-walker.html
   - AI Evolution Walker with permanent improvement
   - Scoped with evo- prefix
*/

let evo = {
    // State
    scene: null,
    camera: null,
    renderer: null,
    creatures: [],
    isRunning: false,
    startTime: 0,
    generation: 1,
    mutations: 0,
    bestFitnessHistory: [],
    
    // Permanent improvements stored in localStorage
    permanentBonus: 0,
    totalTimeSpent: 0,
    allTimeBest: 0,
    
    // Constants (can be modified by bonus)
    POPULATION_SIZE: 15,
    ELIMINATION_DISTANCE: 150,
    MUTATION_RATE: 0.1,
    
    // Three.js objects
    ground: null,
    directionalLight: null,
    statsInterval: null
};

// Load permanent improvements from localStorage
function evoLoadPermanentBonus() {
    try {
        const saved = localStorage.getItem('evoPermanentBonus');
        if (saved) {
            const data = JSON.parse(saved);
            evo.permanentBonus = data.bonus || 0;
            evo.totalTimeSpent = data.totalTime || 0;
            evo.allTimeBest = data.allTimeBest || 0;
            
            // Show bonus if exists
            if (evo.permanentBonus > 0) {
                document.getElementById('evo-permanent-bonus').style.display = 'inline';
                document.getElementById('evo-bonus-value').textContent = evo.permanentBonus;
            }
            
            console.log('Loaded permanent bonus:', evo.permanentBonus + '%');
        }
    } catch (e) {
        console.warn('Could not load permanent bonus:', e);
    }
}

// Save permanent improvements to localStorage
function evoSavePermanentBonus() {
    try {
        const data = {
            bonus: evo.permanentBonus,
            totalTime: evo.totalTimeSpent,
            allTimeBest: evo.allTimeBest,
            lastUpdated: Date.now()
        };
        localStorage.setItem('evoPermanentBonus', JSON.stringify(data));
    } catch (e) {
        console.warn('Could not save permanent bonus:', e);
    }
}

// Update permanent bonus based on time spent
function evoUpdatePermanentBonus(dt) {
    evo.totalTimeSpent += dt;
    
    // Gain 1% bonus every 5 minutes of total site usage
    const minutes = evo.totalTimeSpent / 60;
    const newBonus = Math.floor(minutes / 5);
    
    if (newBonus > evo.permanentBonus) {
        evo.permanentBonus = newBonus;
        document.getElementById('evo-permanent-bonus').style.display = 'inline';
        document.getElementById('evo-bonus-value').textContent = evo.permanentBonus;
        evoSavePermanentBonus();
        
        // Visual feedback
        const bonusElement = document.getElementById('evo-permanent-bonus');
        bonusElement.style.animation = 'none';
        setTimeout(() => {
            bonusElement.style.animation = 'pulse 0.5s';
        }, 10);
    }
}

// Enhanced Neural Network
class evoBrain {
    constructor() {
        this.weights = [];
        const size = 20 + Math.floor(evo.permanentBonus / 2); // Bigger brain with bonus
        for (let i = 0; i < size; i++) {
            this.weights.push((Math.random() - 0.5) * 2);
        }
    }

    think(inputs) {
        let output = 0;
        const bonusMultiplier = 1 + (evo.permanentBonus * 0.01); // Better thinking with bonus
        for (let i = 0; i < Math.min(inputs.length, this.weights.length); i++) {
            output += inputs[i] * this.weights[i] * bonusMultiplier;
        }
        return Math.tanh(output);
    }

    mutate() {
        const mutationRate = document.getElementById('evo-mutation').value / 100;
        for (let i = 0; i < this.weights.length; i++) {
            if (Math.random() < mutationRate) {
                this.weights[i] += (Math.random() - 0.5) * 0.5;
                this.weights[i] = Math.max(-2, Math.min(2, this.weights[i]));
            }
        }
        evo.mutations++;
    }

    crossover(other) {
        const child = new evoBrain();
        for (let i = 0; i < this.weights.length; i++) {
            child.weights[i] = Math.random() < 0.5 ? this.weights[i] : other.weights[i];
        }
        return child;
    }
}

class evoCreature {
    constructor(x = 0, z = 0) {
        // Genetics with permanent bonus influence
        const bonusMultiplier = 1 + (evo.permanentBonus * 0.02);
        this.bodySize = (0.8 + Math.random() * 1.2) * bonusMultiplier;
        this.legLength = (1 + Math.random() * 2) * bonusMultiplier;
        this.numLegs = Math.random() < (0.7 + evo.permanentBonus * 0.01) ? 2 : 4;
        this.hasArms = Math.random() < (0.6 + evo.permanentBonus * 0.01);
        this.armLength = this.hasArms ? (0.8 + Math.random() * 1.5) * bonusMultiplier : 0;
        
        // Color based on performance
        const hue = Math.random() * 0.3 + 0.6; // Blue-green range
        this.color = new THREE.Color().setHSL(hue, 0.8, 0.5);
        
        // Physics with bonus
        this.position = new THREE.Vector3(x, 0, z);
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.rotation = 0;
        this.walkCycle = Math.random() * Math.PI * 2;
        
        this.brain = new evoBrain();
        this.fitness = 0;
        this.alive = true;
        this.age = 0;
        this.id = Date.now() + Math.random();
        
        this.createModel();
    }

    createModel() {
        try {
            this.group = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(this.bodySize, this.bodySize * 1.2, this.bodySize * 0.8);
            const bodyMat = new THREE.MeshLambertMaterial({ 
                color: this.color.getHex(),
                transparent: true,
                opacity: 0.9
            });
            this.bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
            this.bodyMesh.position.y = this.bodySize * 0.6;
            this.bodyMesh.castShadow = true;
            this.group.add(this.bodyMesh);
            
            // Head
            const headGeo = new THREE.SphereGeometry(this.bodySize * 0.4);
            const headMat = new THREE.MeshLambertMaterial({ 
                color: this.color.clone().multiplyScalar(1.2).getHex() 
            });
            this.headMesh = new THREE.Mesh(headGeo, headMat);
            this.headMesh.position.y = this.bodySize * 1.4;
            this.headMesh.castShadow = true;
            this.group.add(this.headMesh);
            
            // Legs
            this.legMeshes = [];
            const legGeo = new THREE.CylinderGeometry(0.1, 0.1, this.legLength);
            const legMat = new THREE.MeshLambertMaterial({ 
                color: this.color.clone().multiplyScalar(0.8).getHex() 
            });
            
            for (let i = 0; i < this.numLegs; i++) {
                const legMesh = new THREE.Mesh(legGeo, legMat);
                const angle = (i / this.numLegs) * Math.PI * 2;
                legMesh.position.x = Math.sin(angle) * this.bodySize * 0.4;
                legMesh.position.z = Math.cos(angle) * this.bodySize * 0.4;
                legMesh.position.y = -this.legLength * 0.5;
                legMesh.castShadow = true;
                this.group.add(legMesh);
                this.legMeshes.push(legMesh);
            }
            
            // Arms
            this.armMeshes = [];
            if (this.hasArms) {
                const armGeo = new THREE.CylinderGeometry(0.08, 0.08, this.armLength);
                const armMat = new THREE.MeshLambertMaterial({ 
                    color: this.color.clone().multiplyScalar(0.9).getHex() 
                });
                
                for (let i = 0; i < 2; i++) {
                    const armMesh = new THREE.Mesh(armGeo, armMat);
                    armMesh.position.x = (i === 0 ? -1 : 1) * this.bodySize * 0.6;
                    armMesh.position.y = this.bodySize * 0.8;
                    armMesh.position.z = 0;
                    armMesh.castShadow = true;
                    this.group.add(armMesh);
                    this.armMeshes.push(armMesh);
                }
            }
            
            evo.scene.add(this.group);
        } catch (e) {
            console.error('Error creating creature:', e);
            this.alive = false;
        }
    }

    update(dt) {
        if (!this.alive) return;
        
        try {
            this.age += dt;
            
            // Enhanced inputs with more sensory data
            const inputs = [
                this.velocity.x,
                this.velocity.z,
                this.velocity.y,
                this.position.y,
                Math.sin(this.walkCycle),
                Math.cos(this.walkCycle),
                Math.sin(this.rotation),
                Math.cos(this.rotation),
                this.age / 100
            ];
            
            // Get brain output with bonus
            const output = this.brain.think(inputs);
            const bonusMultiplier = 1 + (evo.permanentBonus * 0.01);
            
            // Enhanced movement
            const forwardForce = output * 3 * bonusMultiplier;
            const turnForce = this.brain.think([...inputs, output]) * 0.03;
            
            // Update walk cycle
            this.walkCycle += dt * (3 + evo.permanentBonus * 0.05);
            
            // Apply forces
            const forward = new THREE.Vector3(Math.sin(this.rotation), 0, Math.cos(this.rotation));
            this.velocity.add(forward.multiplyScalar(forwardForce * dt));
            this.rotation += turnForce;
            
            // Improved physics
            this.velocity.y -= 12 * dt;
            this.position.add(this.velocity.clone().multiplyScalar(dt));
            
            // Ground collision
            if (this.position.y <= 0) {
                this.position.y = 0;
                this.velocity.y = 0;
                this.velocity.multiplyScalar(0.92); // Better friction with bonus
            }
            
            // Air resistance
            this.velocity.multiplyScalar(0.985);
            
            // Update model
            this.group.position.copy(this.position);
            this.group.rotation.y = this.rotation;
            
            // Enhanced animation
            for (let i = 0; i < this.legMeshes.length; i++) {
                const phase = this.walkCycle + (i / this.numLegs) * Math.PI;
                this.legMeshes[i].rotation.x = Math.sin(phase) * 0.7;
            }
            
            for (let i = 0; i < this.armMeshes.length; i++) {
                this.armMeshes[i].rotation.x = Math.sin(this.walkCycle * 0.7 + i * Math.PI) * 0.9;
            }
            
            // Update fitness
            this.fitness = Math.max(this.fitness, this.position.x);
            
            // Check death conditions
            if (this.position.y < -50 || this.age > 300) {
                this.die();
            }
        } catch (e) {
            console.error('Error updating creature:', e);
            this.die();
        }
    }

    die() {
        this.alive = false;
        if (this.group) {
            evo.scene.remove(this.group);
        }
    }

    breed(partner) {
        try {
            const childX = (this.position.x + partner.position.x) / 2;
            const childZ = (this.position.z + partner.position.z) / 2 + (Math.random() - 0.5) * 8;
            
            const child = new evoCreature(childX, childZ);
            
            // Enhanced inheritance with bonus
            const inheritanceBonus = 1 + (evo.permanentBonus * 0.005);
            child.bodySize = ((this.bodySize + partner.bodySize) / 2) * inheritanceBonus + (Math.random() - 0.5) * 0.2;
            child.legLength = ((this.legLength + partner.legLength) / 2) * inheritanceBonus + (Math.random() - 0.5) * 0.3;
            
            // Clamp values
            child.bodySize = Math.max(0.3, Math.min(3, child.bodySize));
            child.legLength = Math.max(0.5, Math.min(4, child.legLength));
            
            // Genetic crossover with bonus
            child.brain = this.brain.crossover(partner.brain);
            child.brain.mutate();
            
            // Update model
            child.die();
            child.createModel();
            child.alive = true;
            
            return child;
        } catch (e) {
            console.error('Breeding error:', e);
            return null;
        }
    }
}

// Initialize the evolution simulation
function evoInit() {
    try {
        evoLoadPermanentBonus();
        
        // Set up Three.js scene
        evo.scene = new THREE.Scene();
        evo.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        evo.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true 
        });
        
        const container = document.getElementById('evo-canvas-container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        evo.renderer.setSize(width, height);
        evo.renderer.setClearColor(0x000000, 0);
        evo.renderer.shadowMap.enabled = true;
        evo.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        container.appendChild(evo.renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        evo.scene.add(ambientLight);
        
        evo.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        evo.directionalLight.position.set(30, 50, 30);
        evo.directionalLight.castShadow = true;
        evo.scene.add(evo.directionalLight);
        
        // Enhanced ground
        const groundGeometry = new THREE.PlaneGeometry(1000, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x2a5c2a,
            emissive: 0x0a2a0a,
            emissiveIntensity: 0.1
        });
        evo.ground = new THREE.Mesh(groundGeometry, groundMaterial);
        evo.ground.rotation.x = -Math.PI / 2;
        evo.ground.receiveShadow = true;
        evo.scene.add(evo.ground);
        
        // Camera
        evo.camera.position.set(0, 20, 30);
        evo.camera.lookAt(0, 0, 0);
        
        // Create initial population
        evoCreatePopulation();
        
        // Initialize performance chart
        evoInitPerformanceChart();
        
        // Start animation loop
        evoAnimate();
        
        // Update stats every second
        evo.statsInterval = setInterval(evoUpdateStats, 1000);
        
        console.log('Evolution Walker initialized with', evo.permanentBonus + '% bonus');
        return true;
    } catch (e) {
        console.error('Failed to initialize evolution:', e);
        document.getElementById('evo-canvas-container').innerHTML = 
            '<div style="color:#ff4d4d;padding:20px;text-align:center;">3D initialization failed</div>';
        return false;
    }
}

// Create initial population
function evoCreatePopulation() {
    try {
        evo.creatures = [];
        const population = parseInt(document.getElementById('evo-population').value);
        
        for (let i = 0; i < population; i++) {
            const z = (i - population/2) * 2.5;
            evo.creatures.push(new evoCreature(0, z));
        }
    } catch (e) {
        console.error('Error creating population:', e);
    }
}

// Update evolution logic
function evoUpdateEvolution(dt) {
    try {
        const aliveCreatures = evo.creatures.filter(c => c.alive);
        
        // Update permanent bonus
        evoUpdatePermanentBonus(dt);
        
        // Breeding with improved logic
        if (aliveCreatures.length >= 2 && Math.random() < 0.03) {
            aliveCreatures.sort((a, b) => b.fitness - a.fitness);
            const parents = aliveCreatures.slice(0, 3);
            const parent1 = parents[0];
            const parent2 = parents[Math.floor(Math.random() * 2) + 1];
            
            const child = parent1.breed(parent2);
            if (child) {
                evo.creatures.push(child);
                
                // Remove weakest if too many
                if (aliveCreatures.length > evo.POPULATION_SIZE) {
                    const weakest = aliveCreatures[aliveCreatures.length - 1];
                    weakest.die();
                    evo.creatures = evo.creatures.filter(c => c !== weakest);
                }
                
                evo.generation++;
            }
        }
        
        // Smart elimination
        if (aliveCreatures.length > 0) {
            const bestFitness = Math.max(...aliveCreatures.map(c => c.fitness));
            evo.bestFitnessHistory.push(bestFitness);
            if (evo.bestFitnessHistory.length > 100) evo.bestFitnessHistory.shift();
            
            // Eliminate creatures that fall behind
            aliveCreatures.forEach(c => {
                if (c.fitness < bestFitness - evo.ELIMINATION_DISTANCE * 0.8) {
                    c.die();
                }
            });
        }
        
        // Repopulate if needed
        if (aliveCreatures.length === 0) {
            evoCreatePopulation();
            evo.generation++;
        }
        
        // Update all-time best
        const currentBest = Math.max(...evo.creatures.map(c => c.fitness || 0));
        if (currentBest > evo.allTimeBest) {
            evo.allTimeBest = currentBest;
            evoSavePermanentBonus();
        }
    } catch (e) {
        console.error('Evolution update error:', e);
    }
}

// Update camera to follow leader
function evoUpdateCamera() {
    try {
        const aliveCreatures = evo.creatures.filter(c => c.alive);
        if (aliveCreatures.length > 0) {
            const leader = aliveCreatures.reduce((best, c) => c.fitness > best.fitness ? c : best);
            const targetX = leader.position.x + 20;
            const targetY = Math.max(15, 15 + leader.position.y * 0.3);
            
            evo.camera.position.x += (targetX - evo.camera.position.x) * 0.03;
            evo.camera.position.y += (targetY - evo.camera.position.y) * 0.03;
            evo.camera.lookAt(leader.position.x, leader.position.y * 0.5, leader.position.z);
        }
    } catch (e) {
        console.error('Camera update error:', e);
    }
}

// Update UI stats
function evoUpdateStats() {
    try {
        const aliveCreatures = evo.creatures.filter(c => c.alive);
        const elapsed = evo.isRunning ? (Date.now() - evo.startTime) / 1000 : 0;
        
        let bestDistance = 0;
        let avgDistance = 0;
        let leaderboard = [];
        
        if (aliveCreatures.length > 0) {
            bestDistance = Math.max(...aliveCreatures.map(c => c.fitness));
            avgDistance = aliveCreatures.reduce((sum, c) => sum + c.fitness, 0) / aliveCreatures.length;
            
            // Create leaderboard
            leaderboard = aliveCreatures
                .sort((a, b) => b.fitness - a.fitness)
                .slice(0, 5)
                .map((c, i) => ({
                    rank: i + 1,
                    fitness: Math.floor(c.fitness),
                    legs: c.numLegs,
                    arms: c.hasArms ? '‚úì' : '‚úó'
                }));
        }
        
        // Update main stats
        document.getElementById('evo-time').textContent = Math.floor(elapsed) + 's';
        document.getElementById('evo-population-count').textContent = aliveCreatures.length;
        document.getElementById('evo-generation').textContent = evo.generation;
        document.getElementById('evo-best-distance').textContent = Math.floor(bestDistance) + ' m';
        
        // Update overlay stats
        document.getElementById('evo-overlay-best').textContent = Math.floor(bestDistance);
        document.getElementById('evo-overlay-avg').textContent = Math.floor(avgDistance);
        document.getElementById('evo-overlay-gen').textContent = evo.generation;
        
        // Show overlay when running
        document.getElementById('evo-overlay-stats').style.display = evo.isRunning ? 'block' : 'none';
        
        // Update leaderboard if enough creatures
        if (leaderboard.length >= 2) {
            document.getElementById('evo-leaderboard').style.display = 'block';
            const leaderboardHTML = leaderboard.map(c => `
                <div style="display:grid;grid-template-columns:20px 1fr 1fr 1fr;gap:8px;padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1);">
                    <div style="color:#ffcc00;">${c.rank}.</div>
                    <div>${c.fitness}m</div>
                    <div>${c.legs} legs</div>
                    <div>Arms: ${c.arms}</div>
                </div>
            `).join('');
            document.getElementById('evo-leaderboard-list').innerHTML = leaderboardHTML;
        }
        
        // Update performance chart
        evoUpdatePerformanceChart();
    } catch (e) {
        console.error('Stats update error:', e);
    }
}

// Initialize performance chart
function evoInitPerformanceChart() {
    const canvas = document.getElementById('evo-performance-chart');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
}

// Update performance chart
function evoUpdatePerformanceChart() {
    const canvas = document.getElementById('evo-performance-chart');
    const ctx = canvas.getContext('2d');
    
    if (evo.bestFitnessHistory.length < 2) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;
    
    // Draw data
    ctx.beginPath();
    ctx.strokeStyle = '#39ff14';
    ctx.lineWidth = 2;
    
    const maxFitness = Math.max(...evo.bestFitnessHistory);
    const minFitness = Math.min(...evo.bestFitnessHistory);
    const range = maxFitness - minFitness || 1;
    
    evo.bestFitnessHistory.forEach((value, index) => {
        const x = (index / (evo.bestFitnessHistory.length - 1)) * canvas.width;
        const y = canvas.height - ((value - minFitness) / range) * canvas.height * 0.8;
        
        if (index === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    });
    
    ctx.stroke();
}

// Main animation loop
function evoAnimate() {
    try {
        if (evo.isRunning) {
            const dt = 1/60;
            
            // Update all creatures
            evo.creatures.forEach(c => c.update(dt));
            
            // Update evolution
            evoUpdateEvolution(dt);
            
            // Update camera
            evoUpdateCamera();
        }
        
        // Always render
        if (evo.renderer && evo.scene && evo.camera) {
            evo.renderer.render(evo.scene, evo.camera);
        }
        
        requestAnimationFrame(evoAnimate);
    } catch (e) {
        console.error('Animation error:', e);
    }
}

// Start evolution
function evoStartEvolution() {
    evo.isRunning = true;
    evo.startTime = Date.now();
    document.getElementById('evo-start-btn').disabled = true;
    document.getElementById('evo-pause-btn').disabled = false;
    document.getElementById('evo-start-btn').innerHTML = '‚ö° Evolving...';
}

// Pause evolution
function evoPauseEvolution() {
    evo.isRunning = false;
    document.getElementById('evo-start-btn').disabled = false;
    document.getElementById('evo-pause-btn').disabled = true;
    document.getElementById('evo-start-btn').innerHTML = '‚ñ∂Ô∏è Resume';
}

// Reset evolution
function evoResetEvolution() {
    evoPauseEvolution();
    
    // Remove all creatures
    evo.creatures.forEach(c => c.die());
    evo.creatures = [];
    
    // Reset stats
    evo.generation = 1;
    evo.mutations = 0;
    evo.bestFitnessHistory = [];
    evo.startTime = 0;
    
    // Create new population
    evoCreatePopulation();
    
    // Reset UI
    document.getElementById('evo-start-btn').innerHTML = 'üöÄ Start Evolution';
    document.getElementById('evo-overlay-stats').style.display = 'none';
    document.getElementById('evo-leaderboard').style.display = 'none';
    
    // Reset camera
    evo.camera.position.set(0, 20, 30);
    evo.camera.lookAt(0, 0, 0);
    
    // Update stats
    evoUpdateStats();
}

// Handle window resize
function evoHandleResize() {
    if (evo.renderer && evo.camera) {
        const container = document.getElementById('evo-canvas-container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        evo.camera.aspect = width / height;
        evo.camera.updateProjectionMatrix();
        evo.renderer.setSize(width, height);
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        // Load Three.js dynamically
        if (typeof THREE === 'undefined') {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            script.onload = function() {
                setTimeout(evoInit, 100);
                // Add resize listener
                window.addEventListener('resize', evoHandleResize);
            };
            document.head.appendChild(script);
        } else {
            setTimeout(evoInit, 100);
            window.addEventListener('resize', evoHandleResize);
        }
    });
} else {
    setTimeout(evoInit, 100);
    window.addEventListener('resize', evoHandleResize);
}
</script>

<style>
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

#evo-canvas-container canvas {
    display: block;
    border-radius: 4px;
}

#evo-permanent-bonus {
    animation: pulse 2s infinite;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #evo-canvas-container {
        height: 250px !important;
    }
    
    .results > div {
        grid-template-columns: repeat(2, 1fr) !important;
    }
}
</style>
