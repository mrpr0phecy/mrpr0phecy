<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  /* DARK DEFAULTS DIRECTLY IN CSS - NO VARIABLES FOR BACKGROUND */
  html,body{
    height:100%;
    margin:0;
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(135deg, #0a0f14, #141e28); /* DARK DEFAULT */
    color:#e6faff;
    -webkit-font-smoothing:antialiased;
    background-attachment: fixed;
    background-size: cover;
    overflow-x: hidden;
  }
  
  /* CSS VARIABLES ONLY FOR THINGS THAT CHANGE */
  :root{
    --accent:#2dd4ff; 
    --muted:#e6faff; 
    --text:#e6faff;
    --glass: rgba(255,255,255,0.06);
    --panel: rgba(20,20,20,0.92);
    --card-grad-1: rgba(255,255,255,0.02);
    --card-grad-2: rgba(255,255,255,0.04);
    --border: rgba(255,255,255,0.10);
    --card-min: 260px;
    --card-scale: 1;
    --card-translateY: 18px;
    --toolbox-width: 520px;
    --toolbox-height: 420px;
  }

  header{
    padding:20px;
    text-align:center;
    z-index:2
  }
  
  header h1{
    margin:0;
    color:var(--accent);
    font-size:1.6rem
  }

  .control-btn{
    position:fixed;
    bottom:18px;
    z-index:14000;
    width:48px;
    height:48px;
    border-radius:10px;
    background:var(--glass);
    border:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    backdrop-filter:blur(6px);
    box-shadow:0 8px 30px rgba(0,0,0,0.45);
    color:var(--accent);
    transition: transform 0.2s;
  }
  
  .control-btn:hover{
    transform:scale(1.06)
  }
  
  #toolboxToggle{left:18px}
  #paletteToggle{left:78px}
  #readerToggle{left:138px}

  .palette-panel{
    position:fixed;
    left:78px;
    bottom:74px;
    z-index:13900;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:10px;
    padding:12px;
    box-shadow:0 12px 36px rgba(0,0,0,0.6);
    backdrop-filter:blur(8px);
    display:none;
    pointer-events:none;
  }
  
  .palette-panel.open{
    display:block;
    pointer-events:auto
  }

  .toolbox {
    position:fixed;
    right:18px;
    bottom:18px;
    width:var(--toolbox-width);
    height:var(--toolbox-height);
    z-index:13700;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:0 18px 48px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    resize:both;
    min-width:300px;
    min-height:200px;
  }
  
  .toolbox.hidden{
    display:none
  }

  .toolbox .titlebar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px;
    border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    cursor:grab;
    z-index:13750;
  }

  .toolbox .content{
    position:relative;
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    overflow:auto;
    min-height:100px;
  }

  .widget-wrap{
    position:absolute;
    box-sizing:border-box;
    background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.04);
    min-width:160px;
    min-height:120px;
    max-width:calc(100% - 20px);
    max-height:calc(100% - 20px);
    overflow:hidden;
    resize:both;
    z-index:1;
    box-shadow:0 8px 20px rgba(0,0,0,0.35);
  }

  .widget-titlebar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:8px 10px;
    border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    cursor:move;
    user-select:none;
    font-size:12px;
  }
  
  .widget-titlebar strong{
    color:var(--accent);
    font-size:12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width:120px;
  }
  
  .widget-body{
    padding:10px;
    overflow:auto;
    height:calc(100% - 40px);
    font-size:12px;
    line-height:1.4;
  }

  .widget-close, #toolboxClose { 
    z-index: 13800; 
    position: relative; 
    background:transparent;
    border:0;
    color:var(--muted);
    cursor:pointer;
    font-size:12px;
    width:20px;
    height:20px;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  main{
    position:relative;
    z-index:2;
    scroll-margin-top: 0;
  }
  
  .search-bar{
    max-width:1100px;
    margin:14px auto 16px;
    display:flex;
    background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.02));
    border-radius:12px;
    padding:12px 16px;
    border:1px solid rgba(255,255,255,0.04);
    scroll-margin-top: 20px;
  }
  
  .search-bar input{
    flex:1;
    border:none;
    background:transparent;
    color:var(--text);
    font-size:1rem;
    outline:none
  }

  .controls{
    display:flex;
    gap:8px;
    justify-content:center;
    margin-bottom:12px;
    flex-wrap: wrap;
  }
  
  .controls button{
    padding:8px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.06);
    background:transparent;
    color:var(--muted);
    cursor:pointer;
    transition: all 0.2s;
    font-size:14px;
  }
  
  .controls button:hover{
    background: rgba(45,212,255,0.1);
    border-color: rgba(45,212,255,0.3);
  }

  .dashboard{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
    gap:20px;
    padding:20px;
    align-items:start;
    box-sizing:border-box;
    max-width:100%;
    overflow:hidden;
    min-height: 800px;
    position: relative;
  }

  /* ===== FIXED CARD STYLES - NO CONTENT CUTOFF ===== */
  .card{
    box-sizing:border-box;
    background:linear-gradient(135deg,var(--card-grad-1),var(--card-grad-2));
    border:1px solid var(--border);
    border-radius:12px;
    padding:16px;
    min-height:120px;
    width:100%;
    max-width:100%;
    opacity:0;
    transform: translateY(var(--card-translateY)) scale(var(--card-scale));
    transition: opacity .36s ease, transform .36s ease;
    box-shadow:0 8px 24px rgba(0,0,0,0.35);
    overflow: visible; /* CHANGED FROM hidden to visible */
    height: auto; /* AUTO HEIGHT BY DEFAULT */
    position: relative;
    contain: layout style;
    word-wrap: break-word;
    overflow-wrap: break-word;
    cursor: default;
    /* NEW: Card will expand to fit content */
    display: flex;
    flex-direction: column;
  }
  
  .card.visible{
    opacity:1;
    transform: translateY(0) scale(var(--card-scale));
  }
  
  /* Card content wrapper - FIXED: Full height content */
  .card-content-wrapper {
    position: relative;
    width: 100%;
    flex: 1; /* Take up all available space */
    min-height: 100px;
    overflow: visible; /* CHANGED FROM auto to visible */
  }
  
  /* Card body - where the actual content goes */
  .card-body {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    word-wrap: break-word;
    overflow-wrap: break-word;
    /* NEW: Allow content to determine height */
    overflow: visible;
    min-height: 100px;
  }
  
  /* Ensure all card content fits properly */
  .card-body * {
    max-width: 100%;
    box-sizing: border-box;
  }
  
  .card-body img,
  .card-body video,
  .card-body iframe,
  .card-body canvas {
    max-width: 100%;
    height: auto;
    display: block;
  }
  
  .card-body table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
  }
  
  .card-body pre,
  .card-body code {
    white-space: pre-wrap;
    word-break: break-word;
    max-width: 100%;
  }
  
  .card-body textarea,
  .card-body input,
  .card-body select {
    max-width: 100%;
    box-sizing: border-box;
  }
  
  /* Fix for iframes to show all content */
  .card-body iframe {
    min-height: 300px; /* Minimum height for iframes */
  }
  
  .card-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
    cursor: default;
    user-select: none;
    flex-shrink: 0; /* Don't shrink header */
  }
  
  .card-header h3{
    margin:0;
    color:var(--accent);
    font-size:1.05rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width:70%;
  }
  
  /* Custom scrollbar for toolbox */
  .toolbox .content::-webkit-scrollbar {
    width: 6px;
  }
  
  .toolbox .content::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.03);
    border-radius: 3px;
  }
  
  .toolbox .content::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 3px;
    opacity: 0.5;
  }
  
  .toolbox .content::-webkit-scrollbar-thumb:hover {
    opacity: 0.8;
  }

  /* ===== SIMPLE EMBED SECTION ===== */
  .embed-section {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.06);
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
  }
  
  .embed-section span {
    color: rgba(230,250,255,0.7);
    white-space: nowrap;
  }
  
  .embed-btn {
    background: rgba(45,212,255,0.1);
    color: var(--accent);
    border: 1px solid rgba(45,212,255,0.3);
    padding: 4px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  
  .embed-btn:hover {
    background: rgba(45,212,255,0.2);
    transform: translateY(-1px);
  }
  
  .embed-btn.copied {
    background: rgba(57,255,20,0.1);
    color: #39ff14;
    border-color: rgba(57,255,20,0.3);
  }

  /* ===== READER MODE FIXES ===== */
  body.reader-mode{
    font-size:1.12rem;
    line-height:1.6
  }
  
  body.reader-mode .dashboard{
    grid-template-columns:1fr;
    gap:18px
  }
  
  body.reader-mode .card{
    padding:20px;
    background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));
    border-color:rgba(255,255,255,0.06);
    /* Ensure reader mode cards also show all content */
    overflow: visible;
  }
  
  body.reader-mode .card-content-wrapper {
    overflow: visible;
  }
  
  body.reader-mode .card-body {
    overflow: visible;
  }

  /* ===== LOADING ANIMATIONS ===== */
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 0.8; }
    100% { opacity: 0.6; }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .card-loading {
    animation: pulse 1.5s infinite;
  }
  
  .card-loaded {
    animation: fadeIn 0.3s ease-out;
  }

  /* Loading indicator */
  .loading-indicator {
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 12px;
    color: var(--accent);
    z-index: 13000;
    backdrop-filter: blur(6px);
    display: none;
    align-items: center;
    gap: 8px;
  }
  
  .loading-indicator .spinner {
    width: 12px;
    height: 12px;
    border: 2px solid rgba(45,212,255,0.3);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* ===== MOBILE-FRIENDLY SCROLLING FIX ===== */
  @media (max-width: 768px) {
    .card {
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
    }
    
    .dashboard {
      gap: 16px;
      padding: 16px;
      min-height: 600px;
    }
    
    .card-header h3 {
      padding: 4px 0;
      font-size: 1rem;
    }
    
    .search-bar input {
      font-size: 16px;
    }
    
    .controls {
      gap: 6px;
    }
    
    .controls button {
      padding: 6px 10px;
      font-size: 14px;
    }
    
    .loading-indicator {
      bottom: 60px;
      right: 10px;
      left: 10px;
      text-align: center;
      justify-content: center;
    }
    
    .toolbox {
      width: calc(100% - 36px);
      height: 300px;
      right: 18px;
      left: 18px;
    }
  }
  
  /* Fix for very small screens */
  @media (max-width: 480px) {
    .dashboard {
      grid-template-columns: 1fr;
      padding: 12px;
      min-height: 500px;
    }
    
    .card {
      padding: 12px;
    }
    
    .control-btn {
      width: 44px;
      height: 44px;
      bottom: 12px;
    }
    
    #toolboxToggle { left: 12px; }
    #paletteToggle { left: 66px; }
    #readerToggle { left: 120px; }
  }
</style>
</head>
<body>

  <button id="toolboxToggle" class="control-btn" title="Open toolbox">ðŸ§°</button>
  <button id="paletteToggle" class="control-btn" title="Theme">ðŸŽ¨</button>
  <button id="readerToggle" class="control-btn" title="Reader mode">ðŸ‘“</button>

  <!-- Loading indicator -->
  <div id="loadingIndicator" class="loading-indicator">
    <div class="spinner"></div>
    <span id="loadingText">Loading cards...</span>
  </div>

  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px">Accent color</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#00ff99" style="background:#00ff99;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd;height:34px;border-radius:8px;cursor:pointer"></div>
    </div>
    
    <!-- SIMPLIFIED BACKGROUND THEMES - DIRECT COLOR VALUES -->
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px;margin-top:12px">Background theme</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <button class="theme-btn active" data-color="default" style="background:linear-gradient(135deg, #0a0f14, #141e28);height:34px;border-radius:8px;cursor:pointer;border:2px solid var(--accent)"></button>
      <button class="theme-btn" data-color="deep-blue" style="background:linear-gradient(135deg, #05080c, #0f151f);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-purple" style="background:linear-gradient(135deg, #12081a, #1f1229);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-teal" style="background:linear-gradient(135deg, #061616, #0f2525);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-red" style="background:linear-gradient(135deg, #160606, #251010);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
    </div>
  </div>

  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div style="font-weight:600;color:var(--accent)">Toolbox</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="dockBtn" title="Dock/undock" style="background:transparent;border:0;color:var(--muted);cursor:pointer">â‡±</button>
        <button id="toolboxClose" title="Close" style="background:transparent;border:0;color:var(--muted);cursor:pointer">âœ•</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite"></div>
  </div>

  <header><h1>The Most Useful Site in the World</h1></header>

  <main>
    <div class="search-bar"><input id="searchInput" placeholder="Search cards..." autofocus /></div>

    <div class="controls">
      <button id="sortAlphaBtn">Sort Aâ†’Z</button>
      <button id="sortRandomBtn">Random</button>
      <button id="reloadCardsBtn" title="Reload card list">Reload Cards</button>
      <button id="loadAllBtn" title="Load all cards at once">Load All Cards</button>
    </div>

    <div id="status" class="muted" style="text-align:center;margin-bottom:6px">Loading card list...</div>
    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
    
    <!-- Infinite scroll sentinel -->
    <div id="scrollSentinel" style="height:1px;margin-top:20px;"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
// ===== FIXED TOOLBOX AND CARD CONTENT SYSTEM =====

console.log("=== STARTING FIXED SYSTEM ===");

// Configuration
const CONFIG = {
  LOAD_BATCH_SIZE: 8,
  LOAD_DELAY: 50,
  INITIAL_LOAD: 16,
  MAX_CONCURRENT_LOADS: 6,
  OBSERVER_ROOT_MARGIN: '800px'
};

// Global state
let allCards = [];
let loadedCards = new Set();
let loadingCards = new Set();
let cardCache = new Map();
let observer = null;
let isSearching = false;

// Background themes
const themes = {
  'default': { bg1: '#0a0f14', bg2: '#141e28' },
  'deep-blue': { bg1: '#05080c', bg2: '#0f151f' },
  'deep-purple': { bg1: '#12081a', bg2: '#1f1229' },
  'deep-teal': { bg1: '#061616', bg2: '#0f2525' },
  'deep-red': { bg1: '#160606', bg2: '#251010' }
};

// Toolbox widgets
let widgets = [];
let toolboxDocked = false;

// ===== THEME SYSTEM =====
function applyTheme(themeName) {
  const theme = themes[themeName];
  if (!theme) return;
  
  const gradient = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
  document.documentElement.style.background = gradient;
  document.body.style.background = gradient;
  
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === themeName) {
      btn.style.background = gradient;
    }
  });
  
  localStorage.setItem('theme', themeName);
}

// ===== TOOLBOX SYSTEM - FIXED =====
function initToolbox() {
  const toolbox = document.getElementById('toolbox');
  const toolboxTitle = document.getElementById('toolboxTitle');
  
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  toolboxTitle.addEventListener('mousedown', startDrag);
  
  function startDrag(e) {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = toolbox.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = 'grabbing';
  }
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    toolbox.style.left = (e.clientX - dragOffset.x) + 'px';
    toolbox.style.right = 'auto';
    toolbox.style.top = (e.clientY - dragOffset.y) + 'px';
    toolbox.style.bottom = 'auto';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = '';
  }
  
  // Dock/undock button
  document.getElementById('dockBtn').addEventListener('click', function(e) {
    e.stopPropagation();
    toolboxDocked = !toolboxDocked;
    
    if (toolboxDocked) {
      toolbox.style.left = 'auto';
      toolbox.style.right = '18px';
      toolbox.style.top = 'auto';
      toolbox.style.bottom = '18px';
      this.textContent = 'â‡²';
    } else {
      toolbox.style.left = 'auto';
      toolbox.style.right = 'auto';
      toolbox.style.top = '100px';
      toolbox.style.left = '100px';
      this.textContent = 'â‡±';
    }
  });
  
  // Load saved widgets
  loadSavedWidgets();
}

function createWidget(name, contentHTML) {
  const widgetId = 'widget-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  const widget = document.createElement('div');
  widget.className = 'widget-wrap';
  widget.id = widgetId;
  widget.dataset.name = name;
  
  // Random position within toolbox
  const toolboxContent = document.getElementById('toolboxContent');
  
  widget.style.left = Math.random() * 200 + 'px';
  widget.style.top = Math.random() * 150 + 'px';
  widget.style.width = '200px';
  widget.style.height = '150px';
  
  widget.innerHTML = `
    <div class="widget-titlebar">
      <strong>${name}</strong>
      <button class="widget-close" title="Close widget">âœ•</button>
    </div>
    <div class="widget-body">${contentHTML}</div>
  `;
  
  toolboxContent.appendChild(widget);
  
  // Save widget
  widgets.push({
    id: widgetId,
    name: name,
    content: contentHTML,
    x: widget.style.left,
    y: widget.style.top,
    width: widget.style.width,
    height: widget.style.height
  });
  
  saveWidgets();
  
  // Make widget draggable
  makeWidgetDraggable(widget);
  
  // Make widget resizable
  makeWidgetResizable(widget);
  
  // Close button
  widget.querySelector('.widget-close').addEventListener('click', function(e) {
    e.stopPropagation();
    widget.remove();
    widgets = widgets.filter(w => w.id !== widgetId);
    saveWidgets();
  });
  
  return widgetId;
}

function makeWidgetDraggable(widget) {
  const titlebar = widget.querySelector('.widget-titlebar');
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  titlebar.addEventListener('mousedown', startDrag);
  
  function startDrag(e) {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = widget.getBoundingClientRect();
    const parentRect = widget.parentElement.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    widget.style.zIndex = '1000';
  }
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    const parentRect = widget.parentElement.getBoundingClientRect();
    const x = e.clientX - parentRect.left - dragOffset.x;
    const y = e.clientY - parentRect.top - dragOffset.y;
    
    // Keep within bounds
    const maxX = parentRect.width - widget.offsetWidth;
    const maxY = parentRect.height - widget.offsetHeight;
    
    widget.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
    widget.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    widget.style.zIndex = '1';
    
    // Update saved position
    const widgetObj = widgets.find(w => w.id === widget.id);
    if (widgetObj) {
      widgetObj.x = widget.style.left;
      widgetObj.y = widget.style.top;
      saveWidgets();
    }
  }
}

function makeWidgetResizable(widget) {
  const resizeHandle = document.createElement('div');
  resizeHandle.style.position = 'absolute';
  resizeHandle.style.right = '0';
  resizeHandle.style.bottom = '0';
  resizeHandle.style.width = '16px';
  resizeHandle.style.height = '16px';
  resizeHandle.style.cursor = 'se-resize';
  resizeHandle.style.background = 'transparent';
  resizeHandle.style.zIndex = '10';
  
  widget.appendChild(resizeHandle);
  
  let isResizing = false;
  let startWidth, startHeight, startX, startY;
  
  resizeHandle.addEventListener('mousedown', startResize);
  
  function startResize(e) {
    e.stopPropagation();
    isResizing = true;
    startWidth = parseInt(getComputedStyle(widget).width);
    startHeight = parseInt(getComputedStyle(widget).height);
    startX = e.clientX;
    startY = e.clientY;
    
    document.addEventListener('mousemove', onResize);
    document.addEventListener('mouseup', stopResize);
  }
  
  function onResize(e) {
    if (!isResizing) return;
    
    e.preventDefault();
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    const newWidth = Math.max(160, startWidth + dx);
    const newHeight = Math.max(120, startHeight + dy);
    
    widget.style.width = newWidth + 'px';
    widget.style.height = newHeight + 'px';
  }
  
  function stopResize() {
    isResizing = false;
    document.removeEventListener('mousemove', onResize);
    document.removeEventListener('mouseup', stopResize);
    
    // Update saved size
    const widgetObj = widgets.find(w => w.id === widget.id);
    if (widgetObj) {
      widgetObj.width = widget.style.width;
      widgetObj.height = widget.style.height;
      saveWidgets();
    }
  }
}

function saveWidgets() {
  localStorage.setItem('toolboxWidgets', JSON.stringify(widgets));
}

function loadSavedWidgets() {
  const saved = localStorage.getItem('toolboxWidgets');
  if (saved) {
    try {
      widgets = JSON.parse(saved) || [];
      widgets.forEach(widgetData => {
        const widget = document.createElement('div');
        widget.className = 'widget-wrap';
        widget.id = widgetData.id;
        widget.dataset.name = widgetData.name;
        widget.style.left = widgetData.x;
        widget.style.top = widgetData.y;
        widget.style.width = widgetData.width;
        widget.style.height = widgetData.height;
        
        widget.innerHTML = `
          <div class="widget-titlebar">
            <strong>${widgetData.name}</strong>
            <button class="widget-close" title="Close widget">âœ•</button>
          </div>
          <div class="widget-body">${widgetData.content}</div>
        `;
        
        document.getElementById('toolboxContent').appendChild(widget);
        
        makeWidgetDraggable(widget);
        makeWidgetResizable(widget);
        
        widget.querySelector('.widget-close').addEventListener('click', function(e) {
          e.stopPropagation();
          widget.remove();
          widgets = widgets.filter(w => w.id !== widgetData.id);
          saveWidgets();
        });
      });
    } catch (e) {
      console.error('Failed to load widgets:', e);
      widgets = [];
    }
  }
}

// ===== EMBED SYSTEM =====
function addEmbedSectionToCard(card, fileName) {
  const cardName = fileName.replace('.html', '');
  const displayName = cardName.replace(/-/g, ' ');
  
  const embedHTML = `
    <div class="embed-section">
      <span>Share this tool:</span>
      <button class="embed-btn" data-card="${cardName}" data-file="${fileName}">
        ðŸ”— Copy Embed Code
      </button>
    </div>
  `;
  
  const contentBody = card.querySelector('.card-body');
  if (contentBody) {
    contentBody.insertAdjacentHTML('beforeend', embedHTML);
    
    const embedBtn = contentBody.querySelector('.embed-btn');
    if (embedBtn) {
      embedBtn.addEventListener('click', function() {
        copyEmbedCode(cardName, fileName, displayName);
      });
    }
  }
}

function copyEmbedCode(cardName, fileName, displayName) {
  const embedCode = `<iframe src="https://mrpr0phecy.github.io/mrpr0phecy/cards/${fileName}" width="100%" height="400" style="border:none;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);" title="${displayName} - The Most Useful Site"></iframe>`;
  
  navigator.clipboard.writeText(embedCode).then(() => {
    const embedBtn = document.querySelector(`.embed-btn[data-card="${cardName}"]`);
    if (embedBtn) {
      const originalText = embedBtn.textContent;
      embedBtn.textContent = 'âœ… Copied!';
      embedBtn.classList.add('copied');
      
      setTimeout(() => {
        embedBtn.textContent = originalText;
        embedBtn.classList.remove('copied');
      }, 2000);
    }
  }).catch(err => {
    console.error('Failed to copy: ', err);
    const textArea = document.createElement('textarea');
    textArea.value = embedCode;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (e) {}
    document.body.removeChild(textArea);
  });
}

// ===== FIXED CARD LOADING SYSTEM =====
function initIntersectionObserver() {
  if (observer) {
    observer.disconnect();
  }
  
  observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const card = entry.target;
        const cardName = card.dataset.name;
        
        if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
          loadCard(card, cardName);
        }
      }
    });
  }, {
    root: null,
    rootMargin: CONFIG.OBSERVER_ROOT_MARGIN,
    threshold: 0.01
  });
  
  // Observe all unloaded cards
  const unloadedCards = document.querySelectorAll('.card:not(.loaded):not(.loading)');
  unloadedCards.forEach(card => {
    observer.observe(card);
  });
  
  console.log(`Observing ${unloadedCards.length} cards with ${CONFIG.OBSERVER_ROOT_MARGIN} root margin`);
}

function loadCard(card, cardName) {
  if (loadingCards.has(cardName) || loadedCards.has(cardName)) return;
  
  loadingCards.add(cardName);
  
  const contentBody = card.querySelector('.card-body');
  if (!contentBody) {
    loadingCards.delete(cardName);
    return;
  }
  
  // Mark as loading
  card.classList.add('loading');
  contentBody.innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.6)">Loading...</div>';
  
  // Check cache first
  if (cardCache.has(cardName)) {
    setTimeout(() => {
      const cachedHTML = cardCache.get(cardName);
      processLoadedCard(card, cardName, cachedHTML, true);
      loadingCards.delete(cardName);
    }, 50);
    return;
  }
  
  // Fetch from server
  fetch(`cards/${cardName}.html`)
    .then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.text();
    })
    .then(html => {
      // Cache the HTML
      cardCache.set(cardName, html);
      processLoadedCard(card, cardName, html, false);
      loadingCards.delete(cardName);
    })
    .catch(error => {
      console.error(`Failed to load card ${cardName}:`, error);
      contentBody.innerHTML = `<div style="padding:20px;text-align:center;color:rgba(255,77,77,0.6)">
        Failed to load card
      </div>`;
      card.classList.remove('loading');
      loadedCards.add(cardName);
      loadingCards.delete(cardName);
      updateStatusText();
    });
}

function processLoadedCard(card, cardName, html, fromCache) {
  const contentBody = card.querySelector('.card-body');
  
  // Load HTML
  contentBody.innerHTML = html;
  
  // Add embed section
  addEmbedSectionToCard(card, `${cardName}.html`);
  
  // Execute scripts
  const scripts = contentBody.querySelectorAll('script');
  scripts.forEach(script => {
    const newScript = document.createElement('script');
    if (script.src) {
      newScript.src = script.src;
    } else {
      newScript.textContent = script.textContent;
    }
    [...script.attributes].forEach(attr => {
      newScript.setAttribute(attr.name, attr.value);
    });
    script.parentNode.replaceChild(newScript, script);
  });
  
  // FIX: Ensure all content is visible
  setTimeout(() => {
    // Remove any max-height constraints that might hide content
    contentBody.style.maxHeight = 'none';
    contentBody.style.overflow = 'visible';
    
    // Also ensure wrapper allows full content
    const wrapper = card.querySelector('.card-content-wrapper');
    if (wrapper) {
      wrapper.style.maxHeight = 'none';
      wrapper.style.overflow = 'visible';
    }
    
    // Mark as loaded
    loadedCards.add(cardName);
    card.classList.remove('loading');
    card.classList.add('loaded', 'visible');
    
    // Stop observing this card
    if (observer) {
      observer.unobserve(card);
    }
    
    updateStatusText();
    
    console.log(`Loaded card: ${cardName} ${fromCache ? '(from cache)' : ''}`);
  }, 100);
}

function updateStatusText() {
  const status = document.getElementById('status');
  if (!status) return;
  
  const total = allCards.length;
  const loaded = loadedCards.size;
  
  if (isSearching) {
    const visibleCards = document.querySelectorAll('.card[style=""]').length;
    status.textContent = `Search results: ${visibleCards} cards`;
  } else {
    status.textContent = `${loaded} of ${total} cards loaded`;
  }
}

function showLoadingIndicator(text = 'Loading...') {
  const indicator = document.getElementById('loadingIndicator');
  const textElement = document.getElementById('loadingText');
  
  if (indicator && textElement) {
    textElement.textContent = text;
    indicator.style.display = 'flex';
  }
}

function hideLoadingIndicator() {
  const indicator = document.getElementById('loadingIndicator');
  if (indicator) {
    indicator.style.display = 'none';
  }
}

// ===== CARD MANAGEMENT =====
function createCardPlaceholders(cardNames) {
  const grid = document.getElementById('gridContainer');
  grid.innerHTML = '';
  
  cardNames.forEach((cardName, index) => {
    const card = document.createElement('div');
    card.className = 'card';
    card.dataset.name = cardName;
    card.dataset.index = index;
    
    const header = document.createElement('div');
    header.className = 'card-header';
    header.innerHTML = `<h3>${cardName.replace(/-/g, ' ')}</h3>
      <div style="display:flex;gap:8px">
        <div class="add-to-toolbox" title="Add to toolbox" style="cursor:pointer;font-weight:bold;color:var(--accent);font-size:18px;line-height:1;user-select:none">+</div>
      </div>`;
    
    const content = document.createElement('div');
    content.className = 'content';
    content.innerHTML = `
      <div class="card-content-wrapper">
        <div class="card-body">
          <div style="padding:20px;text-align:center;color:rgba(230,250,255,0.4)">
            Loading...
          </div>
        </div>
      </div>
    `;
    
    card.appendChild(header);
    card.appendChild(content);
    grid.appendChild(card);
  });
  
  updateStatusText();
}

// ===== LOAD ALL CARDS FUNCTION =====
async function loadAllCards() {
  showLoadingIndicator('Loading all cards...');
  
  const cards = document.querySelectorAll('.card:not(.loaded):not(.loading)');
  const total = cards.length;
  
  // Load in batches
  const batchSize = CONFIG.MAX_CONCURRENT_LOADS;
  
  for (let i = 0; i < cards.length; i += batchSize) {
    const batch = Array.from(cards).slice(i, i + batchSize);
    
    // Load batch with delay
    await Promise.all(batch.map((card, index) => {
      return new Promise(resolve => {
        setTimeout(() => {
          const cardName = card.dataset.name;
          if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
            loadCard(card, cardName);
          }
          resolve();
        }, index * 100);
      });
    }));
    
    // Small delay between batches
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  
  hideLoadingIndicator();
}

// ===== LOAD CARD LIST =====
async function loadCardList() {
  try {
    document.getElementById('status').textContent = 'Fetching card list...';
    showLoadingIndicator('Loading card list...');
    
    // Clear previous state
    allCards = [];
    loadedCards.clear();
    loadingCards.clear();
    cardCache.clear();
    
    // Try GitHub API
    let cardFiles = [];
    
    try {
      const DEFAULT_REPO = 'mrpr0phecy/mrpr0phecy';
      const DEFAULT_BRANCH = 'main';
      const [owner, repo] = DEFAULT_REPO.split('/');
      
      const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${DEFAULT_BRANCH}?recursive=1`;
      const response = await fetch(url);
      
      if (response.ok) {
        const data = await response.json();
        cardFiles = (data.tree || [])
          .filter(item => item.path.startsWith('cards/') && item.path.endsWith('.html'))
          .map(item => item.path.replace(/^cards\//, '').replace('.html', ''))
          .sort();
          
        console.log(`Found ${cardFiles.length} cards via GitHub API`);
      }
    } catch (githubError) {
      console.log('GitHub API failed:', githubError);
      // Fallback to known cards
      cardFiles = [
        'battery-sizing',
        'cable-calculator', 
        'chord-finder',
        'circuit-calculator',
        'evolution-walker',
        'tip-calculator',
        'unit-converter',
        'countdown-timer'
      ];
    }
    
    allCards = cardFiles;
    
    if (allCards.length === 0) {
      throw new Error('No cards found');
    }
    
    // Create card placeholders
    createCardPlaceholders(allCards);
    hideLoadingIndicator();
    
    // Initialize Intersection Observer IMMEDIATELY
    initIntersectionObserver();
    
    // Load initial batch of cards IMMEDIATELY
    loadInitialCards();
    
  } catch (error) {
    console.error("Error loading card list:", error);
    document.getElementById('status').textContent = 'Error loading cards. Click "Reload Cards" to try again.';
    hideLoadingIndicator();
    
    const grid = document.getElementById('gridContainer');
    grid.innerHTML = `
      <div style="grid-column:1/-1;text-align:center;padding:40px;">
        <div style="color:var(--accent);font-size:1.2rem;margin-bottom:16px;">
          Failed to load cards
        </div>
        <div style="color:rgba(230,250,255,0.7);margin-bottom:24px;">
          Error: ${error.message || 'Unknown error'}
        </div>
        <button onclick="loadCardList()" style="padding:12px 24px;background:rgba(45,212,255,0.1);border:1px solid rgba(45,212,255,0.3);color:var(--accent);border-radius:8px;cursor:pointer;">
          Retry Loading Cards
        </button>
      </div>
    `;
  }
}

function loadInitialCards() {
  // Load first batch of cards immediately
  const cards = document.querySelectorAll('.card:not(.loaded):not(.loading)');
  const initialCount = Math.min(CONFIG.INITIAL_LOAD, cards.length);
  
  console.log(`Loading ${initialCount} initial cards`);
  
  for (let i = 0; i < initialCount; i++) {
    const card = cards[i];
    const cardName = card.dataset.name;
    
    if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
      setTimeout(() => {
        loadCard(card, cardName);
      }, i * 100);
    }
  }
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
  console.log("DOM ready - Starting auto-load...");
  
  // Scroll to top
  window.scrollTo(0, 0);
  
  // Apply saved theme
  const savedTheme = localStorage.getItem('theme') || 'default';
  applyTheme(savedTheme);
  
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === savedTheme) {
      btn.classList.add('active');
      btn.style.border = '2px solid var(--accent)';
    } else {
      btn.classList.remove('active');
      btn.style.border = '1px solid var(--border)';
    }
  });
  
  // Apply saved accent
  const savedAccent = localStorage.getItem('accent') || '#2dd4ff';
  document.documentElement.style.setProperty('--accent', savedAccent);
  document.querySelectorAll('.palette-color').forEach(c => {
    c.classList.toggle('active', c.dataset.accent === savedAccent);
  });
  
  // Apply reader mode
  if(localStorage.getItem('readerMode') === 'on') {
    document.body.classList.add('reader-mode');
  }
  
  // Initialize systems
  initToolbox();
  
  // Load cards IMMEDIATELY
  loadCardList();
});

// ===== UI CONTROLS =====
document.getElementById('paletteToggle').addEventListener('click', function() {
  const panel = document.getElementById('palettePanel');
  panel.classList.toggle('open');
});

document.querySelectorAll('.palette-color').forEach(c => {
  c.addEventListener('click', function() {
    document.querySelectorAll('.palette-color').forEach(x => x.classList.remove('active'));
    this.classList.add('active');
    const col = this.dataset.accent;
    document.documentElement.style.setProperty('--accent', col);
    localStorage.setItem('accent', col);
  });
});

document.querySelectorAll('.theme-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.theme-btn').forEach(b => {
      b.classList.remove('active');
      b.style.border = '1px solid var(--border)';
    });
    this.classList.add('active');
    this.style.border = '2px solid var(--accent)';
    
    const themeName = this.dataset.color;
    applyTheme(themeName);
  });
});

// Toolbox controls - FIXED EVENT HANDLERS
const toolbox = document.getElementById('toolbox');
document.getElementById('toolboxToggle').addEventListener('click', function(e) {
  e.stopPropagation();
  toolbox.classList.toggle('hidden');
  console.log('Toolbox toggled, hidden:', toolbox.classList.contains('hidden'));
});

document.getElementById('toolboxClose').addEventListener('click', function(e) {
  e.stopPropagation();
  toolbox.classList.add('hidden');
  console.log('Toolbox closed');
});

// Reader mode
document.getElementById('readerToggle').addEventListener('click', function() {
  document.body.classList.toggle('reader-mode');
  localStorage.setItem('readerMode', document.body.classList.contains('reader-mode') ? 'on' : 'off');
});

// ===== SEARCH =====
const searchInput = document.getElementById('searchInput');
let searchTimeout = null;

searchInput.addEventListener('input', function(e) {
  const q = e.target.value.toLowerCase().trim();
  
  if (searchTimeout) clearTimeout(searchTimeout);
  
  searchTimeout = setTimeout(() => {
    isSearching = q.length > 0;
    const cards = document.querySelectorAll('.card');
    
    cards.forEach(card => {
      const name = card.dataset.name.toLowerCase();
      const text = card.textContent.toLowerCase();
      const matches = name.includes(q) || text.includes(q);
      
      card.style.display = matches ? '' : 'none';
      
      // If card is visible but not loaded, load it
      if (matches && !card.classList.contains('loaded') && !card.classList.contains('loading')) {
        const cardName = card.dataset.name;
        if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
          loadCard(card, cardName);
        }
      }
    });
    
    // Reinitialize observer for visible cards
    if (observer) {
      observer.disconnect();
      document.querySelectorAll('.card[style=""]:not(.loaded):not(.loading)').forEach(card => {
        observer.observe(card);
      });
    }
    
    updateStatusText();
  }, 300);
});

// ===== SORT BUTTONS =====
document.getElementById('sortAlphaBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  cards.sort((a,b) => a.dataset.name.localeCompare(b.dataset.name));
  cards.forEach(card => grid.appendChild(card));
  
  // Reinitialize observer after sorting
  setTimeout(() => {
    if (observer) {
      observer.disconnect();
      document.querySelectorAll('.card:not(.loaded):not(.loading)').forEach(card => {
        observer.observe(card);
      });
    }
  }, 100);
});

document.getElementById('sortRandomBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  for (let i = cards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [cards[i], cards[j]] = [cards[j], cards[i]];
  }
  cards.forEach(card => grid.appendChild(card));
  
  // Reinitialize observer after sorting
  setTimeout(() => {
    if (observer) {
      observer.disconnect();
      document.querySelectorAll('.card:not(.loaded):not(.loading)').forEach(card => {
        observer.observe(card);
      });
    }
  }, 100);
});

// ===== CARD CONTROLS =====
document.getElementById('reloadCardsBtn').addEventListener('click', function() {
  // Clear cache and reload
  cardCache.clear();
  loadedCards.clear();
  loadingCards.clear();
  loadCardList();
});

document.getElementById('loadAllBtn').addEventListener('click', function() {
  loadAllCards();
});

// ===== ADD TO TOOLBOX - FIXED =====
document.addEventListener('click', function(e) {
  // Check if click is on add-to-toolbox button
  const addBtn = e.target.closest('.add-to-toolbox');
  if (addBtn) {
    e.preventDefault();
    e.stopPropagation();
    
    const card = addBtn.closest('.card');
    if (!card) return;
    
    const cardName = card.dataset.name;
    
    if (!card.classList.contains('loaded')) {
      alert('Please wait for the card to load before adding to toolbox');
      return;
    }
    
    const contentBody = card.querySelector('.card-body');
    if (!contentBody) return;
    
    // Clone the content but remove the embed section
    const contentClone = contentBody.cloneNode(true);
    const embedSection = contentClone.querySelector('.embed-section');
    if (embedSection) {
      embedSection.remove();
    }
    
    // Create widget in toolbox
    createWidget(cardName.replace(/-/g, ' '), contentClone.innerHTML);
    
    // Show toolbox if hidden
    if (toolbox.classList.contains('hidden')) {
      toolbox.classList.remove('hidden');
    }
    
    // Visual feedback
    addBtn.textContent = 'âœ“';
    addBtn.style.color = 'var(--accent)';
    setTimeout(() => {
      addBtn.textContent = '+';
      addBtn.style.color = '';
    }, 1000);
    
    console.log(`Added "${cardName}" to toolbox`);
  }
});

// Make Sortable (disabled on main page)
new Sortable(document.getElementById('gridContainer'), {
  animation: 150,
  disabled: true
});

// Backup scroll listener
let scrollCheckTimeout;
window.addEventListener('scroll', () => {
  if (scrollCheckTimeout) clearTimeout(scrollCheckTimeout);
  scrollCheckTimeout = setTimeout(() => {
    // Force check for visible cards
    const cards = document.querySelectorAll('.card:not(.loaded):not(.loading)');
    const viewportHeight = window.innerHeight;
    const scrollY = window.scrollY;
    
    cards.forEach(card => {
      const rect = card.getBoundingClientRect();
      const cardTop = rect.top + scrollY;
      const cardBottom = rect.bottom + scrollY;
      
      // Check if card is in viewport
      const isVisible = (
        cardBottom > scrollY - 1000 &&
        cardTop < scrollY + viewportHeight + 1000
      );
      
      if (isVisible) {
        const cardName = card.dataset.name;
        if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
          loadCard(card, cardName);
        }
      }
    });
  }, 200);
}, { passive: true });

console.log("=== FIXED SYSTEM INITIALIZED ===");
</script>
</body>
</html>
