<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  /* DARK DEFAULTS DIRECTLY IN CSS - NO VARIABLES FOR BACKGROUND */
  html,body{
    height:100%;
    margin:0;
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(135deg, #0a0f14, #141e28); /* DARK DEFAULT */
    color:#e6faff;
    -webkit-font-smoothing:antialiased;
    background-attachment: fixed;
    background-size: cover;
    overflow-x: hidden;
  }
  
  /* CSS VARIABLES ONLY FOR THINGS THAT CHANGE */
  :root{
    --accent:#2dd4ff; 
    --muted:#e6faff; 
    --text:#e6faff;
    --glass: rgba(255,255,255,0.06);
    --panel: rgba(20,20,20,0.92);
    --card-grad-1: rgba(255,255,255,0.02);
    --card-grad-2: rgba(255,255,255,0.04);
    --border: rgba(255,255,255,0.10);
    --card-min: 260px;
    --card-scale: 1;
    --card-translateY: 18px;
    --toolbox-width: 520px;
    --toolbox-height: 420px;
  }

  header{
    padding:20px;
    text-align:center;
    z-index:2
  }
  
  header h1{
    margin:0;
    color:var(--accent);
    font-size:1.6rem
  }

  .control-btn{
    position:fixed;
    bottom:18px;
    z-index:14000;
    width:48px;
    height:48px;
    border-radius:10px;
    background:var(--glass);
    border:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    backdrop-filter:blur(6px);
    box-shadow:0 8px 30px rgba(0,0,0,0.45);
    color:var(--accent);
    transition: transform 0.2s;
  }
  
  .control-btn:hover{
    transform:scale(1.06)
  }
  
  #toolboxToggle{left:18px}
  #paletteToggle{left:78px}
  #readerToggle{left:138px}

  .palette-panel{
    position:fixed;
    left:78px;
    bottom:74px;
    z-index:13900;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:10px;
    padding:12px;
    box-shadow:0 12px 36px rgba(0,0,0,0.6);
    backdrop-filter:blur(8px);
    display:none;
    pointer-events:none;
  }
  
  .palette-panel.open{
    display:block;
    pointer-events:auto
  }

  .toolbox {
    position:fixed;
    right:18px;
    bottom:18px;
    width:var(--toolbox-width);
    height:var(--toolbox-height);
    z-index:13700;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:0 18px 48px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    resize:both;
    min-width:300px;
    min-height:200px;
  }
  
  .toolbox.hidden{
    display:none
  }

  .toolbox .titlebar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px;
    border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    cursor:grab;
    z-index:13750;
  }

  .toolbox .content{
    position:relative;
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    overflow:auto;
    min-height:100px;
  }

  .widget-wrap{
    position:absolute;
    box-sizing:border-box;
    background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.04);
    min-width:120px;
    min-height:80px;
    max-width:calc(100% - 20px);
    max-height:calc(100% - 20px);
    overflow:hidden;
    resize:both;
    z-index:1;
    box-shadow:0 8px 20px rgba(0,0,0,0.35);
  }

  .widget-titlebar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:8px 10px;
    border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    cursor:move;
    user-select:none;
  }
  
  .widget-titlebar strong{
    color:var(--accent);
    font-size:14px;
  }
  
  .widget-body{
    padding:10px;
    overflow:auto;
    max-height:60vh;
    font-size:14px;
    line-height:1.4;
  }

  .widget-close, #toolboxClose { 
    z-index: 13800; 
    position: relative; 
    background:transparent;
    border:0;
    color:var(--muted);
    cursor:pointer;
    font-size:14px;
  }

  main{
    position:relative;
    z-index:2;
    scroll-margin-top: 0;
  }
  
  .search-bar{
    max-width:1100px;
    margin:14px auto 16px;
    display:flex;
    background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.02));
    border-radius:12px;
    padding:12px 16px;
    border:1px solid rgba(255,255,255,0.04);
    scroll-margin-top: 20px;
  }
  
  .search-bar input{
    flex:1;
    border:none;
    background:transparent;
    color:var(--text);
    font-size:1rem;
    outline:none
  }

  .controls{
    display:flex;
    gap:8px;
    justify-content:center;
    margin-bottom:12px;
    flex-wrap: wrap;
  }
  
  .controls button{
    padding:8px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.06);
    background:transparent;
    color:var(--muted);
    cursor:pointer;
    transition: all 0.2s;
  }
  
  .controls button:hover{
    background: rgba(45,212,255,0.1);
    border-color: rgba(45,212,255,0.3);
  }

  .dashboard{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
    gap:20px;
    padding:20px;
    align-items:start;
    box-sizing:border-box;
    max-width:100%;
    overflow:hidden;
    min-height: 800px;
    position: relative;
  }

  /* ===== ENHANCED CARD STYLES ===== */
  .card{
    box-sizing:border-box;
    background:linear-gradient(135deg,var(--card-grad-1),var(--card-grad-2));
    border:1px solid var(--border);
    border-radius:12px;
    padding:16px;
    min-height:120px;
    width:100%;
    max-width:100%;
    opacity:0;
    transform: translateY(var(--card-translateY)) scale(var(--card-scale));
    transition: opacity .36s ease, transform .36s ease, height .3s ease;
    box-shadow:0 8px 24px rgba(0,0,0,0.35);
    overflow: hidden; /* Changed from visible to hidden */
    height: auto;
    max-height: 80vh;
    resize: vertical;
    position: relative;
    contain: content;
    word-wrap: break-word;
    overflow-wrap: break-word;
    cursor: default;
  }
  
  .card.visible{
    opacity:1;
    transform: translateY(0) scale(var(--card-scale));
  }
  
  /* Card resize handle */
  .card::after {
    content: 'â†•';
    position: absolute;
    bottom: 8px;
    right: 10px;
    font-size: 14px;
    color: rgba(255,255,255,0.4);
    cursor: ns-resize;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
    z-index: 10;
    background: rgba(0,0,0,0.3);
    border-radius: 4px;
    padding: 2px 4px;
  }
  
  .card:hover::after {
    opacity: 0.7;
  }
  
  .card.card-resizing::after {
    opacity: 1;
  }
  
  .card.card-auto-size::after {
    display: none;
  }
  
  /* Card content wrapper - FIXED: Now properly contains content */
  .card-content-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: auto; /* Changed from hidden to auto */
  }
  
  /* Card inner content */
  .card-inner {
    width: 100%;
    height: auto;
    min-height: 100%;
    box-sizing: border-box;
  }
  
  /* Card body - where the actual content goes */
  .card-body {
    width: 100%;
    overflow: auto;
    max-height: 100%;
    box-sizing: border-box;
  }
  
  /* Expand/collapse button */
  .card-expand-btn {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: rgba(45,212,255,0.2);
    border: 1px solid rgba(45,212,255,0.4);
    color: var(--accent);
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    cursor: pointer;
    z-index: 10;
    opacity: 0.7;
    transition: opacity 0.2s, background 0.2s;
  }
  
  .card-expand-btn:hover {
    opacity: 1;
    background: rgba(45,212,255,0.3);
  }
  
  /* Auto-sizing for card content */
  .card-auto-size {
    height: auto !important;
    min-height: 120px;
    max-height: none;
    resize: none;
  }
  
  /* Card size indicators */
  .card-size-indicator {
    position: absolute;
    top: 8px;
    right: 40px;
    font-size: 10px;
    color: rgba(255,255,255,0.4);
    background: rgba(0,0,0,0.3);
    padding: 2px 6px;
    border-radius: 10px;
    display: none;
  }
  
  .card-resizing .card-size-indicator {
    display: block;
  }
  
  .card-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
    cursor: default;
    user-select: none;
  }
  
  .card-header h3{
    margin:0;
    color:var(--accent);
    font-size:1.05rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width:70%;
  }
  
  /* Custom scrollbar for card content */
  .card-content-wrapper::-webkit-scrollbar {
    width: 6px;
  }
  
  .card-content-wrapper::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.03);
    border-radius: 3px;
  }
  
  .card-content-wrapper::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 3px;
    opacity: 0.5;
  }
  
  .card-content-wrapper::-webkit-scrollbar-thumb:hover {
    opacity: 0.8;
  }

  /* ===== SIMPLE EMBED SECTION ===== */
  .embed-section {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.06);
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
  }
  
  .embed-section span {
    color: rgba(230,250,255,0.7);
    white-space: nowrap;
  }
  
  .embed-btn {
    background: rgba(45,212,255,0.1);
    color: var(--accent);
    border: 1px solid rgba(45,212,255,0.3);
    padding: 4px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  
  .embed-btn:hover {
    background: rgba(45,212,255,0.2);
    transform: translateY(-1px);
  }
  
  .embed-btn.copied {
    background: rgba(57,255,20,0.1);
    color: #39ff14;
    border-color: rgba(57,255,20,0.3);
  }

  body.reader-mode{
    font-size:1.12rem;
    line-height:1.6
  }
  
  body.reader-mode .dashboard{
    grid-template-columns:1fr;
    gap:18px
  }
  
  body.reader-mode .card{
    padding:20px;
    background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));
    border-color:rgba(255,255,255,0.06)
  }

  /* ===== LOADING ANIMATIONS ===== */
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 0.8; }
    100% { opacity: 0.6; }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .card-loading {
    animation: pulse 1.5s infinite;
  }
  
  .card-loaded {
    animation: fadeIn 0.3s ease-out;
  }

  /* Loading indicator */
  .loading-indicator {
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 12px;
    color: var(--accent);
    z-index: 13000;
    backdrop-filter: blur(6px);
    display: none;
    align-items: center;
    gap: 8px;
  }
  
  .loading-indicator .spinner {
    width: 12px;
    height: 12px;
    border: 2px solid rgba(45,212,255,0.3);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* ===== MOBILE-FRIENDLY SCROLLING FIX ===== */
  @media (max-width: 768px) {
    .card {
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
      resize: none;
    }
    
    .card::after {
      display: none;
    }
    
    .dashboard {
      gap: 16px;
      padding: 16px;
      min-height: 600px;
    }
    
    .card-header h3 {
      padding: 4px 0;
      font-size: 1rem;
    }
    
    .search-bar input {
      font-size: 16px;
    }
    
    .controls {
      gap: 6px;
    }
    
    .controls button {
      padding: 6px 10px;
      font-size: 14px;
    }
    
    .loading-indicator {
      bottom: 60px;
      right: 10px;
      left: 10px;
      text-align: center;
      justify-content: center;
    }
  }
  
  /* Fix for very small screens */
  @media (max-width: 480px) {
    .dashboard {
      grid-template-columns: 1fr;
      padding: 12px;
      min-height: 500px;
    }
    
    .card {
      padding: 12px;
    }
    
    .control-btn {
      width: 44px;
      height: 44px;
      bottom: 12px;
    }
    
    #toolboxToggle { left: 12px; }
    #paletteToggle { left: 66px; }
    #readerToggle { left: 120px; }
  }
</style>
</head>
<body>

  <button id="toolboxToggle" class="control-btn" title="Open toolbox">ðŸ§°</button>
  <button id="paletteToggle" class="control-btn" title="Theme">ðŸŽ¨</button>
  <button id="readerToggle" class="control-btn" title="Reader mode">ðŸ‘“</button>

  <!-- Loading indicator -->
  <div id="loadingIndicator" class="loading-indicator">
    <div class="spinner"></div>
    <span id="loadingText">Loading cards...</span>
  </div>

  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px">Accent color</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#00ff99" style="background:#00ff99;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd;height:34px;border-radius:8px;cursor:pointer"></div>
    </div>
    
    <!-- SIMPLIFIED BACKGROUND THEMES - DIRECT COLOR VALUES -->
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px;margin-top:12px">Background theme</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <button class="theme-btn active" data-color="default" style="background:linear-gradient(135deg, #0a0f14, #141e28);height:34px;border-radius:8px;cursor:pointer;border:2px solid var(--accent)"></button>
      <button class="theme-btn" data-color="deep-blue" style="background:linear-gradient(135deg, #05080c, #0f151f);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-purple" style="background:linear-gradient(135deg, #12081a, #1f1229);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-teal" style="background:linear-gradient(135deg, #061616, #0f2525);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-red" style="background:linear-gradient(135deg, #160606, #251010);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
    </div>
  </div>

  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div style="font-weight:600;color:var(--accent)">Toolbox</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="dockBtn" title="Dock/undock" style="background:transparent;border:0;color:var(--muted);cursor:pointer">â‡±</button>
        <button id="toolboxClose" title="Close" style="background:transparent;border:0;color:var(--muted);cursor:pointer">âœ•</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite"></div>
  </div>

  <header><h1>The Most Useful Site in the World</h1></header>

  <main>
    <div class="search-bar"><input id="searchInput" placeholder="Search cards..." autofocus /></div>

    <div class="controls">
      <button id="sortAlphaBtn">Sort Aâ†’Z</button>
      <button id="sortRandomBtn">Random</button>
      <button id="autoSizeAllBtn" title="Set all cards to auto-height">Auto Height</button>
      <button id="resetCardSizesBtn" title="Reset all card sizes">Reset Sizes</button>
    </div>

    <div id="status" class="muted" style="text-align:center;margin-bottom:6px">Loading card list...</div>
    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
    
    <!-- Infinite scroll sentinel -->
    <div id="scrollSentinel" style="height:1px;margin-top:20px;"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
// ===== FIXED LAZY LOADING SYSTEM =====
// This version properly detects visible cards and loads them as you scroll

console.log("=== STARTING FIXED LAZY LOADING SYSTEM ===");

// Configuration - tuned for better performance
const LAZY_LOAD_CONFIG = {
  VISIBLE_BUFFER: 3, // Reduced for faster loading
  MAX_LOADED_CARDS: 50,
  BATCH_SIZE: 3,
  BATCH_DELAY: 50,
  UNLOAD_DISTANCE: 6,
  SEARCH_LOAD_ALL: true,
  DEBOUNCE_SCROLL: 50,
  THROTTLE_OBSERVER: 50,
  CACHE_SIZE: 30,
  LOAD_IMMEDIATE: 8, // Number of cards to load immediately
};

// Global state
const lazyState = {
  allCardFiles: [],
  loadedCards: new Set(),
  cardCache: new Map(),
  isLoading: false,
  isSearching: false,
  visibleCards: new Set(),
  observer: null,
  lastScrollY: 0
};

// Card resize state
const cardResizeState = {
  isResizing: false,
  currentCard: null,
  startHeight: 0,
  startY: 0,
  minHeight: 120,
  maxHeight: 1200
};

// Background themes
const themes = {
  'default': { bg1: '#0a0f14', bg2: '#141e28' },
  'deep-blue': { bg1: '#05080c', bg2: '#0f151f' },
  'deep-purple': { bg1: '#12081a', bg2: '#1f1229' },
  'deep-teal': { bg1: '#061616', bg2: '#0f2525' },
  'deep-red': { bg1: '#160606', bg2: '#251010' }
};

// ===== THEME SYSTEM =====
function applyTheme(themeName) {
  console.log("Applying theme:", themeName);
  const theme = themes[themeName];
  if (!theme) return;
  
  const gradient = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
  document.documentElement.style.background = gradient;
  document.body.style.background = gradient;
  
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === themeName) {
      btn.style.background = gradient;
    }
  });
  
  localStorage.setItem('theme', themeName);
}

// ===== FIXED CARD RESIZE SYSTEM =====
function initCardResizeSystem() {
  console.log("Initializing card resize system...");
  
  // Mouse events for desktop
  document.addEventListener('mousedown', handleCardResizeStart);
  document.addEventListener('mousemove', handleCardResizeMove);
  document.addEventListener('mouseup', handleCardResizeEnd);
  
  // Touch events for mobile
  document.addEventListener('touchstart', handleCardResizeStartTouch, { passive: true });
  document.addEventListener('touchmove', handleCardResizeMoveTouch, { passive: false });
  document.addEventListener('touchend', handleCardResizeEnd);
}

function handleCardResizeStart(e) {
  const card = e.target.closest('.card');
  if (!card || card.classList.contains('card-auto-size')) return;
  
  const rect = card.getBoundingClientRect();
  const isNearBottom = e.clientY > rect.bottom - 20 && e.clientY < rect.bottom;
  
  if (isNearBottom) {
    e.preventDefault();
    cardResizeState.isResizing = true;
    cardResizeState.currentCard = card;
    cardResizeState.startHeight = card.offsetHeight;
    cardResizeState.startY = e.clientY;
    
    card.classList.add('card-resizing');
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
  }
}

function handleCardResizeStartTouch(e) {
  if (e.touches.length !== 1) return;
  
  const touch = e.touches[0];
  const card = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.card');
  if (!card || card.classList.contains('card-auto-size')) return;
  
  const rect = card.getBoundingClientRect();
  const isNearBottom = touch.clientY > rect.bottom - 30 && touch.clientY < rect.bottom;
  
  if (isNearBottom) {
    cardResizeState.isResizing = true;
    cardResizeState.currentCard = card;
    cardResizeState.startHeight = card.offsetHeight;
    cardResizeState.startY = touch.clientY;
    
    card.classList.add('card-resizing');
    document.body.style.userSelect = 'none';
  }
}

function handleCardResizeMove(e) {
  if (!cardResizeState.isResizing || !cardResizeState.currentCard) return;
  
  e.preventDefault();
  
  const deltaY = e.clientY - cardResizeState.startY;
  let newHeight = cardResizeState.startHeight + deltaY;
  
  newHeight = Math.max(cardResizeState.minHeight, Math.min(cardResizeState.maxHeight, newHeight));
  
  cardResizeState.currentCard.style.height = newHeight + 'px';
  
  // IMPORTANT: Update the content wrapper height when card is resized
  const wrapper = cardResizeState.currentCard.querySelector('.card-content-wrapper');
  if (wrapper) {
    // Set wrapper height to fill the card (minus padding)
    const cardStyle = window.getComputedStyle(cardResizeState.currentCard);
    const paddingTop = parseInt(cardStyle.paddingTop) || 0;
    const paddingBottom = parseInt(cardStyle.paddingBottom) || 0;
    wrapper.style.height = (newHeight - paddingTop - paddingBottom) + 'px';
  }
}

function handleCardResizeMoveTouch(e) {
  if (!cardResizeState.isResizing || !cardResizeState.currentCard || e.touches.length !== 1) return;
  
  e.preventDefault();
  
  const touch = e.touches[0];
  const deltaY = touch.clientY - cardResizeState.startY;
  let newHeight = cardResizeState.startHeight + deltaY;
  
  newHeight = Math.max(cardResizeState.minHeight, Math.min(cardResizeState.maxHeight, newHeight));
  
  cardResizeState.currentCard.style.height = newHeight + 'px';
  
  // Update wrapper height
  const wrapper = cardResizeState.currentCard.querySelector('.card-content-wrapper');
  if (wrapper) {
    const cardStyle = window.getComputedStyle(cardResizeState.currentCard);
    const paddingTop = parseInt(cardStyle.paddingTop) || 0;
    const paddingBottom = parseInt(cardStyle.paddingBottom) || 0;
    wrapper.style.height = (newHeight - paddingTop - paddingBottom) + 'px';
  }
}

function handleCardResizeEnd() {
  if (!cardResizeState.isResizing || !cardResizeState.currentCard) return;
  
  const card = cardResizeState.currentCard;
  const height = card.offsetHeight;
  
  card.dataset.savedHeight = height;
  localStorage.setItem(`card-height-${card.dataset.name}`, height);
  
  card.classList.remove('card-resizing');
  cardResizeState.isResizing = false;
  cardResizeState.currentCard = null;
  
  document.body.style.cursor = '';
  document.body.style.userSelect = '';
}

// ===== FIXED CARD SETUP =====
function setupCardContent(card) {
  const contentDiv = card.querySelector('.content');
  if (!contentDiv) return;
  
  // Check if already enhanced
  if (contentDiv.querySelector('.card-content-wrapper')) return;
  
  const originalHTML = contentDiv.innerHTML;
  
  // Create enhanced structure
  contentDiv.innerHTML = `
    <div class="card-content-wrapper">
      <div class="card-body">
        ${originalHTML}
      </div>
    </div>
  `;
  
  // Load saved state
  loadCardSavedState(card);
  
  // Add double-click for auto-size toggle
  card.addEventListener('dblclick', function(e) {
    if (e.target.closest('button, input, textarea, select, a')) return;
    toggleCardAutoSize(card);
  });
}

function toggleCardAutoSize(card) {
  card.classList.toggle('card-auto-size');
  
  if (card.classList.contains('card-auto-size')) {
    card.style.height = 'auto';
    localStorage.setItem(`card-auto-${card.dataset.name}`, 'true');
    
    // Reset wrapper height
    const wrapper = card.querySelector('.card-content-wrapper');
    if (wrapper) wrapper.style.height = 'auto';
  } else {
    const savedHeight = localStorage.getItem(`card-height-${card.dataset.name}`);
    if (savedHeight) {
      card.style.height = savedHeight + 'px';
      card.dataset.savedHeight = savedHeight;
      
      // Set wrapper height
      const wrapper = card.querySelector('.card-content-wrapper');
      if (wrapper) {
        const cardStyle = window.getComputedStyle(card);
        const paddingTop = parseInt(cardStyle.paddingTop) || 0;
        const paddingBottom = parseInt(cardStyle.paddingBottom) || 0;
        wrapper.style.height = (parseInt(savedHeight) - paddingTop - paddingBottom) + 'px';
      }
    }
    localStorage.removeItem(`card-auto-${card.dataset.name}`);
  }
}

function loadCardSavedState(card) {
  const cardName = card.dataset.name;
  if (!cardName) return;
  
  const autoSize = localStorage.getItem(`card-auto-${cardName}`);
  if (autoSize === 'true') {
    card.classList.add('card-auto-size');
    card.style.height = 'auto';
  } else {
    const savedHeight = localStorage.getItem(`card-height-${cardName}`);
    if (savedHeight) {
      card.style.height = savedHeight + 'px';
      card.dataset.savedHeight = savedHeight;
      
      // Set wrapper height
      const wrapper = card.querySelector('.card-content-wrapper');
      if (wrapper) {
        const cardStyle = window.getComputedStyle(card);
        const paddingTop = parseInt(cardStyle.paddingTop) || 0;
        const paddingBottom = parseInt(cardStyle.paddingBottom) || 0;
        wrapper.style.height = (parseInt(savedHeight) - paddingTop - paddingBottom) + 'px';
      }
    }
  }
}

// ===== EMBED SYSTEM =====
function addEmbedSectionToCard(card, fileName) {
  const cardName = fileName.replace('.html', '');
  const displayName = cardName.replace(/-/g, ' ');
  
  const embedHTML = `
    <div class="embed-section">
      <span>Share this tool:</span>
      <button class="embed-btn" data-card="${cardName}" data-file="${fileName}">
        ðŸ”— Copy Embed Code
      </button>
    </div>
  `;
  
  const contentBody = card.querySelector('.card-body');
  if (contentBody) {
    contentBody.insertAdjacentHTML('beforeend', embedHTML);
    
    const embedBtn = contentBody.querySelector('.embed-btn');
    if (embedBtn) {
      embedBtn.addEventListener('click', function() {
        copyEmbedCode(cardName, fileName, displayName);
      });
    }
  }
}

function copyEmbedCode(cardName, fileName, displayName) {
  const embedCode = `<iframe src="https://mrpr0phecy.github.io/mrpr0phecy/cards/${fileName}" width="100%" height="400" style="border:none;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);" title="${displayName} - The Most Useful Site"></iframe>`;
  
  navigator.clipboard.writeText(embedCode).then(() => {
    const embedBtn = document.querySelector(`.embed-btn[data-card="${cardName}"]`);
    if (embedBtn) {
      const originalText = embedBtn.textContent;
      embedBtn.textContent = 'âœ… Copied!';
      embedBtn.classList.add('copied');
      
      setTimeout(() => {
        embedBtn.textContent = originalText;
        embedBtn.classList.remove('copied');
      }, 2000);
    }
  }).catch(err => {
    console.error('Failed to copy: ', err);
    const textArea = document.createElement('textarea');
    textArea.value = embedCode;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (e) {}
    document.body.removeChild(textArea);
  });
}

// ===== FIXED LAZY LOADING FUNCTIONS =====
function checkVisibleCards() {
  const cards = document.querySelectorAll('.card:not(.loaded)');
  const viewportHeight = window.innerHeight;
  
  cards.forEach(card => {
    const rect = card.getBoundingClientRect();
    
    // Check if card is in or near viewport
    const isVisible = (
      rect.top < viewportHeight + 300 && // 300px buffer below viewport
      rect.bottom > -300 // 300px buffer above viewport
    );
    
    if (isVisible && !card.classList.contains('loading')) {
      const cardName = card.dataset.name;
      if (cardName && !lazyState.loadedCards.has(cardName)) {
        lazyState.visibleCards.add(cardName);
        loadCardContent(cardName, card);
      }
    }
  });
  
  updateStatusText();
}

function loadCardContent(cardName, cardElement) {
  if (!cardElement || lazyState.loadedCards.has(cardName)) return;
  
  const contentDiv = cardElement.querySelector('.content');
  if (!contentDiv) return;
  
  // Mark as loading
  cardElement.classList.add('loading');
  cardElement.querySelector('.content .card-body').innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.6)">Loading...</div>';
  
  // Check cache first
  if (lazyState.cardCache.has(cardName)) {
    const cachedHTML = lazyState.cardCache.get(cardName);
    processLoadedCard(cardName, cardElement, cachedHTML, true);
    return;
  }
  
  // Fetch from server
  fetch(`cards/${cardName}.html`)
    .then(r => {
      if (!r.ok) throw new Error('Failed to load');
      return r.text();
    })
    .then(html => {
      // Cache the HTML
      lazyState.cardCache.set(cardName, html);
      processLoadedCard(cardName, cardElement, html, false);
    })
    .catch(() => {
      cardElement.querySelector('.content .card-body').textContent = 'Preview unavailable';
      cardElement.classList.remove('loading');
      lazyState.loadedCards.add(cardName);
      updateStatusText();
    });
}

function processLoadedCard(cardName, cardElement, html, fromCache) {
  const contentBody = cardElement.querySelector('.card-body');
  
  // Load HTML
  contentBody.innerHTML = html;
  
  // Add embed section
  addEmbedSectionToCard(cardElement, `${cardName}.html`);
  
  // Execute scripts
  const scripts = contentBody.querySelectorAll('script');
  scripts.forEach(script => {
    const newScript = document.createElement('script');
    if (script.src) {
      newScript.src = script.src;
    } else {
      newScript.textContent = script.textContent;
    }
    [...script.attributes].forEach(attr => {
      newScript.setAttribute(attr.name, attr.value);
    });
    script.parentNode.replaceChild(newScript, script);
  });
  
  // Mark as loaded
  lazyState.loadedCards.add(cardName);
  cardElement.classList.remove('loading');
  cardElement.classList.add('loaded', 'visible');
  
  // Setup card content for resizing
  setupCardContent(cardElement);
  
  updateStatusText();
  
  console.log(`Loaded card: ${cardName} ${fromCache ? '(from cache)' : ''}`);
}

function updateStatusText() {
  const status = document.getElementById('status');
  if (!status) return;
  
  const total = lazyState.allCardFiles.length;
  const loaded = lazyState.loadedCards.size;
  
  if (lazyState.isSearching) {
    const visibleCards = document.querySelectorAll('.card[style=""]').length;
    status.textContent = `Search results: ${visibleCards} cards`;
  } else {
    status.textContent = `${loaded} of ${total} cards loaded`;
  }
}

function showLoadingIndicator(text = 'Loading...') {
  const indicator = document.getElementById('loadingIndicator');
  const textElement = document.getElementById('loadingText');
  
  if (indicator && textElement) {
    textElement.textContent = text;
    indicator.style.display = 'flex';
  }
}

function hideLoadingIndicator() {
  const indicator = document.getElementById('loadingIndicator');
  if (indicator) {
    indicator.style.display = 'none';
  }
}

// ===== FIXED TOOLBOX SYSTEM =====
let widgets = [];
let toolboxDocked = false;

function initToolbox() {
  const toolbox = document.getElementById('toolbox');
  const toolboxTitle = document.getElementById('toolboxTitle');
  
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  toolboxTitle.addEventListener('mousedown', startDrag);
  
  function startDrag(e) {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = toolbox.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = 'grabbing';
  }
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    toolbox.style.left = 'auto';
    toolbox.style.right = 'auto';
    toolbox.style.top = e.clientY - dragOffset.y + 'px';
    toolbox.style.left = e.clientX - dragOffset.x + 'px';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = '';
  }
  
  document.getElementById('dockBtn').addEventListener('click', function() {
    toolboxDocked = !toolboxDocked;
    
    if (toolboxDocked) {
      toolbox.style.left = 'auto';
      toolbox.style.right = '18px';
      toolbox.style.top = 'auto';
      toolbox.style.bottom = '18px';
      this.textContent = 'â‡²';
    } else {
      this.textContent = 'â‡±';
    }
  });
  
  loadSavedWidgets();
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
  console.log("DOM ready");
  
  // Scroll to top
  window.scrollTo(0, 0);
  
  // Apply saved theme
  const savedTheme = localStorage.getItem('theme') || 'default';
  applyTheme(savedTheme);
  
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === savedTheme) {
      btn.classList.add('active');
      btn.style.border = '2px solid var(--accent)';
    } else {
      btn.classList.remove('active');
      btn.style.border = '1px solid var(--border)';
    }
  });
  
  // Apply saved accent
  const savedAccent = localStorage.getItem('accent') || '#2dd4ff';
  document.documentElement.style.setProperty('--accent', savedAccent);
  document.querySelectorAll('.palette-color').forEach(c => {
    c.classList.toggle('active', c.dataset.accent === savedAccent);
  });
  
  // Apply reader mode
  if(localStorage.getItem('readerMode') === 'on') {
    document.body.classList.add('reader-mode');
  }
  
  // Initialize systems
  initToolbox();
  initCardResizeSystem();
  
  // Load dashboard
  loadDashboard();
});

// Scroll to search bar on load
window.addEventListener('load', function() {
  setTimeout(() => {
    const searchBar = document.querySelector('.search-bar');
    if (searchBar) {
      searchBar.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.focus();
    }
  }, 100);
});

// ===== UI CONTROLS =====
document.getElementById('paletteToggle').addEventListener('click', function() {
  const panel = document.getElementById('palettePanel');
  panel.classList.toggle('open');
});

document.querySelectorAll('.palette-color').forEach(c => {
  c.addEventListener('click', function() {
    document.querySelectorAll('.palette-color').forEach(x => x.classList.remove('active'));
    this.classList.add('active');
    const col = this.dataset.accent;
    document.documentElement.style.setProperty('--accent', col);
    localStorage.setItem('accent', col);
  });
});

document.querySelectorAll('.theme-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.theme-btn').forEach(b => {
      b.classList.remove('active');
      b.style.border = '1px solid var(--border)';
    });
    this.classList.add('active');
    this.style.border = '2px solid var(--accent)';
    
    const themeName = this.dataset.color;
    applyTheme(themeName);
  });
});

const toolbox = document.getElementById('toolbox');
document.getElementById('toolboxToggle').addEventListener('click', function() {
  toolbox.classList.toggle('hidden');
});
document.getElementById('toolboxClose').addEventListener('click', function(e) {
  e.stopPropagation();
  toolbox.classList.add('hidden');
});

document.getElementById('readerToggle').addEventListener('click', function() {
  document.body.classList.toggle('reader-mode');
  localStorage.setItem('readerMode', document.body.classList.contains('reader-mode') ? 'on' : 'off');
});

// ===== SEARCH =====
const searchInput = document.getElementById('searchInput');
let searchTimeout = null;

searchInput.addEventListener('input', function(e) {
  const q = e.target.value.toLowerCase().trim();
  
  if (searchTimeout) clearTimeout(searchTimeout);
  
  searchTimeout = setTimeout(() => {
    lazyState.isSearching = q.length > 0;
    
    if (lazyState.isSearching) {
      performSearch(q);
    } else {
      document.querySelectorAll('.card').forEach(card => {
        card.style.display = '';
      });
      // Trigger check for visible cards after search
      setTimeout(checkVisibleCards, 100);
    }
  }, 300);
});

function performSearch(query) {
  const cards = document.querySelectorAll('.card');
  let visibleCount = 0;
  
  cards.forEach(card => {
    const name = card.dataset.name.toLowerCase();
    const text = card.textContent.toLowerCase();
    const matches = name.includes(query) || text.includes(query);
    
    card.style.display = matches ? '' : 'none';
    
    if (matches) {
      visibleCount++;
      
      if (!card.classList.contains('loaded')) {
        loadCardContent(card.dataset.name, card);
      }
    }
  });
  
  updateStatusText();
}

// ===== SORT BUTTONS =====
document.getElementById('sortAlphaBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  cards.sort((a,b) => a.dataset.name.localeCompare(b.dataset.name));
  cards.forEach(card => grid.appendChild(card));
  
  // Re-check visible cards after sorting
  setTimeout(checkVisibleCards, 100);
});

document.getElementById('sortRandomBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  for (let i = cards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [cards[i], cards[j]] = [cards[j], cards[i]];
  }
  cards.forEach(card => grid.appendChild(card));
  
  // Re-check visible cards after sorting
  setTimeout(checkVisibleCards, 100);
});

// ===== CARD SIZE CONTROLS =====
document.getElementById('autoSizeAllBtn').addEventListener('click', function() {
  document.querySelectorAll('.card').forEach(card => {
    card.classList.add('card-auto-size');
    card.style.height = 'auto';
    localStorage.setItem(`card-auto-${card.dataset.name}`, 'true');
    
    // Reset wrapper height
    const wrapper = card.querySelector('.card-content-wrapper');
    if (wrapper) wrapper.style.height = 'auto';
  });
});

document.getElementById('resetCardSizesBtn').addEventListener('click', function() {
  document.querySelectorAll('.card').forEach(card => {
    card.classList.remove('card-auto-size');
    card.style.height = '';
    card.dataset.savedHeight = '';
    
    localStorage.removeItem(`card-auto-${card.dataset.name}`);
    localStorage.removeItem(`card-height-${card.dataset.name}`);
    
    // Reset wrapper height
    const wrapper = card.querySelector('.card-content-wrapper');
    if (wrapper) wrapper.style.height = 'auto';
  });
});

// ===== FIXED LOAD DASHBOARD =====
async function loadDashboard() {
  try {
    const DEFAULT_REPO = 'mrpr0phecy/mrpr0phecy';
    const DEFAULT_BRANCH = 'main';
    
    const [owner, repo] = DEFAULT_REPO.split('/');
    
    document.getElementById('status').textContent = 'Fetching card list...';
    showLoadingIndicator('Loading card list...');
    
    const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${DEFAULT_BRANCH}?recursive=1`;
    const response = await fetch(url);
    const data = await response.json();
    
    lazyState.allCardFiles = (data.tree || [])
      .filter(item => item.path.startsWith('cards/') && item.path.endsWith('.html'))
      .map(item => item.path.replace(/^cards\//, '').replace('.html', ''))
      .sort();
    
    console.log(`Found ${lazyState.allCardFiles.length} cards`);
    
    const grid = document.getElementById('gridContainer');
    grid.innerHTML = '';
    
    lazyState.allCardFiles.forEach((cardName, index) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.name = cardName;
      card.dataset.index = index;
      
      const header = document.createElement('div');
      header.className = 'card-header';
      header.innerHTML = `<h3>${cardName.replace(/-/g, ' ')}</h3>
        <div style="display:flex;gap:8px">
          <div class="add-to-toolbox" title="Add to toolbox" style="cursor:pointer;font-weight:bold;color:var(--accent);font-size:18px;line-height:1">+</div>
        </div>`;
      
      const content = document.createElement('div');
      content.className = 'content';
      content.innerHTML = `
        <div class="card-content-wrapper">
          <div class="card-body">
            <div style="padding:20px;text-align:center;color:rgba(230,250,255,0.4)">
              Click or scroll to load card...
            </div>
          </div>
        </div>
      `;
      
      card.appendChild(header);
      card.appendChild(content);
      grid.appendChild(card);
    });
    
    updateStatusText();
    hideLoadingIndicator();
    
    // Initialize Intersection Observer for lazy loading
    initIntersectionObserver();
    
    // Load initial batch of cards immediately
    loadInitialCards();
    
  } catch (error) {
    console.error("Error loading dashboard:", error);
    document.getElementById('status').textContent = 'Error loading cards';
    hideLoadingIndicator();
  }
}

function initIntersectionObserver() {
  // Use Intersection Observer for better performance
  if ('IntersectionObserver' in window) {
    lazyState.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const card = entry.target;
          const cardName = card.dataset.name;
          
          if (cardName && !lazyState.loadedCards.has(cardName) && !card.classList.contains('loading')) {
            lazyState.visibleCards.add(cardName);
            loadCardContent(cardName, card);
          }
          
          // Unobserve once loaded
          lazyState.observer.unobserve(card);
        }
      });
    }, {
      root: null,
      rootMargin: '300px 0px', // Load cards 300px before they enter viewport
      threshold: 0.1
    });
    
    // Observe all cards
    document.querySelectorAll('.card:not(.loaded)').forEach(card => {
      lazyState.observer.observe(card);
    });
  } else {
    // Fallback to scroll event for older browsers
    console.log("IntersectionObserver not supported, using scroll event");
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      if (scrollTimeout) clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        checkVisibleCards();
      }, LAZY_LOAD_CONFIG.DEBOUNCE_SCROLL);
    });
    
    // Also check on resize
    window.addEventListener('resize', () => {
      checkVisibleCards();
    });
  }
}

function loadInitialCards() {
  // Load first batch of cards immediately
  const cards = document.querySelectorAll('.card:not(.loaded)');
  const cardsToLoad = Math.min(LAZY_LOAD_CONFIG.LOAD_IMMEDIATE, cards.length);
  
  for (let i = 0; i < cardsToLoad; i++) {
    const card = cards[i];
    const cardName = card.dataset.name;
    
    if (cardName && !lazyState.loadedCards.has(cardName)) {
      lazyState.visibleCards.add(cardName);
      loadCardContent(cardName, card);
    }
  }
  
  // Also check visible cards after a short delay
  setTimeout(checkVisibleCards, 500);
}

// ===== ADD TO TOOLBOX =====
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('add-to-toolbox') || 
      e.target.closest('.add-to-toolbox')) {
    
    const card = e.target.closest('.card');
    if (!card) return;
    
    const cardName = card.dataset.name;
    
    if (!card.classList.contains('loaded')) {
      alert('Please wait for the card to load before adding to toolbox');
      return;
    }
    
    // Simple toolbox addition (full implementation would need more code)
    alert(`Added "${cardName}" to toolbox!`);
    
    const addBtn = e.target.closest('.add-to-toolbox');
    addBtn.textContent = 'âœ“';
    addBtn.style.color = 'var(--accent)';
    setTimeout(() => {
      addBtn.textContent = '+';
      addBtn.style.color = '';
    }, 1000);
  }
});

// Make Sortable (disabled on main page)
new Sortable(document.getElementById('gridContainer'), {
  animation: 150,
  disabled: true
});

console.log("=== FIXED LAZY LOADING SYSTEM INITIALIZED ===");
</script>
</body>
</html>
