<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  /* === GLOBAL RESET AND BASE STYLES === */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  
  html, body {
    height: 100%;
    margin: 0;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    background: linear-gradient(135deg, #0a0f14 0%, #141e28 100%);
    color: #e6faff;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background-attachment: fixed;
    background-size: cover;
    overflow-x: hidden;
  }
  
  /* === CSS VARIABLES FOR THEMING === */
  :root {
    --accent: #2dd4ff;
    --accent-dark: #1aa3cc;
    --accent-glow: rgba(45, 212, 255, 0.3);
    --muted: #e6faff;
    --text: #e6faff;
    --text-secondary: rgba(230, 250, 255, 0.7);
    --glass: rgba(255, 255, 255, 0.06);
    --panel: rgba(20, 20, 20, 0.95);
    --card-grad-1: rgba(255, 255, 255, 0.03);
    --card-grad-2: rgba(255, 255, 255, 0.06);
    --border: rgba(255, 255, 255, 0.12);
    --border-light: rgba(255, 255, 255, 0.08);
    --card-min: 300px;
    --toolbox-width: 500px;
    --toolbox-height: 400px;
    --success: #39ff14;
    --warning: #ffcc00;
    --error: #ff2d55;
    --radius-sm: 8px;
    --radius-md: 12px;
    --radius-lg: 16px;
    --radius-xl: 20px;
    --shadow-sm: 0 4px 12px rgba(0, 0, 0, 0.1);
    --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.2);
    --shadow-lg: 0 16px 40px rgba(0, 0, 0, 0.3);
    --shadow-xl: 0 24px 60px rgba(0, 0, 0, 0.4);
  }

  /* === HEADER === */
  header {
    padding: 32px 24px 24px;
    text-align: center;
    position: relative;
    z-index: 10;
  }
  
  .header-content {
    max-width: 800px;
    margin: 0 auto;
    position: relative;
  }
  
  header h1 {
    margin: 0;
    color: var(--accent);
    font-size: 2.5rem;
    font-weight: 800;
    letter-spacing: -0.5px;
    text-shadow: 0 0 30px var(--accent-glow);
    margin-bottom: 12px;
    background: linear-gradient(135deg, var(--accent) 0%, #00ffaa 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  header p {
    color: var(--text-secondary);
    margin: 0;
    font-size: 1.1rem;
    line-height: 1.5;
    max-width: 600px;
    margin: 0 auto;
  }

  /* === FLOATING CONTROL BUTTONS === */
  .control-btn {
    position: fixed;
    bottom: 24px;
    z-index: 10000;
    width: 60px;
    height: 60px;
    border-radius: var(--radius-lg);
    background: var(--panel);
    border: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    box-shadow: var(--shadow-lg), 0 0 0 1px rgba(45, 212, 255, 0.1);
    color: var(--accent);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    font-size: 22px;
  }
  
  .control-btn:hover {
    transform: translateY(-4px) scale(1.05);
    box-shadow: var(--shadow-xl), 0 0 0 2px rgba(45, 212, 255, 0.2);
    background: rgba(45, 212, 255, 0.1);
  }
  
  #toolboxToggle { left: 24px; }
  #paletteToggle { left: 100px; }
  #readerToggle { left: 176px; }
  
  .control-btn.active {
    background: rgba(45, 212, 255, 0.15);
    box-shadow: 0 0 0 2px var(--accent), var(--shadow-xl);
    transform: translateY(-2px);
  }

  /* === THEME PANEL === */
  .palette-panel {
    position: fixed;
    left: 100px;
    bottom: 100px;
    z-index: 9999;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius-xl);
    padding: 24px;
    box-shadow: var(--shadow-xl);
    backdrop-filter: blur(30px);
    -webkit-backdrop-filter: blur(30px);
    display: none;
    pointer-events: none;
    transform: translateY(10px);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    width: 340px;
  }
  
  .palette-panel.open {
    display: block;
    pointer-events: auto;
    transform: translateY(0);
    opacity: 1;
  }
  
  .palette-section {
    margin-bottom: 24px;
  }
  
  .palette-title {
    color: var(--accent);
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 16px;
    display: flex;
    align-items: center;
    gap: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  /* === TOOLBOX === */
  .toolbox {
    position: fixed;
    right: 24px;
    bottom: 24px;
    width: var(--toolbox-width);
    height: var(--toolbox-height);
    z-index: 9998;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius-xl);
    box-shadow: var(--shadow-xl);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    resize: both;
    min-width: 340px;
    min-height: 260px;
    backdrop-filter: blur(30px);
    -webkit-backdrop-filter: blur(30px);
    transform: translateY(20px);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .toolbox.visible {
    transform: translateY(0);
    opacity: 1;
  }
  
  .toolbox.hidden {
    display: none;
  }

  .toolbox .titlebar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 18px 24px;
    border-bottom: 1px solid var(--border-light);
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), transparent);
    cursor: grab;
    z-index: 100;
    flex-shrink: 0;
  }
  
  .toolbox-title {
    font-weight: 700;
    color: var(--accent);
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .toolbox-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .toolbox-btn {
    width: 36px;
    height: 36px;
    border-radius: var(--radius-md);
    background: transparent;
    border: 1px solid var(--border-light);
    color: var(--muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    font-size: 16px;
  }
  
  .toolbox-btn:hover {
    background: rgba(45, 212, 255, 0.1);
    border-color: rgba(45, 212, 255, 0.3);
    color: var(--accent);
  }

  .toolbox .content {
    flex: 1;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
    overflow: auto;
    position: relative;
    padding: 20px;
  }

  /* === WIDGETS === */
  .widget-wrap {
    position: absolute;
    box-sizing: border-box;
    background: linear-gradient(135deg, var(--card-grad-1), var(--card-grad-2));
    border-radius: var(--radius-lg);
    border: 1px solid var(--border-light);
    min-width: 200px;
    min-height: 160px;
    max-width: calc(100% - 24px);
    max-height: calc(100% - 24px);
    overflow: hidden;
    resize: both;
    z-index: 1;
    box-shadow: var(--shadow-md);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
  }
  
  .widget-titlebar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 18px;
    border-bottom: 1px solid var(--border-light);
    background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
    cursor: move;
    user-select: none;
    font-size: 14px;
    flex-shrink: 0;
  }
  
  .widget-titlebar strong {
    color: var(--accent);
    font-weight: 600;
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 160px;
  }
  
  .widget-body {
    padding: 18px;
    overflow: auto;
    height: calc(100% - 52px);
    font-size: 14px;
    line-height: 1.5;
  }

  .widget-close {
    background: transparent;
    border: 0;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 14px;
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: var(--radius-sm);
    transition: all 0.2s;
  }
  
  .widget-close:hover {
    background: rgba(255, 77, 77, 0.1);
    color: var(--error);
  }

  /* === MAIN CONTENT === */
  main {
    position: relative;
    z-index: 2;
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 24px;
  }
  
  /* SEARCH BAR */
  .search-container {
    max-width: 800px;
    margin: 32px auto 28px;
    position: relative;
  }
  
  .search-bar {
    display: flex;
    background: linear-gradient(180deg, var(--glass), rgba(255, 255, 255, 0.02));
    border-radius: var(--radius-xl);
    padding: 8px 8px 8px 24px;
    border: 1px solid var(--border-light);
    box-shadow: var(--shadow-md);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .search-bar:focus-within {
    border-color: var(--accent);
    box-shadow: var(--shadow-lg), 0 0 0 1px rgba(45, 212, 255, 0.2);
    transform: translateY(-2px);
  }
  
  .search-bar input {
    flex: 1;
    border: none;
    background: transparent;
    color: var(--text);
    font-size: 16px;
    outline: none;
    padding: 14px 0;
    font-weight: 500;
    font-family: inherit;
  }
  
  .search-bar input::placeholder {
    color: var(--text-secondary);
    opacity: 0.6;
  }
  
  .search-btn {
    background: linear-gradient(135deg, rgba(45, 212, 255, 0.2), rgba(45, 212, 255, 0.1));
    border: 1px solid rgba(45, 212, 255, 0.3);
    color: var(--accent);
    border-radius: var(--radius-lg);
    padding: 14px 28px;
    cursor: pointer;
    font-weight: 600;
    font-size: 15px;
    transition: all 0.2s;
    white-space: nowrap;
    margin-left: 12px;
    font-family: inherit;
  }
  
  .search-btn:hover {
    background: linear-gradient(135deg, rgba(45, 212, 255, 0.3), rgba(45, 212, 255, 0.2));
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(45, 212, 255, 0.15);
  }

  /* CONTROLS */
  .controls {
    display: flex;
    gap: 16px;
    justify-content: center;
    margin-bottom: 32px;
    flex-wrap: wrap;
  }
  
  .control-group {
    display: flex;
    gap: 10px;
    background: var(--glass);
    border: 1px solid var(--border-light);
    border-radius: var(--radius-lg);
    padding: 10px;
    backdrop-filter: blur(10px);
  }
  
  .controls button {
    padding: 12px 20px;
    border-radius: var(--radius-md);
    border: 1px solid var(--border-light);
    background: transparent;
    color: var(--muted);
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    font-size: 14px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: inherit;
  }
  
  .controls button:hover {
    background: rgba(45, 212, 255, 0.1);
    border-color: rgba(45, 212, 255, 0.3);
    color: var(--accent);
    transform: translateY(-2px);
  }
  
  .controls button:active {
    transform: translateY(0);
  }
  
  .controls button.active {
    background: rgba(45, 212, 255, 0.15);
    border-color: var(--accent);
    color: var(--accent);
  }

  /* STATUS */
  .status-bar {
    text-align: center;
    padding: 16px;
    color: var(--text-secondary);
    font-size: 15px;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
  }
  
  .tool-count {
    background: var(--glass);
    padding: 6px 16px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 600;
    color: var(--accent);
    border: 1px solid var(--border-light);
    backdrop-filter: blur(10px);
  }

  /* === CARD SYSTEM === */
  .dashboard {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--card-min), 1fr));
    gap: 28px;
    padding: 24px 0 80px;
    align-items: stretch;
    box-sizing: border-box;
  }

  .card {
    box-sizing: border-box;
    background: linear-gradient(135deg, var(--card-grad-1), var(--card-grad-2));
    border: 1px solid var(--border-light);
    border-radius: var(--radius-lg);
    padding: 24px;
    min-height: 200px;
    width: 100%;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), 
                transform 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                border-color 0.3s ease,
                box-shadow 0.3s ease;
    box-shadow: var(--shadow-md);
    position: relative;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  .card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--accent), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  
  .card:hover {
    border-color: var(--border);
    box-shadow: var(--shadow-lg);
    transform: translateY(-4px);
  }
  
  .card:hover::before {
    opacity: 0.5;
  }
  
  .card.loading {
    animation: pulse 2s infinite;
  }
  
  .card.visible {
    opacity: 1;
    transform: translateY(0);
  }
  
  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 20px;
    flex-shrink: 0;
  }
  
  .card-header h3 {
    margin: 0;
    color: var(--accent);
    font-size: 1.2rem;
    font-weight: 700;
    line-height: 1.3;
    flex: 1;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
    hyphens: auto;
  }
  
  .card-actions {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-shrink: 0;
  }
  
  .card-action-btn {
    width: 36px;
    height: 36px;
    border-radius: var(--radius-md);
    background: transparent;
    border: 1px solid var(--border-light);
    color: var(--text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    transition: all 0.2s;
    flex-shrink: 0;
    position: relative;
  }
  
  .card-action-btn:hover {
    background: rgba(45, 212, 255, 0.1);
    border-color: var(--accent);
    color: var(--accent);
    transform: scale(1.1);
  }
  
  .card-action-btn::after {
    content: attr(title);
    position: absolute;
    bottom: -30px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--panel);
    color: var(--text);
    padding: 6px 12px;
    border-radius: var(--radius-sm);
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s;
    border: 1px solid var(--border);
    z-index: 100;
  }
  
  .card-action-btn:hover::after {
    opacity: 1;
    visibility: visible;
    transform: translateX(-50%) translateY(-5px);
  }
  
  .card-content {
    flex: 1;
    position: relative;
    min-height: 0;
  }
  
  .card-body {
    width: 100%;
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    padding-right: 8px;
    max-width: 100% !important;
    overflow-wrap: break-word !important;
    word-wrap: break-word !important;
    word-break: break-word !important;
    hyphens: auto !important;
    color: inherit !important;
    font-family: inherit !important;
  }
  
  /* Card body specific styles */
  .card-body * {
    max-width: 100% !important;
    box-sizing: border-box !important;
    overflow-wrap: break-word !important;
    word-break: break-word !important;
  }
  
  .card-body img,
  .card-body video,
  .card-body iframe,
  .card-body canvas {
    max-width: 100% !important;
    height: auto !important;
    display: block;
    border-radius: var(--radius-md);
  }
  
  .card-body iframe {
    min-height: 320px;
    border: none !important;
    width: 100% !important;
  }
  
  .card-body table {
    width: 100% !important;
    max-width: 100% !important;
    overflow-x: auto !important;
    display: block !important;
    border-collapse: collapse;
  }
  
  .card-body pre,
  .card-body code {
    white-space: pre-wrap !important;
    word-break: break-word !important;
    max-width: 100% !important;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace !important;
    background: rgba(0, 0, 0, 0.3) !important;
    padding: 14px !important;
    border-radius: var(--radius-md) !important;
    border: 1px solid var(--border-light) !important;
    overflow-x: auto !important;
  }
  
  .card-body input,
  .card-body textarea,
  .card-body select,
  .card-body button {
    max-width: 100% !important;
    background: rgba(255, 255, 255, 0.05) !important;
    border: 1px solid var(--border-light) !important;
    color: var(--text) !important;
    font-family: inherit !important;
  }
  
  .card-body a {
    word-break: break-all !important;
    color: var(--accent) !important;
    text-decoration: none;
    transition: all 0.2s;
  }
  
  .card-body a:hover {
    text-decoration: underline;
    opacity: 0.8;
  }
  
  /* Card body scrollbar */
  .card-body::-webkit-scrollbar {
    width: 6px;
  }
  
  .card-body::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
  }
  
  .card-body::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 3px;
    opacity: 0.5;
  }
  
  .card-body::-webkit-scrollbar-thumb:hover {
    opacity: 0.8;
  }

  /* === EMBED SECTION === */
  .embed-section {
    margin-top: 24px;
    padding-top: 20px;
    border-top: 1px solid var(--border-light);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }
  
  .embed-label {
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 500;
  }
  
  .embed-btn {
    background: rgba(45, 212, 255, 0.1);
    color: var(--accent);
    border: 1px solid rgba(45, 212, 255, 0.3);
    padding: 10px 20px;
    border-radius: var(--radius-md);
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .embed-btn:hover {
    background: rgba(45, 212, 255, 0.2);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(45, 212, 255, 0.15);
  }
  
  .embed-btn.copied {
    background: rgba(57, 255, 20, 0.1);
    color: var(--success);
    border-color: rgba(57, 255, 20, 0.3);
  }

  /* === LOADING INDICATOR === */
  .loading-indicator {
    position: fixed;
    bottom: 100px;
    right: 24px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    padding: 16px 24px;
    font-size: 14px;
    color: var(--accent);
    z-index: 9997;
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    display: flex;
    align-items: center;
    gap: 16px;
    box-shadow: var(--shadow-lg);
    transform: translateY(10px);
    opacity: 0;
    transition: all 0.3s ease;
  }
  
  .loading-indicator.visible {
    transform: translateY(0);
    opacity: 1;
  }
  
  .spinner {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(45, 212, 255, 0.2);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  .progress-bar {
    width: 160px;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    overflow: hidden;
  }
  
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--success));
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 3px;
  }

  /* === ANIMATIONS === */
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  @keyframes shimmer {
    0% { background-position: -200% center; }
    100% { background-position: 200% center; }
  }

  /* === READER MODE === */
  body.reader-mode {
    font-size: 1.15rem;
    line-height: 1.7;
  }
  
  body.reader-mode .dashboard {
    grid-template-columns: 1fr;
    max-width: 800px;
    margin: 0 auto;
    gap: 36px;
  }
  
  body.reader-mode .card {
    padding: 32px;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.06));
    border-color: var(--border);
  }

  /* === SCROLLBAR STYLING === */
  ::-webkit-scrollbar {
    width: 10px;
    height: 10px;
  }
  
  ::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
  }
  
  ::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 5px;
    opacity: 0.5;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    opacity: 0.8;
  }

  /* === PALETTE COLORS === */
  .palette-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 12px;
  }
  
  .palette-color {
    height: 44px;
    border-radius: var(--radius-md);
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }
  
  .palette-color:hover {
    transform: scale(1.05);
    box-shadow: 0 0 0 2px var(--accent);
  }
  
  .palette-color.active::after {
    content: '‚úì';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 16px;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
  }
  
  .theme-btn {
    height: 44px;
    border-radius: var(--radius-md);
    cursor: pointer;
    border: 1px solid var(--border);
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }
  
  .theme-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 0 2px var(--accent);
  }
  
  .theme-btn.active::after {
    content: '‚úì';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 16px;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
  }

  /* === MOBILE RESPONSIVE === */
  @media (max-width: 1200px) {
    .dashboard {
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
    }
  }
  
  @media (max-width: 768px) {
    header {
      padding: 24px 20px 20px;
    }
    
    header h1 {
      font-size: 2rem;
    }
    
    .search-container {
      margin: 24px auto 20px;
    }
    
    .search-bar {
      padding: 6px 6px 6px 20px;
    }
    
    .search-bar input {
      font-size: 16px;
      padding: 12px 0;
    }
    
    .search-btn {
      padding: 12px 20px;
      font-size: 14px;
    }
    
    .dashboard {
      grid-template-columns: 1fr;
      gap: 24px;
      padding: 20px 0 60px;
    }
    
    .card {
      padding: 20px;
      min-height: 180px;
    }
    
    .controls {
      gap: 12px;
    }
    
    .control-group {
      width: 100%;
      justify-content: center;
    }
    
    .controls button {
      padding: 10px 16px;
      font-size: 13px;
      flex: 1;
    }
    
    .control-btn {
      width: 56px;
      height: 56px;
      bottom: 20px;
    }
    
    #toolboxToggle { left: 20px; }
    #paletteToggle { left: 92px; }
    #readerToggle { left: 164px; }
    
    .toolbox {
      width: calc(100% - 40px);
      height: 50vh;
      right: 20px;
      left: 20px;
      bottom: 92px;
    }
    
    .palette-panel {
      width: calc(100% - 40px);
      left: 20px;
      right: 20px;
      bottom: 92px;
    }
    
    .loading-indicator {
      bottom: 160px;
      right: 20px;
      left: 20px;
      justify-content: center;
    }
  }
  
  @media (max-width: 480px) {
    .card-header {
      flex-direction: column;
      gap: 16px;
    }
    
    .card-actions {
      width: 100%;
      justify-content: flex-end;
    }
    
    .embed-section {
      flex-direction: column;
      gap: 16px;
      align-items: stretch;
    }
    
    .embed-btn {
      text-align: center;
      justify-content: center;
    }
  }
</style>
</head>
<body>

  <!-- FLOATING CONTROLS -->
  <button id="toolboxToggle" class="control-btn" title="Toolbox (Ctrl+T)">üß∞</button>
  <button id="paletteToggle" class="control-btn" title="Themes (Ctrl+P)">üé®</button>
  <button id="readerToggle" class="control-btn" title="Reader Mode (Ctrl+R)">üëì</button>

  <!-- LOADING INDICATOR -->
  <div id="loadingIndicator" class="loading-indicator">
    <div class="spinner"></div>
    <span id="loadingText">Loading tools...</span>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>

  <!-- THEME PANEL -->
  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div class="palette-section">
      <div class="palette-title">üé® Accent Color</div>
      <div class="palette-grid">
        <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff"></div>
        <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55"></div>
        <div class="palette-color" data-accent="#00ff99" style="background:#00ff99"></div>
        <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00"></div>
        <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd"></div>
      </div>
    </div>
    
    <div class="palette-section">
      <div class="palette-title">üåÖ Background Theme</div>
      <div class="palette-grid">
        <button class="theme-btn active" data-color="default" style="background:linear-gradient(135deg, #0a0f14, #141e28)"></button>
        <button class="theme-btn" data-color="deep-blue" style="background:linear-gradient(135deg, #05080c, #0f151f)"></button>
        <button class="theme-btn" data-color="deep-purple" style="background:linear-gradient(135deg, #12081a, #1f1229)"></button>
        <button class="theme-btn" data-color="deep-teal" style="background:linear-gradient(135deg, #061616, #0f2525)"></button>
        <button class="theme-btn" data-color="deep-red" style="background:linear-gradient(135deg, #160606, #251010)"></button>
      </div>
    </div>
  </div>

  <!-- TOOLBOX -->
  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div class="toolbox-title">
        <span>üß∞ Toolbox</span>
        <span style="font-size:12px;color:var(--text-secondary)" id="widgetCount">(0 tools)</span>
      </div>
      <div class="toolbox-controls">
        <button id="dockBtn" class="toolbox-btn" title="Dock/Undock">‚á±</button>
        <button id="clearToolboxBtn" class="toolbox-btn" title="Clear All">üóëÔ∏è</button>
        <button id="toolboxClose" class="toolbox-btn" title="Close">‚úï</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite">
      <div style="text-align:center;padding:40px 20px;color:var(--text-secondary);">
        <div style="font-size:48px;margin-bottom:16px;">üß∞</div>
        <h3 style="color:var(--accent);margin-bottom:8px;">Empty Toolbox</h3>
        <p style="margin:0;">Add tools by clicking the + button on any card</p>
      </div>
    </div>
  </div>

  <!-- HEADER -->
  <header>
    <div class="header-content">
      <h1>The Most Useful Site in the World</h1>
      <p>A collection of essential tools for productivity, creativity, and problem-solving</p>
    </div>
  </header>

  <!-- MAIN CONTENT -->
  <main>
    <div class="search-container">
      <div class="search-bar">
        <input id="searchInput" placeholder="Search tools (e.g., 'calculator', 'converter', 'timer')..." autofocus />
        <button id="searchBtn" class="search-btn">Search</button>
      </div>
    </div>

    <div class="controls">
      <div class="control-group">
        <button id="sortAlphaBtn" class="active">üî§ A‚ÜíZ</button>
        <button id="sortRandomBtn">üé≤ Random</button>
        <button id="sortNewestBtn">üÜï Newest</button>
      </div>
      <div class="control-group">
        <button id="viewGridBtn" class="active">‚èπÔ∏è Grid</button>
        <button id="viewListBtn">üìã List</button>
        <button id="showAllBtn">üîÑ Load All</button>
      </div>
    </div>

    <div id="status" class="status-bar">
      <span id="statusText">Loading tools...</span>
      <span id="toolCount" class="tool-count">0/0</span>
    </div>

    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
// ==================== CONFIGURATION ====================
const CONFIG = {
  INITIAL_LOAD: 8,
  LOAD_BATCH_SIZE: 4,
  LOAD_DELAY: 100,
  MAX_CONCURRENT: 3,
  CACHE_TTL: 10 * 60 * 1000, // 10 minutes
  OBSERVER_THRESHOLD: 0.05,
  OBSERVER_ROOT_MARGIN: '300px'
};

// ==================== GLOBAL STATE ====================
let allCards = [];
let loadedCards = new Map();
let loadingCards = new Set();
let cardCache = new Map();
let observer = null;
let isSearching = false;
let currentSort = 'alpha';
let currentView = 'grid';

// Background themes
const themes = {
  'default': { bg1: '#0a0f14', bg2: '#141e28' },
  'deep-blue': { bg1: '#05080c', bg2: '#0f151f' },
  'deep-purple': { bg1: '#12081a', bg2: '#1f1229' },
  'deep-teal': { bg1: '#061616', bg2: '#0f2525' },
  'deep-red': { bg1: '#160606', bg2: '#251010' }
};

// Toolbox
let widgets = [];
let toolboxDocked = true;

// ==================== UTILITY FUNCTIONS ====================
function showLoading(text = 'Loading...') {
  const indicator = document.getElementById('loadingIndicator');
  const textElement = document.getElementById('loadingText');
  const progress = document.getElementById('progressFill');
  
  if (indicator && textElement) {
    textElement.textContent = text;
    indicator.classList.add('visible');
    if (progress) progress.style.width = '0%';
  }
}

function updateProgress(percent) {
  const progress = document.getElementById('progressFill');
  if (progress) {
    progress.style.width = `${percent}%`;
  }
}

function hideLoading() {
  const indicator = document.getElementById('loadingIndicator');
  if (indicator) {
    indicator.classList.remove('visible');
  }
}

function updateStatus() {
  const status = document.getElementById('statusText');
  const count = document.getElementById('toolCount');
  
  if (!status || !count) return;
  
  const total = allCards.length;
  const loaded = loadedCards.size;
  const visible = document.querySelectorAll('.card[style=""]').length;
  
  if (isSearching) {
    status.textContent = `Found ${visible} tool${visible !== 1 ? 's' : ''}`;
  } else if (loaded < total) {
    status.textContent = `Loading ${loaded} of ${total} tools...`;
  } else {
    status.textContent = `${total} tool${total !== 1 ? 's' : ''} ready`;
  }
  
  count.textContent = isSearching ? `${visible}/${total}` : `${loaded}/${total}`;
}

// ==================== CARD LOADING SYSTEM ====================
async function loadCardList() {
  try {
    showLoading('Loading tool catalog...');
    
    let cardFiles = [];
    
    // Try GitHub API
    try {
      const response = await fetch('https://api.github.com/repos/mrpr0phecy/mrpr0phecy/contents/cards');
      if (response.ok) {
        const data = await response.json();
        cardFiles = data
          .filter(item => item.name.endsWith('.html'))
          .map(item => item.name.replace('.html', ''))
          .sort();
        
        console.log(`Found ${cardFiles.length} cards via GitHub API`);
      }
    } catch (githubError) {
      console.warn('GitHub API failed, trying alternative...', githubError);
      
      // Alternative: Try directly loading known cards
      try {
        const knownCards = ['battery-sizing', 'cable-calculator', 'chord-finder', 'circuit-calculator', 
                           'evolution-walker', 'tip-calculator', 'unit-converter', 'countdown-timer'];
        
        // Test which cards exist
        cardFiles = [];
        for (const card of knownCards) {
          try {
            const test = await fetch(`cards/${card}.html`, { method: 'HEAD' });
            if (test.ok) cardFiles.push(card);
          } catch {}
        }
        
        console.log(`Found ${cardFiles.length} cards via direct check`);
      } catch (directError) {
        console.error('All methods failed:', directError);
      }
    }
    
    // Fallback to hardcoded list
    if (cardFiles.length === 0) {
      cardFiles = ['battery-sizing', 'cable-calculator', 'chord-finder', 'circuit-calculator', 
                  'evolution-walker', 'tip-calculator', 'unit-converter', 'countdown-timer'];
      console.log('Using fallback card list');
    }
    
    allCards = cardFiles;
    
    // Clear and create card placeholders
    const grid = document.getElementById('gridContainer');
    grid.innerHTML = '';
    
    cardFiles.forEach((cardName, index) => {
      const displayName = cardName.replace(/-/g, ' ');
      const card = document.createElement('div');
      card.className = 'card loading';
      card.dataset.name = cardName;
      card.dataset.index = index;
      card.dataset.displayName = displayName;
      
      card.innerHTML = `
        <div class="card-header">
          <h3>${displayName}</h3>
          <div class="card-actions">
            <button class="card-action-btn add-to-toolbox" title="Add to Toolbox">+</button>
            <button class="card-action-btn card-expand" title="Open in New Tab">‚Üó</button>
          </div>
        </div>
        <div class="card-content">
          <div class="card-body">
            <div style="padding:40px 20px;text-align:center;">
              <div style="margin-bottom:16px;font-size:48px;opacity:0.3;">‚öôÔ∏è</div>
              <div style="color:rgba(230,250,255,0.6);font-size:14px;">Loading ${displayName}...</div>
            </div>
          </div>
        </div>
        <div class="embed-section" style="display:none;">
          <div class="embed-label">Share this tool</div>
          <button class="embed-btn" data-card="${cardName}">
            <span>üîó</span>
            <span>Copy Embed Code</span>
          </button>
        </div>
      `;
      
      grid.appendChild(card);
    });
    
    updateStatus();
    hideLoading();
    
    // Load first cards immediately
    setTimeout(() => {
      loadInitialCards();
      initIntersectionObserver();
    }, 300);
    
  } catch (error) {
    console.error('Error loading card list:', error);
    document.getElementById('statusText').textContent = 'Failed to load tools. Please refresh.';
    hideLoading();
  }
}

function loadInitialCards() {
  const cards = document.querySelectorAll('.card:not(.loaded)');
  const initialBatch = Array.from(cards).slice(0, CONFIG.INITIAL_LOAD);
  
  console.log(`Loading ${initialBatch.length} initial cards`);
  
  initialBatch.forEach((card, index) => {
    setTimeout(() => {
      const cardName = card.dataset.name;
      if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
        loadCard(card, cardName);
      }
    }, index * CONFIG.LOAD_DELAY);
  });
}

async function loadCard(card, cardName) {
  if (loadingCards.has(cardName) || loadedCards.has(cardName)) return;
  
  loadingCards.add(cardName);
  console.log(`Loading card: ${cardName}`);
  
  // Check cache first
  const cached = cardCache.get(cardName);
  if (cached && (Date.now() - cached.timestamp) < CONFIG.CACHE_TTL) {
    console.log(`Loading ${cardName} from cache`);
    setTimeout(() => {
      renderCardContent(card, cardName, cached.html);
      loadingCards.delete(cardName);
      loadedCards.set(cardName, true);
    }, 50);
    return;
  }
  
  try {
    // Try to load the card
    const response = await fetch(`cards/${cardName}.html`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const html = await response.text();
    
    // Sanitize HTML to prevent style issues
    const sanitizedHTML = sanitizeCardHTML(html);
    
    // Cache it
    cardCache.set(cardName, {
      html: sanitizedHTML,
      timestamp: Date.now()
    });
    
    renderCardContent(card, cardName, sanitizedHTML);
    
  } catch (error) {
    console.error(`Failed to load card ${cardName}:`, error);
    showCardError(card, cardName, error);
  } finally {
    loadingCards.delete(cardName);
    loadedCards.set(cardName, true);
    updateStatus();
    
    // Stop observing this card
    if (observer) {
      observer.unobserve(card);
    }
  }
}

function sanitizeCardHTML(html) {
  // Create a temporary container
  const temp = document.createElement('div');
  temp.innerHTML = html;
  
  // Remove any style tags that might interfere
  const styles = temp.querySelectorAll('style');
  styles.forEach(style => {
    const styleText = style.textContent;
    // Only remove styles that set background colors or white colors
    if (styleText.includes('background') || styleText.includes('#fff') || 
        styleText.includes('white') || styleText.includes('rgb(255')) {
      style.remove();
    }
  });
  
  // Fix any elements with white backgrounds
  const allElements = temp.querySelectorAll('*');
  allElements.forEach(el => {
    // Remove inline white backgrounds
    if (el.style.background === 'white' || el.style.backgroundColor === 'white' ||
        el.style.background === '#fff' || el.style.backgroundColor === '#fff' ||
        el.style.background === '#ffffff' || el.style.backgroundColor === '#ffffff') {
      el.style.background = 'transparent';
      el.style.backgroundColor = 'transparent';
    }
    
    // Ensure text color inherits
    if (el.style.color && !el.style.color.includes('var(') && !el.style.color.includes('inherit')) {
      el.style.color = 'inherit';
    }
  });
  
  return temp.innerHTML;
}

function renderCardContent(card, cardName, html) {
  const cardBody = card.querySelector('.card-body');
  if (!cardBody) return;
  
  try {
    // Set the HTML
    cardBody.innerHTML = html;
    
    // Execute any scripts
    const scripts = cardBody.querySelectorAll('script');
    scripts.forEach(oldScript => {
      const newScript = document.createElement('script');
      
      if (oldScript.src) {
        // For external scripts
        newScript.src = oldScript.src;
      } else {
        // For inline scripts
        try {
          // Try to wrap in a function to avoid global scope issues
          const scriptContent = oldScript.textContent;
          if (scriptContent.trim()) {
            newScript.textContent = `(function(){${scriptContent}})();`;
          }
        } catch (e) {
          console.warn(`Failed to process script in ${cardName}:`, e);
        }
      }
      
      // Copy attributes
      Array.from(oldScript.attributes).forEach(attr => {
        newScript.setAttribute(attr.name, attr.value);
      });
      
      // Replace the old script
      oldScript.parentNode.replaceChild(newScript, oldScript);
    });
    
    // Show embed section
    const embedSection = card.querySelector('.embed-section');
    if (embedSection) {
      embedSection.style.display = 'flex';
      
      const embedBtn = embedSection.querySelector('.embed-btn');
      if (embedBtn) {
        embedBtn.addEventListener('click', () => {
          copyEmbedCode(cardName);
        });
      }
    }
    
    // Update card state
    card.classList.remove('loading');
    card.classList.add('loaded', 'visible');
    
    // Update progress
    const loadedPercent = Math.round((loadedCards.size / allCards.length) * 100);
    updateProgress(loadedPercent);
    
    console.log(`Successfully rendered: ${cardName}`);
    
  } catch (error) {
    console.error(`Error rendering card ${cardName}:`, error);
    showCardError(card, cardName, error);
  }
}

function showCardError(card, cardName, error) {
  const cardBody = card.querySelector('.card-body');
  if (cardBody) {
    const displayName = card.dataset.displayName || cardName;
    cardBody.innerHTML = `
      <div style="padding:40px 20px;text-align:center;color:rgba(255,77,77,0.8);">
        <div style="font-size:48px;margin-bottom:16px;">‚ö†Ô∏è</div>
        <h3 style="color:rgba(255,77,77,0.9);margin-bottom:12px;">Failed to load ${displayName}</h3>
        <div style="font-size:14px;opacity:0.8;margin-bottom:20px;">${error.message || 'Unknown error'}</div>
        <button onclick="retryLoadCard('${cardName}')" style="padding:10px 20px;background:rgba(255,77,77,0.1);border:1px solid rgba(255,77,77,0.3);color:rgba(255,77,77,0.9);border-radius:8px;cursor:pointer;">
          Retry Loading
        </button>
      </div>
    `;
    card.classList.remove('loading');
    card.classList.add('loaded', 'visible');
  }
}

// Expose retry function globally
window.retryLoadCard = function(cardName) {
  const card = document.querySelector(`.card[data-name="${cardName}"]`);
  if (card && !loadingCards.has(cardName)) {
    loadedCards.delete(cardName);
    cardCache.delete(cardName);
    loadCard(card, cardName);
  }
};

function initIntersectionObserver() {
  if (observer) observer.disconnect();
  
  observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && !isSearching) {
        const card = entry.target;
        const cardName = card.dataset.name;
        
        if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
          loadCard(card, cardName);
        }
      }
    });
  }, {
    root: null,
    rootMargin: CONFIG.OBSERVER_ROOT_MARGIN,
    threshold: CONFIG.OBSERVER_THRESHOLD
  });
  
  // Observe unloaded cards
  document.querySelectorAll('.card:not(.loaded)').forEach(card => {
    observer.observe(card);
  });
}

// ==================== TOOLBOX SYSTEM ====================
function initToolbox() {
  const toolbox = document.getElementById('toolbox');
  const toolboxTitle = document.getElementById('toolboxTitle');
  
  // Dragging
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  toolboxTitle.addEventListener('mousedown', (e) => {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = toolbox.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onToolboxDrag);
    document.addEventListener('mouseup', stopToolboxDrag);
    toolboxTitle.style.cursor = 'grabbing';
  });
  
  function onToolboxDrag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    if (!toolboxDocked) {
      toolbox.style.left = (e.clientX - dragOffset.x) + 'px';
      toolbox.style.top = (e.clientY - dragOffset.y) + 'px';
      toolbox.style.right = 'auto';
      toolbox.style.bottom = 'auto';
    }
  }
  
  function stopToolboxDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onToolboxDrag);
    document.removeEventListener('mouseup', stopToolboxDrag);
    toolboxTitle.style.cursor = '';
  }
  
  // Controls
  document.getElementById('dockBtn').addEventListener('click', () => {
    toolboxDocked = !toolboxDocked;
    const btn = document.getElementById('dockBtn');
    btn.textContent = toolboxDocked ? '‚á±' : '‚á≤';
    btn.title = toolboxDocked ? 'Undock' : 'Dock';
  });
  
  document.getElementById('clearToolboxBtn').addEventListener('click', () => {
    if (widgets.length === 0) return;
    
    if (confirm(`Clear all ${widgets.length} widgets from toolbox?`)) {
      document.getElementById('toolboxContent').innerHTML = `
        <div style="text-align:center;padding:40px 20px;color:var(--text-secondary);">
          <div style="font-size:48px;margin-bottom:16px;">üß∞</div>
          <h3 style="color:var(--accent);margin-bottom:8px;">Empty Toolbox</h3>
          <p style="margin:0;">Add tools by clicking the + button on any card</p>
        </div>
      `;
      widgets = [];
      saveWidgets();
      updateWidgetCount();
    }
  });
  
  // Load saved widgets
  loadSavedWidgets();
}

function createWidget(name, contentHTML) {
  const widgetId = 'widget-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  const widget = document.createElement('div');
  widget.className = 'widget-wrap';
  widget.id = widgetId;
  widget.dataset.name = name;
  
  widget.innerHTML = `
    <div class="widget-titlebar">
      <strong>${name}</strong>
      <button class="widget-close" title="Close widget">‚úï</button>
    </div>
    <div class="widget-body">${contentHTML}</div>
  `;
  
  const toolboxContent = document.getElementById('toolboxContent');
  
  // Remove empty state if present
  if (toolboxContent.children.length === 1 && 
      toolboxContent.children[0].querySelector('h3')?.textContent === 'Empty Toolbox') {
    toolboxContent.innerHTML = '';
  }
  
  toolboxContent.appendChild(widget);
  
  // Position randomly but not too close to edges
  const rect = toolboxContent.getBoundingClientRect();
  const maxX = rect.width - 200;
  const maxY = rect.height - 160;
  widget.style.left = Math.max(20, Math.min(maxX - 20, Math.random() * maxX)) + 'px';
  widget.style.top = Math.max(20, Math.min(maxY - 20, Math.random() * maxY)) + 'px';
  widget.style.width = '200px';
  widget.style.height = '160px';
  
  // Make draggable and resizable
  makeWidgetDraggable(widget);
  makeWidgetResizable(widget);
  
  // Close button
  widget.querySelector('.widget-close').addEventListener('click', () => {
    widget.remove();
    widgets = widgets.filter(w => w.id !== widgetId);
    saveWidgets();
    updateWidgetCount();
    
    // Show empty state if no widgets left
    if (widgets.length === 0) {
      toolboxContent.innerHTML = `
        <div style="text-align:center;padding:40px 20px;color:var(--text-secondary);">
          <div style="font-size:48px;margin-bottom:16px;">üß∞</div>
          <h3 style="color:var(--accent);margin-bottom:8px;">Empty Toolbox</h3>
          <p style="margin:0;">Add tools by clicking the + button on any card</p>
        </div>
      `;
    }
  });
  
  // Save widget
  widgets.push({
    id: widgetId,
    name: name,
    content: contentHTML,
    x: widget.style.left,
    y: widget.style.top,
    width: widget.style.width,
    height: widget.style.height
  });
  
  saveWidgets();
  updateWidgetCount();
  
  return widgetId;
}

function makeWidgetDraggable(widget) {
  const titlebar = widget.querySelector('.widget-titlebar');
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  titlebar.addEventListener('mousedown', (e) => {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = widget.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    widget.style.zIndex = '1000';
  });
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    const parentRect = widget.parentElement.getBoundingClientRect();
    const x = e.clientX - parentRect.left - dragOffset.x;
    const y = e.clientY - parentRect.top - dragOffset.y;
    
    const maxX = parentRect.width - widget.offsetWidth;
    const maxY = parentRect.height - widget.offsetHeight;
    
    widget.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
    widget.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    widget.style.zIndex = '1';
    
    // Update saved position
    const widgetObj = widgets.find(w => w.id === widget.id);
    if (widgetObj) {
      widgetObj.x = widget.style.left;
      widgetObj.y = widget.style.top;
      saveWidgets();
    }
  }
}

function makeWidgetResizable(widget) {
  const resizeHandle = document.createElement('div');
  resizeHandle.style.cssText = `
    position: absolute;
    right: 0;
    bottom: 0;
    width: 20px;
    height: 20px;
    cursor: se-resize;
    background: transparent;
    z-index: 10;
  `;
  
  widget.appendChild(resizeHandle);
  
  let isResizing = false;
  let startSize = { width: 0, height: 0 };
  let startPos = { x: 0, y: 0 };
  
  resizeHandle.addEventListener('mousedown', (e) => {
    e.stopPropagation();
    isResizing = true;
    startSize.width = widget.offsetWidth;
    startSize.height = widget.offsetHeight;
    startPos.x = e.clientX;
    startPos.y = e.clientY;
    
    document.addEventListener('mousemove', onResize);
    document.addEventListener('mouseup', stopResize);
  });
  
  function onResize(e) {
    if (!isResizing) return;
    
    e.preventDefault();
    const dx = e.clientX - startPos.x;
    const dy = e.clientY - startPos.y;
    
    widget.style.width = Math.max(200, startSize.width + dx) + 'px';
    widget.style.height = Math.max(160, startSize.height + dy) + 'px';
  }
  
  function stopResize() {
    isResizing = false;
    document.removeEventListener('mousemove', onResize);
    document.removeEventListener('mouseup', stopResize);
    
    const widgetObj = widgets.find(w => w.id === widget.id);
    if (widgetObj) {
      widgetObj.width = widget.style.width;
      widgetObj.height = widget.style.height;
      saveWidgets();
    }
  }
}

function saveWidgets() {
  localStorage.setItem('toolboxWidgets', JSON.stringify(widgets));
}

function loadSavedWidgets() {
  try {
    const saved = localStorage.getItem('toolboxWidgets');
    if (saved) {
      widgets = JSON.parse(saved) || [];
      
      const toolboxContent = document.getElementById('toolboxContent');
      
      // Remove empty state if widgets exist
      if (widgets.length > 0) {
        toolboxContent.innerHTML = '';
      }
      
      widgets.forEach(data => {
        const widget = document.createElement('div');
        widget.className = 'widget-wrap';
        widget.id = data.id;
        widget.dataset.name = data.name;
        widget.style.left = data.x;
        widget.style.top = data.y;
        widget.style.width = data.width;
        widget.style.height = data.height;
        
        widget.innerHTML = `
          <div class="widget-titlebar">
            <strong>${data.name}</strong>
            <button class="widget-close" title="Close widget">‚úï</button>
          </div>
          <div class="widget-body">${data.content}</div>
        `;
        
        toolboxContent.appendChild(widget);
        
        makeWidgetDraggable(widget);
        makeWidgetResizable(widget);
        
        widget.querySelector('.widget-close').addEventListener('click', () => {
          widget.remove();
          widgets = widgets.filter(w => w.id !== data.id);
          saveWidgets();
          updateWidgetCount();
          
          if (widgets.length === 0) {
            toolboxContent.innerHTML = `
              <div style="text-align:center;padding:40px 20px;color:var(--text-secondary);">
                <div style="font-size:48px;margin-bottom:16px;">üß∞</div>
                <h3 style="color:var(--accent);margin-bottom:8px;">Empty Toolbox</h3>
                <p style="margin:0;">Add tools by clicking the + button on any card</p>
              </div>
            `;
          }
        });
      });
      
      updateWidgetCount();
    }
  } catch (e) {
    console.error('Failed to load widgets:', e);
    widgets = [];
  }
}

function updateWidgetCount() {
  const countElement = document.getElementById('widgetCount');
  if (countElement) {
    const count = widgets.length;
    countElement.textContent = `(${count} tool${count !== 1 ? 's' : ''})`;
  }
}

// ==================== OTHER SYSTEMS ====================
function applyTheme(themeName) {
  const theme = themes[themeName];
  if (!theme) return;
  
  const gradient = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
  document.documentElement.style.background = gradient;
  document.body.style.background = gradient;
  
  localStorage.setItem('theme', themeName);
}

function copyEmbedCode(cardName) {
  const displayName = cardName.replace(/-/g, ' ');
  const embedCode = `<iframe src="https://mrpr0phecy.github.io/mrpr0phecy/cards/${cardName}.html" width="100%" height="400" style="border:none;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);" title="${displayName} - The Most Useful Site"></iframe>`;
  
  navigator.clipboard.writeText(embedCode).then(() => {
    const embedBtn = document.querySelector(`.embed-btn[data-card="${cardName}"]`);
    if (embedBtn) {
      const originalHTML = embedBtn.innerHTML;
      embedBtn.innerHTML = '<span>‚úÖ</span><span>Copied!</span>';
      embedBtn.classList.add('copied');
      
      setTimeout(() => {
        embedBtn.innerHTML = originalHTML;
        embedBtn.classList.remove('copied');
      }, 2000);
    }
  }).catch(err => {
    console.error('Copy failed:', err);
    // Fallback
    const textArea = document.createElement('textarea');
    textArea.value = embedCode;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (e) {}
    document.body.removeChild(textArea);
  });
}

function performSearch(query) {
  query = query.toLowerCase().trim();
  isSearching = query.length > 0;
  
  const cards = document.querySelectorAll('.card');
  let visibleCount = 0;
  
  cards.forEach(card => {
    const name = card.dataset.name.toLowerCase();
    const displayName = card.dataset.displayName.toLowerCase();
    const text = card.textContent.toLowerCase();
    const matches = name.includes(query) || displayName.includes(query) || text.includes(query);
    
    card.style.display = matches ? '' : 'none';
    
    if (matches) {
      visibleCount++;
      
      // Load card if not already loaded
      const cardName = card.dataset.name;
      if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
        loadCard(card, cardName);
      }
    }
  });
  
  updateStatus();
}

function sortCards(type) {
  currentSort = type;
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  switch (type) {
    case 'alpha':
      cards.sort((a, b) => a.dataset.name.localeCompare(b.dataset.name));
      break;
    case 'random':
      for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        grid.appendChild(cards[j]);
      }
      return;
    case 'newest':
      cards.sort((a, b) => b.dataset.index - a.dataset.index);
      break;
  }
  
  cards.forEach(card => grid.appendChild(card));
}

function setView(type) {
  currentView = type;
  const dashboard = document.getElementById('gridContainer');
  
  if (type === 'list') {
    dashboard.style.gridTemplateColumns = '1fr';
    dashboard.style.maxWidth = '900px';
    dashboard.style.margin = '0 auto';
  } else {
    dashboard.style.gridTemplateColumns = 'repeat(auto-fill, minmax(var(--card-min), 1fr))';
    dashboard.style.maxWidth = '';
    dashboard.style.margin = '';
  }
}

// ==================== INITIALIZATION ====================
document.addEventListener('DOMContentLoaded', () => {
  console.log('Initializing The Most Useful Site...');
  
  // Apply saved settings
  const savedTheme = localStorage.getItem('theme') || 'default';
  applyTheme(savedTheme);
  
  const savedAccent = localStorage.getItem('accent') || '#2dd4ff';
  document.documentElement.style.setProperty('--accent', savedAccent);
  
  // Update active theme button
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === savedTheme) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
  
  // Update active accent color
  document.querySelectorAll('.palette-color').forEach(c => {
    if (c.dataset.accent === savedAccent) {
      c.classList.add('active');
    } else {
      c.classList.remove('active');
    }
  });
  
  // Apply reader mode
  if (localStorage.getItem('readerMode') === 'on') {
    document.body.classList.add('reader-mode');
    document.getElementById('readerToggle').classList.add('active');
  }
  
  // Initialize toolbox
  initToolbox();
  
  // Load cards immediately
  loadCardList();
  
  // Setup event listeners
  setupEventListeners();
});

function setupEventListeners() {
  // Theme panel
  document.getElementById('paletteToggle').addEventListener('click', () => {
    const panel = document.getElementById('palettePanel');
    panel.classList.toggle('open');
    document.getElementById('paletteToggle').classList.toggle('active');
  });
  
  // Accent colors
  document.querySelectorAll('.palette-color').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.palette-color').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const color = btn.dataset.accent;
      document.documentElement.style.setProperty('--accent', color);
      localStorage.setItem('accent', color);
    });
  });
  
  // Background themes
  document.querySelectorAll('.theme-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyTheme(btn.dataset.color);
    });
  });
  
  // Toolbox
  document.getElementById('toolboxToggle').addEventListener('click', () => {
    const toolbox = document.getElementById('toolbox');
    toolbox.classList.toggle('hidden');
    if (!toolbox.classList.contains('hidden')) {
      setTimeout(() => {
        toolbox.classList.add('visible');
      }, 10);
    }
    document.getElementById('toolboxToggle').classList.toggle('active');
  });
  
  document.getElementById('toolboxClose').addEventListener('click', (e) => {
    e.stopPropagation();
    const toolbox = document.getElementById('toolbox');
    toolbox.classList.add('hidden');
    document.getElementById('toolboxToggle').classList.remove('active');
  });
  
  // Reader mode
  document.getElementById('readerToggle').addEventListener('click', () => {
    const isReaderMode = document.body.classList.toggle('reader-mode');
    document.getElementById('readerToggle').classList.toggle('active', isReaderMode);
    localStorage.setItem('readerMode', isReaderMode ? 'on' : 'off');
  });
  
  // Search
  const searchInput = document.getElementById('searchInput');
  const searchBtn = document.getElementById('searchBtn');
  
  let searchTimeout;
  searchInput.addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      performSearch(e.target.value);
    }, 300);
  });
  
  searchBtn.addEventListener('click', () => {
    performSearch(searchInput.value);
  });
  
  // Enter key in search
  searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      performSearch(searchInput.value);
    }
  });
  
  // Sorting
  document.getElementById('sortAlphaBtn').addEventListener('click', () => {
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    document.getElementById('sortAlphaBtn').classList.add('active');
    sortCards('alpha');
  });
  
  document.getElementById('sortRandomBtn').addEventListener('click', () => {
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    document.getElementById('sortRandomBtn').classList.add('active');
    sortCards('random');
  });
  
  document.getElementById('sortNewestBtn').addEventListener('click', () => {
    document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
    document.getElementById('sortNewestBtn').classList.add('active');
    sortCards('newest');
  });
  
  // View
  document.getElementById('viewGridBtn').addEventListener('click', () => {
    document.getElementById('viewGridBtn').classList.add('active');
    document.getElementById('viewListBtn').classList.remove('active');
    setView('grid');
  });
  
  document.getElementById('viewListBtn').addEventListener('click', () => {
    document.getElementById('viewListBtn').classList.add('active');
    document.getElementById('viewGridBtn').classList.remove('active');
    setView('list');
  });
  
  // Load All
  document.getElementById('showAllBtn').addEventListener('click', async () => {
    showLoading('Loading all tools...');
    
    const cards = document.querySelectorAll('.card:not(.loaded)');
    const total = cards.length;
    let loaded = 0;
    
    for (let i = 0; i < cards.length; i++) {
      const card = cards[i];
      const cardName = card.dataset.name;
      
      if (cardName && !loadedCards.has(cardName) && !loadingCards.has(cardName)) {
        await loadCard(card, cardName);
        loaded++;
        updateProgress(Math.round((loaded / total) * 100));
        
        // Small delay to prevent overwhelming the browser
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    hideLoading();
    updateStatus();
  });
  
  // Add to toolbox button
  document.addEventListener('click', (e) => {
    const addBtn = e.target.closest('.add-to-toolbox');
    if (addBtn) {
      e.preventDefault();
      e.stopPropagation();
      
      const card = addBtn.closest('.card');
      if (!card) return;
      
      const cardName = card.dataset.name;
      const displayName = card.dataset.displayName || cardName.replace(/-/g, ' ');
      
      if (!card.classList.contains('loaded')) {
        alert('Please wait for the tool to load before adding to toolbox');
        return;
      }
      
      const cardBody = card.querySelector('.card-body');
      if (!cardBody) return;
      
      // Clone content but remove the embed section
      const contentClone = cardBody.cloneNode(true);
      const embedSection = contentClone.querySelector('.embed-section');
      if (embedSection) {
        embedSection.remove();
      }
      
      // Create widget
      createWidget(displayName, contentClone.innerHTML);
      
      // Show toolbox if hidden
      const toolbox = document.getElementById('toolbox');
      if (toolbox.classList.contains('hidden')) {
        toolbox.classList.remove('hidden');
        setTimeout(() => {
          toolbox.classList.add('visible');
        }, 10);
        document.getElementById('toolboxToggle').classList.add('active');
      }
      
      // Visual feedback
      const originalHTML = addBtn.innerHTML;
      addBtn.innerHTML = '‚úì';
      addBtn.style.color = 'var(--accent)';
      setTimeout(() => {
        addBtn.innerHTML = originalHTML;
        addBtn.style.color = '';
      }, 1500);
      
      console.log(`Added "${displayName}" to toolbox`);
    }
  });
  
  // Expand button
  document.addEventListener('click', (e) => {
    const expandBtn = e.target.closest('.card-expand');
    if (expandBtn) {
      e.preventDefault();
      e.stopPropagation();
      
      const card = expandBtn.closest('.card');
      const cardName = card.dataset.name;
      
      if (cardName) {
        window.open(`cards/${cardName}.html`, '_blank', 'noopener,noreferrer');
      }
    }
  });
  
  // Close panels when clicking outside
  document.addEventListener('click', (e) => {
    const palettePanel = document.getElementById('palettePanel');
    if (palettePanel.classList.contains('open') && 
        !e.target.closest('.palette-panel') && 
        !e.target.closest('#paletteToggle')) {
      palettePanel.classList.remove('open');
      document.getElementById('paletteToggle').classList.remove('active');
    }
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Ctrl+T for toolbox
    if (e.ctrlKey && e.key === 't') {
      e.preventDefault();
      document.getElementById('toolboxToggle').click();
    }
    // Ctrl+P for palette
    else if (e.ctrlKey && e.key === 'p') {
      e.preventDefault();
      document.getElementById('paletteToggle').click();
    }
    // Ctrl+R for reader mode
    else if (e.ctrlKey && e.key === 'r') {
      e.preventDefault();
      document.getElementById('readerToggle').click();
    }
    // Escape to close panels
    else if (e.key === 'Escape') {
      document.getElementById('palettePanel').classList.remove('open');
      document.getElementById('paletteToggle').classList.remove('active');
    }
    // / to focus search
    else if (e.key === '/' && document.activeElement !== searchInput) {
      e.preventDefault();
      searchInput.focus();
    }
  });
  
  // Auto-focus search on page load
  window.addEventListener('load', () => {
    setTimeout(() => {
      searchInput.focus();
    }, 500);
  });
}

// Initialize Sortable for card dragging (optional)
new Sortable(document.getElementById('gridContainer'), {
  animation: 150,
  ghostClass: 'sortable-ghost',
  chosenClass: 'sortable-chosen',
  dragClass: 'sortable-drag'
});

console.log('The Most Useful Site initialized successfully!');
</script>
</body>
</html>
