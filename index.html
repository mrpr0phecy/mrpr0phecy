<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  /* DARK DEFAULTS DIRECTLY IN CSS - NO VARIABLES FOR BACKGROUND */
  html,body{
    height:100%;
    margin:0;
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(135deg, #0a0f14, #141e28); /* DARK DEFAULT */
    color:#e6faff;
    -webkit-font-smoothing:antialiased;
    /* Ensure background covers entire page */
    background-attachment: fixed;
    background-size: cover;
    /* Prevent card content from overflowing */
    overflow-x: hidden;
  }
  
  /* CSS VARIABLES ONLY FOR THINGS THAT CHANGE */
  :root{
    --accent:#2dd4ff; 
    --muted:#e6faff; 
    --text:#e6faff;
    --glass: rgba(255,255,255,0.06);
    --panel: rgba(20,20,20,0.92);
    --card-grad-1: rgba(255,255,255,0.02);
    --card-grad-2: rgba(255,255,255,0.04);
    --border: rgba(255,255,255,0.10);
    --card-min: 260px;
    --card-scale: 1;
    --card-translateY: 18px;
    --toolbox-width: 520px;
    --toolbox-height: 420px;
  }

  header{
    padding:20px;
    text-align:center;
    z-index:2
  }
  
  header h1{
    margin:0;
    color:var(--accent);
    font-size:1.6rem
  }

  .control-btn{
    position:fixed;
    bottom:18px;
    z-index:14000;
    width:48px;
    height:48px;
    border-radius:10px;
    background:var(--glass);
    border:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    backdrop-filter:blur(6px);
    box-shadow:0 8px 30px rgba(0,0,0,0.45);
    color:var(--accent);
    transition: transform 0.2s;
  }
  
  .control-btn:hover{
    transform:scale(1.06)
  }
  
  #toolboxToggle{left:18px}
  #paletteToggle{left:78px}
  #readerToggle{left:138px}

  .palette-panel{
    position:fixed;
    left:78px;
    bottom:74px;
    z-index:13900;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:10px;
    padding:12px;
    box-shadow:0 12px 36px rgba(0,0,0,0.6);
    backdrop-filter:blur(8px);
    display:none;
    pointer-events:none;
  }
  
  .palette-panel.open{
    display:block;
    pointer-events:auto
  }

  .toolbox {
    position:fixed;
    right:18px;
    bottom:18px;
    width:var(--toolbox-width);
    height:var(--toolbox-height);
    z-index:13700;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:0 18px 48px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    resize:both;
    min-width:300px;
    min-height:200px;
  }
  
  .toolbox.hidden{
    display:none
  }

  .toolbox .titlebar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:10px;
    border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
    cursor:grab;
    z-index:13750;
  }

  .toolbox .content{
    position:relative;
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    overflow:auto;
    min-height:100px;
  }

  .widget-wrap{
    position:absolute;
    box-sizing:border-box;
    background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.04);
    min-width:120px;
    min-height:80px;
    max-width:calc(100% - 20px);
    max-height:calc(100% - 20px);
    overflow:hidden;
    resize:both;
    z-index:1;
    box-shadow:0 8px 20px rgba(0,0,0,0.35);
  }

  .widget-titlebar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:8px 10px;
    border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    cursor:move;
    user-select:none;
  }
  
  .widget-titlebar strong{
    color:var(--accent);
    font-size:14px;
  }
  
  .widget-body{
    padding:10px;
    overflow:auto;
    max-height:60vh;
    font-size:14px;
    line-height:1.4;
  }

  .widget-close, #toolboxClose { 
    z-index: 13800; 
    position: relative; 
    background:transparent;
    border:0;
    color:var(--muted);
    cursor:pointer;
    font-size:14px;
  }

  main{
    position:relative;
    z-index:2;
    scroll-margin-top: 0;
  }
  
  .search-bar{
    max-width:1100px;
    margin:14px auto 16px;
    display:flex;
    background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.02));
    border-radius:12px;
    padding:12px 16px;
    border:1px solid rgba(255,255,255,0.04);
    scroll-margin-top: 20px;
  }
  
  .search-bar input{
    flex:1;
    border:none;
    background:transparent;
    color:var(--text);
    font-size:1rem;
    outline:none
  }

  .controls{
    display:flex;
    gap:8px;
    justify-content:center;
    margin-bottom:12px;
    flex-wrap: wrap;
  }
  
  .controls button{
    padding:8px 12px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.06);
    background:transparent;
    color:var(--muted);
    cursor:pointer;
    transition: all 0.2s;
  }
  
  .controls button:hover{
    background: rgba(45,212,255,0.1);
    border-color: rgba(45,212,255,0.3);
  }

  .dashboard{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
    gap:20px;
    padding:20px;
    align-items:start;
    box-sizing:border-box;
    max-width:100%;
    overflow:hidden;
    min-height: 800px;
    position: relative;
  }

  /* ===== ENHANCED CARD STYLES ===== */
  .card{
    box-sizing:border-box;
    background:linear-gradient(135deg,var(--card-grad-1),var(--card-grad-2));
    border:1px solid var(--border);
    border-radius:12px;
    padding:16px;
    min-height:120px;
    width:100%;
    max-width:100%;
    opacity:0;
    transform: translateY(var(--card-translateY)) scale(var(--card-scale));
    transition: opacity .36s ease, transform .36s ease, height .3s ease;
    box-shadow:0 8px 24px rgba(0,0,0,0.35);
    overflow: visible;
    height: auto;
    max-height: 80vh;
    resize: vertical;
    position: relative;
    contain: content;
    word-wrap: break-word;
    overflow-wrap: break-word;
    cursor: default;
  }
  
  .card.visible{
    opacity:1;
    transform: translateY(0) scale(var(--card-scale));
  }
  
  /* Card resize handle */
  .card::after {
    content: 'â†•';
    position: absolute;
    bottom: 6px;
    right: 10px;
    font-size: 12px;
    color: rgba(255,255,255,0.3);
    cursor: ns-resize;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }
  
  .card:hover::after {
    opacity: 0.5;
  }
  
  .card:active::after {
    opacity: 1;
  }
  
  .card.card-auto-size::after {
    display: none;
  }
  
  /* Card content wrapper */
  .card-content-wrapper {
    position: relative;
    width: 100%;
    height: auto;
    overflow: hidden;
    transition: height 0.3s ease;
  }
  
  /* Card inner content */
  .card-inner {
    width: 100%;
    padding-bottom: 8px;
  }
  
  /* Expandable content section */
  .card-expandable {
    max-height: 400px;
    overflow-y: auto;
    overflow-x: hidden;
    transition: max-height 0.3s ease;
    position: relative;
  }
  
  .card-expanded .card-expandable {
    max-height: 1000px;
  }
  
  /* Expand/collapse button */
  .card-expand-btn {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: rgba(45,212,255,0.1);
    border: 1px solid rgba(45,212,255,0.3);
    color: var(--accent);
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    cursor: pointer;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.2s, background 0.2s;
  }
  
  .card:hover .card-expand-btn {
    opacity: 0.7;
  }
  
  .card:hover .card-expand-btn:hover {
    opacity: 1;
    background: rgba(45,212,255,0.2);
  }
  
  /* Auto-sizing for card content */
  .card-auto-size {
    height: auto !important;
    min-height: 120px;
    max-height: none;
    resize: none;
  }
  
  /* Card size indicators */
  .card-size-indicator {
    position: absolute;
    top: 8px;
    right: 40px;
    font-size: 10px;
    color: rgba(255,255,255,0.4);
    background: rgba(0,0,0,0.3);
    padding: 2px 6px;
    border-radius: 10px;
    display: none;
  }
  
  .card-resizing .card-size-indicator {
    display: block;
  }
  
  .card-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
    cursor: default;
    user-select: none;
  }
  
  .card-header h3{
    margin:0;
    color:var(--accent);
    font-size:1.05rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width:70%;
  }
  
  /* Card content container with scroll isolation */
  .card-content {
    position: relative;
    overflow-y: auto;
    overflow-x: hidden;
    padding-right: 4px;
    isolation: isolate;
  }
  
  /* Custom scrollbar for card content */
  .card-content::-webkit-scrollbar,
  .card-expandable::-webkit-scrollbar {
    width: 6px;
  }
  
  .card-content::-webkit-scrollbar-track,
  .card-expandable::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.03);
    border-radius: 3px;
  }
  
  .card-content::-webkit-scrollbar-thumb,
  .card-expandable::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 3px;
    opacity: 0.5;
  }
  
  .card-content::-webkit-scrollbar-thumb:hover,
  .card-expandable::-webkit-scrollbar-thumb:hover {
    opacity: 0.8;
  }

  /* ===== SIMPLE EMBED SECTION ===== */
  .embed-section {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.06);
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
  }
  
  .embed-section span {
    color: rgba(230,250,255,0.7);
    white-space: nowrap;
  }
  
  .embed-btn {
    background: rgba(45,212,255,0.1);
    color: var(--accent);
    border: 1px solid rgba(45,212,255,0.3);
    padding: 4px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  
  .embed-btn:hover {
    background: rgba(45,212,255,0.2);
    transform: translateY(-1px);
  }
  
  .embed-btn.copied {
    background: rgba(57,255,20,0.1);
    color: #39ff14;
    border-color: rgba(57,255,20,0.3);
  }

  body.reader-mode{
    font-size:1.12rem;
    line-height:1.6
  }
  
  body.reader-mode .dashboard{
    grid-template-columns:1fr;
    gap:18px
  }
  
  body.reader-mode .card{
    padding:20px;
    background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));
    border-color:rgba(255,255,255,0.06)
  }

  /* ===== LOADING ANIMATIONS ===== */
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 0.8; }
    100% { opacity: 0.6; }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .card-loading {
    animation: pulse 1.5s infinite;
  }
  
  .card-loaded {
    animation: fadeIn 0.3s ease-out;
  }

  /* ===== CRITICAL FIXES ===== */
  .card iframe,
  .card canvas,
  .card video,
  .card img,
  .card table {
    max-width: 100%;
    display: block;
  }
  
  .card * {
    max-width: 100%;
    box-sizing: border-box;
  }
  
  .card textarea,
  .card input,
  .card select {
    max-width: 100%;
    box-sizing: border-box;
  }
  
  .card pre,
  .card code {
    white-space: pre-wrap;
    word-break: break-word;
    max-width: 100%;
    overflow-x: auto;
  }
  
  /* Loading indicator */
  .loading-indicator {
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 12px;
    color: var(--accent);
    z-index: 13000;
    backdrop-filter: blur(6px);
    display: none;
    align-items: center;
    gap: 8px;
  }
  
  .loading-indicator .spinner {
    width: 12px;
    height: 12px;
    border: 2px solid rgba(45,212,255,0.3);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* ===== MOBILE-FRIENDLY SCROLLING FIX ===== */
  @media (max-width: 768px) {
    .card {
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
      resize: none;
    }
    
    .card::after {
      display: none;
    }
    
    .dashboard {
      gap: 16px;
      padding: 16px;
      min-height: 600px;
    }
    
    .card-header h3 {
      padding: 4px 0;
      font-size: 1rem;
    }
    
    .search-bar input {
      font-size: 16px;
    }
    
    .card-expandable {
      max-height: 300px;
    }
    
    .controls {
      gap: 6px;
    }
    
    .controls button {
      padding: 6px 10px;
      font-size: 14px;
    }
    
    .loading-indicator {
      bottom: 60px;
      right: 10px;
      left: 10px;
      text-align: center;
      justify-content: center;
    }
  }
  
  /* Fix for very small screens */
  @media (max-width: 480px) {
    .dashboard {
      grid-template-columns: 1fr;
      padding: 12px;
      min-height: 500px;
    }
    
    .card {
      padding: 12px;
    }
    
    .control-btn {
      width: 44px;
      height: 44px;
      bottom: 12px;
    }
    
    #toolboxToggle { left: 12px; }
    #paletteToggle { left: 66px; }
    #readerToggle { left: 120px; }
  }
</style>
</head>
<body>

  <button id="toolboxToggle" class="control-btn" title="Open toolbox">ðŸ§°</button>
  <button id="paletteToggle" class="control-btn" title="Theme">ðŸŽ¨</button>
  <button id="readerToggle" class="control-btn" title="Reader mode">ðŸ‘“</button>

  <!-- Loading indicator -->
  <div id="loadingIndicator" class="loading-indicator">
    <div class="spinner"></div>
    <span id="loadingText">Loading cards...</span>
  </div>

  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px">Accent color</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#00ff99" style="background:#00ff99;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd;height:34px;border-radius:8px;cursor:pointer"></div>
    </div>
    
    <!-- SIMPLIFIED BACKGROUND THEMES - DIRECT COLOR VALUES -->
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px;margin-top:12px">Background theme</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <button class="theme-btn active" data-color="default" style="background:linear-gradient(135deg, #0a0f14, #141e28);height:34px;border-radius:8px;cursor:pointer;border:2px solid var(--accent)"></button>
      <button class="theme-btn" data-color="deep-blue" style="background:linear-gradient(135deg, #05080c, #0f151f);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-purple" style="background:linear-gradient(135deg, #12081a, #1f1229);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-teal" style="background:linear-gradient(135deg, #061616, #0f2525);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-red" style="background:linear-gradient(135deg, #160606, #251010);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
    </div>
  </div>

  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div style="font-weight:600;color:var(--accent)">Toolbox</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="dockBtn" title="Dock/undock" style="background:transparent;border:0;color:var(--muted);cursor:pointer">â‡±</button>
        <button id="toolboxClose" title="Close" style="background:transparent;border:0;color:var(--muted);cursor:pointer">âœ•</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite"></div>
  </div>

  <header><h1>The Most Useful Site in the World</h1></header>

  <main>
    <div class="search-bar"><input id="searchInput" placeholder="Search cards..." autofocus /></div>

    <div class="controls">
      <button id="sortAlphaBtn">Sort Aâ†’Z</button>
      <button id="sortRandomBtn">Random</button>
      <button id="autoSizeAllBtn" title="Set all cards to auto-height">Auto Height</button>
      <button id="resetCardSizesBtn" title="Reset all card sizes">Reset Sizes</button>
    </div>

    <div id="status" class="muted" style="text-align:center;margin-bottom:6px">Loading card list...</div>
    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
    
    <!-- Infinite scroll sentinel -->
    <div id="scrollSentinel" style="height:1px;margin-top:20px;"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
// ===== ENHANCED CARD DISPLAY SYSTEM =====
// Cards now support: auto-height, manual resizing, expand/collapse, and size persistence

console.log("=== STARTING ENHANCED CARD SYSTEM ===");

// Configuration
const LAZY_LOAD_CONFIG = {
  VISIBLE_BUFFER: 12,
  MAX_LOADED_CARDS: 40,
  BATCH_SIZE: 6,
  BATCH_DELAY: 100,
  UNLOAD_DISTANCE: 5,
  SEARCH_LOAD_ALL: true,
  DEBOUNCE_SCROLL: 100,
  THROTTLE_OBSERVER: 50,
  CACHE_SIZE: 20,
};

// Global state for lazy loading
const lazyState = {
  allCardFiles: [],
  loadedCards: new Set(),
  cardCache: new Map(),
  cardPositions: new Map(),
  isLoading: false,
  isSearching: false,
  currentViewportRange: { start: 0, end: 0 },
  scrollObserver: null,
  visibleCards: new Set(),
  placeholderCount: 0
};

// Card resize state
const cardResizeState = {
  isResizing: false,
  currentCard: null,
  startHeight: 0,
  startY: 0,
  minHeight: 120,
  maxHeight: 800
};

// Background themes
const themes = {
  'default': { bg1: '#0a0f14', bg2: '#141e28' },
  'deep-blue': { bg1: '#05080c', bg2: '#0f151f' },
  'deep-purple': { bg1: '#12081a', bg2: '#1f1229' },
  'deep-teal': { bg1: '#061616', bg2: '#0f2525' },
  'deep-red': { bg1: '#160606', bg2: '#251010' }
};

// ===== THEME SYSTEM =====
function applyTheme(themeName) {
  console.log("Applying theme:", themeName);
  const theme = themes[themeName];
  if (!theme) return;
  
  const gradient = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
  document.documentElement.style.background = gradient;
  document.body.style.background = gradient;
  
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === themeName) {
      btn.style.background = gradient;
    }
  });
  
  localStorage.setItem('theme', themeName);
}

// ===== CARD RESIZE SYSTEM =====
function initCardResizeSystem() {
  console.log("Initializing card resize system...");
  
  // Mouse events for desktop
  document.addEventListener('mousedown', handleCardResizeStart);
  document.addEventListener('mousemove', handleCardResizeMove);
  document.addEventListener('mouseup', handleCardResizeEnd);
  
  // Touch events for mobile
  document.addEventListener('touchstart', handleCardResizeStartTouch, { passive: true });
  document.addEventListener('touchmove', handleCardResizeMoveTouch, { passive: false });
  document.addEventListener('touchend', handleCardResizeEnd);
  
  // Initialize existing cards
  initializeCardsAutoHeight();
}

function handleCardResizeStart(e) {
  const card = e.target.closest('.card');
  if (!card || card.classList.contains('card-auto-size')) return;
  
  const rect = card.getBoundingClientRect();
  const isNearBottom = e.clientY > rect.bottom - 20 && e.clientY < rect.bottom;
  
  if (isNearBottom) {
    e.preventDefault();
    cardResizeState.isResizing = true;
    cardResizeState.currentCard = card;
    cardResizeState.startHeight = card.offsetHeight;
    cardResizeState.startY = e.clientY;
    
    card.classList.add('card-resizing');
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
  }
}

function handleCardResizeStartTouch(e) {
  if (e.touches.length !== 1) return;
  
  const touch = e.touches[0];
  const card = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.card');
  if (!card || card.classList.contains('card-auto-size')) return;
  
  const rect = card.getBoundingClientRect();
  const isNearBottom = touch.clientY > rect.bottom - 30 && touch.clientY < rect.bottom;
  
  if (isNearBottom) {
    cardResizeState.isResizing = true;
    cardResizeState.currentCard = card;
    cardResizeState.startHeight = card.offsetHeight;
    cardResizeState.startY = touch.clientY;
    
    card.classList.add('card-resizing');
    document.body.style.userSelect = 'none';
  }
}

function handleCardResizeMove(e) {
  if (!cardResizeState.isResizing || !cardResizeState.currentCard) return;
  
  e.preventDefault();
  
  const deltaY = e.clientY - cardResizeState.startY;
  let newHeight = cardResizeState.startHeight + deltaY;
  
  newHeight = Math.max(cardResizeState.minHeight, Math.min(cardResizeState.maxHeight, newHeight));
  
  cardResizeState.currentCard.style.height = newHeight + 'px';
  
  const indicator = cardResizeState.currentCard.querySelector('.card-size-indicator');
  if (indicator) {
    indicator.textContent = `${newHeight}px`;
  }
}

function handleCardResizeMoveTouch(e) {
  if (!cardResizeState.isResizing || !cardResizeState.currentCard || e.touches.length !== 1) return;
  
  e.preventDefault();
  
  const touch = e.touches[0];
  const deltaY = touch.clientY - cardResizeState.startY;
  let newHeight = cardResizeState.startHeight + deltaY;
  
  newHeight = Math.max(cardResizeState.minHeight, Math.min(cardResizeState.maxHeight, newHeight));
  
  cardResizeState.currentCard.style.height = newHeight + 'px';
  
  const indicator = cardResizeState.currentCard.querySelector('.card-size-indicator');
  if (indicator) {
    indicator.textContent = `${newHeight}px`;
  }
}

function handleCardResizeEnd() {
  if (!cardResizeState.isResizing || !cardResizeState.currentCard) return;
  
  const card = cardResizeState.currentCard;
  const height = card.offsetHeight;
  
  card.dataset.savedHeight = height;
  localStorage.setItem(`card-height-${card.dataset.name}`, height);
  
  card.classList.remove('card-resizing');
  cardResizeState.isResizing = false;
  cardResizeState.currentCard = null;
  
  document.body.style.cursor = '';
  document.body.style.userSelect = '';
}

// ===== CARD AUTO-HEIGHT SYSTEM =====
function initializeCardsAutoHeight() {
  document.querySelectorAll('.card').forEach(card => {
    setupCardAutoHeight(card);
  });
}

function setupCardAutoHeight(card) {
  const contentDiv = card.querySelector('.content');
  if (!contentDiv) return;
  
  // Check if already enhanced
  if (contentDiv.querySelector('.card-content-wrapper')) return;
  
  const originalHTML = contentDiv.innerHTML;
  contentDiv.innerHTML = '';
  
  const wrapper = document.createElement('div');
  wrapper.className = 'card-content-wrapper';
  
  const inner = document.createElement('div');
  inner.className = 'card-inner';
  
  const expandable = document.createElement('div');
  expandable.className = 'card-expandable';
  expandable.innerHTML = originalHTML;
  
  // Add size indicator
  const sizeIndicator = document.createElement('div');
  sizeIndicator.className = 'card-size-indicator';
  sizeIndicator.textContent = 'Auto';
  
  inner.appendChild(expandable);
  inner.appendChild(sizeIndicator);
  wrapper.appendChild(inner);
  contentDiv.appendChild(wrapper);
  
  // Add double-click for auto-size toggle
  card.addEventListener('dblclick', function(e) {
    if (e.target.closest('button, input, textarea, select')) return;
    toggleCardAutoSize(card);
  });
  
  // Load saved state
  loadCardSavedState(card);
}

function toggleCardAutoSize(card) {
  card.classList.toggle('card-auto-size');
  
  const indicator = card.querySelector('.card-size-indicator');
  if (indicator) {
    if (card.classList.contains('card-auto-size')) {
      indicator.textContent = 'Auto';
      card.style.height = 'auto';
      localStorage.setItem(`card-auto-${card.dataset.name}`, 'true');
    } else {
      indicator.textContent = `${card.offsetHeight}px`;
      card.dataset.savedHeight = card.offsetHeight;
      localStorage.setItem(`card-height-${card.dataset.name}`, card.offsetHeight);
      localStorage.removeItem(`card-auto-${card.dataset.name}`);
    }
  }
}

function loadCardSavedState(card) {
  const cardName = card.dataset.name;
  if (!cardName) return;
  
  const autoSize = localStorage.getItem(`card-auto-${cardName}`);
  if (autoSize === 'true') {
    card.classList.add('card-auto-size');
    card.style.height = 'auto';
  } else {
    const savedHeight = localStorage.getItem(`card-height-${cardName}`);
    if (savedHeight) {
      card.style.height = savedHeight + 'px';
      card.dataset.savedHeight = savedHeight;
      const indicator = card.querySelector('.card-size-indicator');
      if (indicator) indicator.textContent = `${savedHeight}px`;
    }
  }
}

// ===== EMBED SYSTEM =====
function addEmbedSectionToCard(card, fileName) {
  const cardName = fileName.replace('.html', '');
  const displayName = cardName.replace(/-/g, ' ');
  
  const embedHTML = `
    <div class="embed-section">
      <span>Share this tool:</span>
      <button class="embed-btn" data-card="${cardName}" data-file="${fileName}">
        ðŸ”— Copy Embed Code
      </button>
    </div>
  `;
  
  const contentDiv = card.querySelector('.content .card-expandable') || card.querySelector('.content');
  if (contentDiv) {
    contentDiv.insertAdjacentHTML('beforeend', embedHTML);
    
    const embedBtn = contentDiv.querySelector('.embed-btn');
    if (embedBtn) {
      embedBtn.addEventListener('click', function() {
        copyEmbedCode(cardName, fileName, displayName);
      });
    }
  }
}

function copyEmbedCode(cardName, fileName, displayName) {
  const embedCode = `<iframe src="https://mrpr0phecy.github.io/mrpr0phecy/cards/${fileName}" width="100%" height="400" style="border:none;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);" title="${displayName} - The Most Useful Site"></iframe>`;
  
  navigator.clipboard.writeText(embedCode).then(() => {
    const embedBtn = document.querySelector(`.embed-btn[data-card="${cardName}"]`);
    if (embedBtn) {
      const originalText = embedBtn.textContent;
      embedBtn.textContent = 'âœ… Copied!';
      embedBtn.classList.add('copied');
      
      setTimeout(() => {
        embedBtn.textContent = originalText;
        embedBtn.classList.remove('copied');
      }, 2000);
    }
  }).catch(err => {
    console.error('Failed to copy: ', err);
    const textArea = document.createElement('textarea');
    textArea.value = embedCode;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
    } catch (e) {}
    document.body.removeChild(textArea);
  });
}

// ===== LAZY LOADING SYSTEM =====
function calculateVisibleRange() {
  const grid = document.getElementById('gridContainer');
  if (!grid || !grid.children.length) return { start: 0, end: 0 };
  
  const cards = Array.from(grid.children);
  const viewportHeight = window.innerHeight;
  
  let firstVisible = 0;
  let lastVisible = cards.length - 1;
  
  for (let i = 0; i < cards.length; i++) {
    const rect = cards[i].getBoundingClientRect();
    if (rect.bottom > 0 && rect.top < viewportHeight) {
      firstVisible = i;
      break;
    }
  }
  
  for (let i = cards.length - 1; i >= 0; i--) {
    const rect = cards[i].getBoundingClientRect();
    if (rect.bottom > 0 && rect.top < viewportHeight) {
      lastVisible = i;
      break;
    }
  }
  
  const buffer = LAZY_LOAD_CONFIG.VISIBLE_BUFFER;
  const start = Math.max(0, firstVisible - buffer);
  const end = Math.min(cards.length - 1, lastVisible + buffer);
  
  return { start, end };
}

function updateVisibleCards() {
  const range = calculateVisibleRange();
  lazyState.currentViewportRange = range;
  
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  lazyState.visibleCards.clear();
  for (let i = range.start; i <= range.end && i < cards.length; i++) {
    const card = cards[i];
    if (card.dataset.name) {
      lazyState.visibleCards.add(card.dataset.name);
    }
  }
  
  scheduleLazyLoad(range);
}

function scheduleLazyLoad(range) {
  if (lazyState.isLoading || lazyState.isSearching) return;
  
  const cardsToLoad = [];
  const cardsToUnload = [];
  
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const cardName = card.dataset.name;
    
    if (!cardName) continue;
    
    const isInRange = i >= range.start && i <= range.end;
    const isLoaded = lazyState.loadedCards.has(cardName);
    const isLoading = card.classList.contains('loading');
    
    if (isInRange && !isLoaded && !isLoading) {
      cardsToLoad.push({ index: i, name: cardName, element: card });
    }
    
    const isFarAway = i < range.start - LAZY_LOAD_CONFIG.UNLOAD_DISTANCE || 
                     i > range.end + LAZY_LOAD_CONFIG.UNLOAD_DISTANCE;
    if (isFarAway && isLoaded) {
      cardsToUnload.push({ index: i, name: cardName, element: card });
    }
  }
  
  const loadingBatch = cardsToLoad.slice(0, LAZY_LOAD_CONFIG.BATCH_SIZE);
  
  unloadCards(cardsToUnload);
  
  if (loadingBatch.length > 0) {
    lazyState.isLoading = true;
    showLoadingIndicator(`Loading ${loadingBatch.length} cards...`);
    
    loadingBatch.forEach((card, idx) => {
      setTimeout(() => {
        loadCardContent(card.name, card.element, idx === loadingBatch.length - 1);
      }, idx * LAZY_LOAD_CONFIG.BATCH_DELAY);
    });
  } else {
    hideLoadingIndicator();
  }
}

function loadCardContent(cardName, cardElement, isLastInBatch = false) {
  if (!cardElement) return;
  
  const contentDiv = cardElement.querySelector('.content');
  if (!contentDiv) return;
  
  cardElement.classList.add('loading');
  contentDiv.innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.6)">Loading...</div>';
  
  if (lazyState.cardCache.has(cardName)) {
    const cachedHTML = lazyState.cardCache.get(cardName);
    processLoadedCard(cardName, cardElement, cachedHTML, isLastInBatch, true);
    return;
  }
  
  fetch(`cards/${cardName}.html`)
    .then(r => r.ok ? r.text() : Promise.reject())
    .then(html => {
      lazyState.cardCache.set(cardName, html);
      processLoadedCard(cardName, cardElement, html, isLastInBatch, false);
    })
    .catch(() => {
      contentDiv.textContent = 'Preview unavailable';
      cardElement.classList.remove('loading');
      lazyState.loadedCards.add(cardName);
      
      if (isLastInBatch) {
        lazyState.isLoading = false;
        hideLoadingIndicator();
      }
    });
}

function processLoadedCard(cardName, cardElement, html, isLastInBatch, fromCache) {
  const contentDiv = cardElement.querySelector('.content');
  
  // Load content
  contentDiv.innerHTML = html;
  
  // Setup enhanced card features
  setupCardAutoHeight(cardElement);
  
  // Add embed section
  addEmbedSectionToCard(cardElement, `${cardName}.html`);
  
  // Execute scripts
  const scripts = contentDiv.querySelectorAll('script');
  scripts.forEach(script => {
    const newScript = document.createElement('script');
    if (script.src) {
      newScript.src = script.src;
    } else {
      newScript.textContent = script.textContent;
    }
    [...script.attributes].forEach(attr => {
      newScript.setAttribute(attr.name, attr.value);
    });
    script.parentNode.replaceChild(newScript, script);
  });
  
  // Mark as loaded
  lazyState.loadedCards.add(cardName);
  cardElement.classList.remove('loading');
  cardElement.classList.add('loaded', 'visible');
  
  updateStatusText();
  
  if (isLastInBatch) {
    lazyState.isLoading = false;
    hideLoadingIndicator();
    cleanupCardCache();
  }
}

function unloadCards(cardsToUnload) {
  if (lazyState.loadedCards.size <= LAZY_LOAD_CONFIG.MAX_LOADED_CARDS) return;
  
  cardsToUnload.forEach(({ name, element }) => {
    if (lazyState.loadedCards.has(name) && !lazyState.visibleCards.has(name)) {
      const contentDiv = element.querySelector('.content');
      if (contentDiv) {
        contentDiv.innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.4)">Card unloaded (scroll to load)</div>';
      }
      
      lazyState.loadedCards.delete(name);
      element.classList.remove('loaded', 'visible');
    }
  });
}

function cleanupCardCache() {
  if (lazyState.cardCache.size <= LAZY_LOAD_CONFIG.CACHE_SIZE) return;
  
  const cacheEntries = Array.from(lazyState.cardCache.entries());
  const toRemove = cacheEntries
    .filter(([name]) => !lazyState.loadedCards.has(name) && !lazyState.visibleCards.has(name))
    .slice(0, lazyState.cardCache.size - LAZY_LOAD_CONFIG.CACHE_SIZE);
  
  toRemove.forEach(([name]) => {
    lazyState.cardCache.delete(name);
  });
}

function showLoadingIndicator(text = 'Loading...') {
  const indicator = document.getElementById('loadingIndicator');
  const textElement = document.getElementById('loadingText');
  
  if (indicator && textElement) {
    textElement.textContent = text;
    indicator.style.display = 'flex';
  }
}

function hideLoadingIndicator() {
  const indicator = document.getElementById('loadingIndicator');
  if (indicator) {
    indicator.style.display = 'none';
  }
}

function updateStatusText() {
  const status = document.getElementById('status');
  if (!status) return;
  
  const total = lazyState.allCardFiles.length;
  const loaded = lazyState.loadedCards.size;
  const visible = lazyState.visibleCards.size;
  
  if (lazyState.isSearching) {
    status.textContent = `Search results: ${visible} cards`;
  } else {
    status.textContent = `${loaded} of ${total} cards loaded (${visible} visible)`;
  }
}

// ===== TOOLBOX WIDGET MANAGEMENT =====
let widgets = [];
let toolboxDocked = false;

function initToolbox() {
  const toolbox = document.getElementById('toolbox');
  const toolboxTitle = document.getElementById('toolboxTitle');
  
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  toolboxTitle.addEventListener('mousedown', startDrag);
  
  function startDrag(e) {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = toolbox.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = 'grabbing';
  }
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    toolbox.style.left = 'auto';
    toolbox.style.right = 'auto';
    toolbox.style.top = e.clientY - dragOffset.y + 'px';
    toolbox.style.left = e.clientX - dragOffset.x + 'px';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = '';
  }
  
  document.getElementById('dockBtn').addEventListener('click', function() {
    toolboxDocked = !toolboxDocked;
    
    if (toolboxDocked) {
      toolbox.style.left = 'auto';
      toolbox.style.right = '18px';
      toolbox.style.top = 'auto';
      toolbox.style.bottom = '18px';
      this.textContent = 'â‡²';
    } else {
      this.textContent = 'â‡±';
    }
  });
  
  loadSavedWidgets();
}

function createWidget(name, contentHTML) {
  const widgetId = 'widget-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  const widget = document.createElement('div');
  widget.className = 'widget-wrap';
  widget.id = widgetId;
  widget.dataset.name = name;
  
  const toolboxContent = document.getElementById('toolboxContent');
  const tRect = toolboxContent.getBoundingClientRect();
  
  widget.style.left = Math.random() * (tRect.width - 200) + 'px';
  widget.style.top = Math.random() * (tRect.height - 150) + 'px';
  widget.style.width = '200px';
  widget.style.height = '150px';
  
  widget.innerHTML = `
    <div class="widget-titlebar">
      <strong>${name}</strong>
      <button class="widget-close" title="Close widget">âœ•</button>
    </div>
    <div class="widget-body">${contentHTML}</div>
  `;
  
  toolboxContent.appendChild(widget);
  
  widgets.push({
    id: widgetId,
    name: name,
    content: contentHTML,
    x: widget.style.left,
    y: widget.style.top,
    width: widget.style.width,
    height: widget.style.height
  });
  
  saveWidgets();
  
  return widgetId;
}

function saveWidgets() {
  localStorage.setItem('toolboxWidgets', JSON.stringify(widgets));
}

function loadSavedWidgets() {
  const saved = localStorage.getItem('toolboxWidgets');
  if (saved) {
    try {
      widgets = JSON.parse(saved) || [];
    } catch (e) {
      console.error('Failed to load widgets:', e);
      widgets = [];
    }
  }
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
  console.log("DOM ready");
  
  // Scroll to top
  window.scrollTo(0, 0);
  
  // Apply saved theme
  const savedTheme = localStorage.getItem('theme') || 'default';
  applyTheme(savedTheme);
  
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === savedTheme) {
      btn.classList.add('active');
      btn.style.border = '2px solid var(--accent)';
    } else {
      btn.classList.remove('active');
      btn.style.border = '1px solid var(--border)';
    }
  });
  
  // Apply saved accent
  const savedAccent = localStorage.getItem('accent') || '#2dd4ff';
  document.documentElement.style.setProperty('--accent', savedAccent);
  document.querySelectorAll('.palette-color').forEach(c => {
    c.classList.toggle('active', c.dataset.accent === savedAccent);
  });
  
  // Apply reader mode
  if(localStorage.getItem('readerMode') === 'on') {
    document.body.classList.add('reader-mode');
  }
  
  // Initialize systems
  initToolbox();
  initCardResizeSystem();
  
  // Load dashboard
  loadDashboard();
});

// Scroll to search bar on load
window.addEventListener('load', function() {
  setTimeout(() => {
    const searchBar = document.querySelector('.search-bar');
    if (searchBar) {
      searchBar.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.focus();
    }
  }, 100);
});

window.addEventListener('beforeunload', function() {
  window.scrollTo(0, 0);
});

// ===== UI CONTROLS =====
document.getElementById('paletteToggle').addEventListener('click', function() {
  const panel = document.getElementById('palettePanel');
  panel.classList.toggle('open');
});

document.querySelectorAll('.palette-color').forEach(c => {
  c.addEventListener('click', function() {
    document.querySelectorAll('.palette-color').forEach(x => x.classList.remove('active'));
    this.classList.add('active');
    const col = this.dataset.accent;
    document.documentElement.style.setProperty('--accent', col);
    localStorage.setItem('accent', col);
  });
});

document.querySelectorAll('.theme-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.theme-btn').forEach(b => {
      b.classList.remove('active');
      b.style.border = '1px solid var(--border)';
    });
    this.classList.add('active');
    this.style.border = '2px solid var(--accent)';
    
    const themeName = this.dataset.color;
    applyTheme(themeName);
  });
});

const toolbox = document.getElementById('toolbox');
document.getElementById('toolboxToggle').addEventListener('click', function() {
  toolbox.classList.toggle('hidden');
});
document.getElementById('toolboxClose').addEventListener('click', function(e) {
  e.stopPropagation();
  toolbox.classList.add('hidden');
});

document.getElementById('readerToggle').addEventListener('click', function() {
  document.body.classList.toggle('reader-mode');
  localStorage.setItem('readerMode', document.body.classList.contains('reader-mode') ? 'on' : 'off');
});

// ===== SEARCH =====
const searchInput = document.getElementById('searchInput');
let searchTimeout = null;

searchInput.addEventListener('input', function(e) {
  const q = e.target.value.toLowerCase().trim();
  
  if (searchTimeout) clearTimeout(searchTimeout);
  
  searchTimeout = setTimeout(() => {
    lazyState.isSearching = q.length > 0;
    
    if (lazyState.isSearching) {
      performSearch(q);
    } else {
      document.querySelectorAll('.card').forEach(card => {
        card.style.display = '';
      });
      updateVisibleCards();
    }
  }, 300);
});

function performSearch(query) {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  let visibleCount = 0;
  
  cards.forEach(card => {
    const name = card.dataset.name.toLowerCase();
    const text = card.textContent.toLowerCase();
    const matches = name.includes(query) || text.includes(query);
    
    card.style.display = matches ? '' : 'none';
    
    if (matches) {
      visibleCount++;
      
      if (!lazyState.loadedCards.has(card.dataset.name)) {
        loadCardContent(card.dataset.name, card, false);
      }
    }
  });
  
  updateStatusText();
}

// ===== SORT BUTTONS =====
document.getElementById('sortAlphaBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  cards.sort((a,b) => a.dataset.name.localeCompare(b.dataset.name));
  cards.forEach(card => grid.appendChild(card));
  
  updateCardPositions();
  updateVisibleCards();
});

document.getElementById('sortRandomBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  for (let i = cards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [cards[i], cards[j]] = [cards[j], cards[i]];
  }
  cards.forEach(card => grid.appendChild(card));
  
  updateCardPositions();
  updateVisibleCards();
});

// ===== CARD SIZE CONTROLS =====
document.getElementById('autoSizeAllBtn').addEventListener('click', function() {
  document.querySelectorAll('.card').forEach(card => {
    card.classList.add('card-auto-size');
    card.style.height = 'auto';
    localStorage.setItem(`card-auto-${card.dataset.name}`, 'true');
    
    const indicator = card.querySelector('.card-size-indicator');
    if (indicator) indicator.textContent = 'Auto';
  });
});

document.getElementById('resetCardSizesBtn').addEventListener('click', function() {
  document.querySelectorAll('.card').forEach(card => {
    card.classList.remove('card-auto-size', 'card-expanded');
    card.style.height = '';
    card.dataset.savedHeight = '';
    
    localStorage.removeItem(`card-auto-${card.dataset.name}`);
    localStorage.removeItem(`card-height-${card.dataset.name}`);
    
    const indicator = card.querySelector('.card-size-indicator');
    if (indicator) indicator.textContent = 'Auto';
  });
});

// ===== LOAD DASHBOARD =====
async function loadDashboard() {
  try {
    const DEFAULT_REPO = 'mrpr0phecy/mrpr0phecy';
    const DEFAULT_BRANCH = 'main';
    
    const [owner, repo] = DEFAULT_REPO.split('/');
    
    document.getElementById('status').textContent = 'Fetching card list...';
    showLoadingIndicator('Loading card list...');
    
    const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${DEFAULT_BRANCH}?recursive=1`;
    const response = await fetch(url);
    const data = await response.json();
    
    lazyState.allCardFiles = (data.tree || [])
      .filter(item => item.path.startsWith('cards/') && item.path.endsWith('.html'))
      .map(item => item.path.replace(/^cards\//, '').replace('.html', ''))
      .sort();
    
    console.log(`Found ${lazyState.allCardFiles.length} cards`);
    
    const grid = document.getElementById('gridContainer');
    grid.innerHTML = '';
    
    lazyState.allCardFiles.forEach((cardName, index) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.name = cardName;
      card.dataset.index = index;
      
      const header = document.createElement('div');
      header.className = 'card-header';
      header.innerHTML = `<h3>${cardName.replace(/-/g, ' ')}</h3>
        <div style="display:flex;gap:8px">
          <div class="add-to-toolbox" title="Add to toolbox" style="cursor:pointer;font-weight:bold;color:var(--accent);font-size:18px;line-height:1">+</div>
        </div>`;
      
      const content = document.createElement('div');
      content.className = 'content';
      content.innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.4)">Click or scroll to load card...</div>';
      
      card.appendChild(header);
      card.appendChild(content);
      grid.appendChild(card);
      
      lazyState.cardPositions.set(cardName, index);
    });
    
    updateStatusText();
    hideLoadingIndicator();
    
    initScrollObserver();
    
    setTimeout(() => {
      updateVisibleCards();
    }, 100);
    
  } catch (error) {
    console.error("Error loading dashboard:", error);
    document.getElementById('status').textContent = 'Error loading cards';
    hideLoadingIndicator();
  }
}

function initScrollObserver() {
  let scrollTimeout = null;
  
  window.addEventListener('scroll', () => {
    if (scrollTimeout) clearTimeout(scrollTimeout);
    
    scrollTimeout = setTimeout(() => {
      if (!lazyState.isSearching) {
        updateVisibleCards();
      }
    }, LAZY_LOAD_CONFIG.DEBOUNCE_SCROLL);
  }, { passive: true });
  
  window.addEventListener('resize', () => {
    if (!lazyState.isSearching) {
      updateVisibleCards();
    }
  }, { passive: true });
  
  document.addEventListener('click', function(e) {
    const card = e.target.closest('.card');
    if (card && !card.classList.contains('loaded')) {
      const cardName = card.dataset.name;
      if (cardName && !lazyState.loadedCards.has(cardName)) {
        loadCardContent(cardName, card, true);
      }
    }
  });
}

// ===== ADD TO TOOLBOX =====
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('add-to-toolbox') || 
      e.target.closest('.add-to-toolbox')) {
    
    const card = e.target.closest('.card');
    if (!card) return;
    
    const cardName = card.dataset.name;
    const contentElement = card.querySelector('.content');
    const contentHTML = contentElement.innerHTML;
    
    if (!lazyState.loadedCards.has(cardName)) {
      alert('Please wait for the card to load before adding to toolbox');
      return;
    }
    
    createWidget(cardName, contentHTML);
    
    toolbox.classList.remove('hidden');
    
    const addBtn = e.target.closest('.add-to-toolbox');
    addBtn.textContent = 'âœ“';
    addBtn.style.color = 'var(--accent)';
    setTimeout(() => {
      addBtn.textContent = '+';
      addBtn.style.color = '';
    }, 1000);
  }
});

// ===== UTILITY FUNCTIONS =====
function updateCardPositions() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  lazyState.cardPositions.clear();
  cards.forEach((card, index) => {
    if (card.dataset.name) {
      lazyState.cardPositions.set(card.dataset.name, index);
    }
  });
}

// Make Sortable (disabled on main page)
new Sortable(document.getElementById('gridContainer'), {
  animation: 150,
  disabled: true
});

console.log("=== ENHANCED CARD SYSTEM INITIALIZED ===");
</script>
</body>
</html>
