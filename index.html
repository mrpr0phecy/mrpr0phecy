<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Most Useful Site in the World</title>
<style>
  /* DARK DEFAULTS DIRECTLY IN CSS - NO VARIABLES FOR BACKGROUND */
  html,body{
    height:100%;
    margin:0;
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial;
    background:linear-gradient(135deg, #0a0f14, #141e28); /* DARK DEFAULT */
    color:#e6faff;
    -webkit-font-smoothing:antialiased;
    /* FIX 1: Ensure background covers entire page */
    background-attachment: fixed;
    background-size: cover;
    /* NEW: Prevent card content from overflowing */
    overflow-x: hidden;
  }
  
  /* CSS VARIABLES ONLY FOR THINGS THAT CHANGE */
  :root{
    --accent:#2dd4ff; 
    --muted:#e6faff; 
    --text:#e6faff;
    --glass: rgba(255,255,255,0.06);
    --panel: rgba(20,20,20,0.92);
    --card-grad-1: rgba(255,255,255,0.02);
    --card-grad-2: rgba(255,255,255,0.04);
    --border: rgba(255,255,255,0.10);
    --card-min: 260px;
    --card-scale: 1;
    --card-translateY: 18px;
    --toolbox-width: 520px;
    --toolbox-height: 420px;
  }

  header{padding:20px;text-align:center;z-index:2}
  header h1{margin:0;color:var(--accent);font-size:1.6rem}

  .control-btn{
    position:fixed;bottom:18px;z-index:14000;width:48px;height:48px;border-radius:10px;
    background:var(--glass);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;
    cursor:pointer;backdrop-filter:blur(6px);box-shadow:0 8px 30px rgba(0,0,0,0.45);color:var(--accent);
  }
  .control-btn:hover{transform:scale(1.06)}
  #toolboxToggle{left:18px}
  #paletteToggle{left:78px}
  #readerToggle{left:138px}

  .palette-panel{
    position:fixed;left:78px;bottom:74px;z-index:13900;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:12px;box-shadow:0 12px 36px rgba(0,0,0,0.6);backdrop-filter:blur(8px);
    display:none;pointer-events:none;
  }
  .palette-panel.open{display:block;pointer-events:auto}

  .toolbox {
    position:fixed;
    right:18px;
    bottom:18px;
    width:var(--toolbox-width);
    height:var(--toolbox-height);
    z-index:13700;
    background:var(--panel);
    border:1px solid var(--border);
    border-radius:12px;
    box-shadow:0 18px 48px rgba(0,0,0,0.6);
    display:flex;
    flex-direction:column;
    overflow:hidden;
    resize:both;
    min-width:300px;
    min-height:200px;
  }
  .toolbox.hidden{display:none}

  .toolbox .titlebar{
    display:flex;align-items:center;justify-content:space-between;padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);cursor:grab;z-index:13750;
  }

  .toolbox .content{
    position:relative;
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    overflow:auto;
    min-height:100px;
  }

  .widget-wrap{
    position:absolute;
    box-sizing:border-box;
    background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
    border-radius:10px;border:1px solid rgba(255,255,255,0.04);
    min-width:120px; min-height:80px;
    max-width:calc(100% - 20px);
    max-height:calc(100% - 20px);
    overflow:hidden;
    resize:both;
    z-index:1;
    box-shadow:0 8px 20px rgba(0,0,0,0.35);
    /* NEW: Advanced font scaling with min/max sizes */
    --widget-font-size: 14px;
    --widget-font-scale: 1;
    --widget-min-font: 8px;
    --widget-max-font: 32px;
    --widget-ideal-area: 30000; /* 200x150 = 30000pxÂ² */
  }

  .widget-titlebar{
    display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    cursor:move;
    user-select:none;
  }
  .widget-titlebar strong{
    color:var(--accent);
    font-size: calc(var(--widget-font-size) * 1.1);
  }
  
  .widget-body{
    padding:10px;
    overflow:auto;
    max-height:60vh;
    font-size: var(--widget-font-size);
    line-height: calc(var(--widget-font-size) * 1.4);
  }

  .widget-close, #toolboxClose { 
    z-index: 13800; 
    position: relative; 
    background:transparent;
    border:0;
    color:var(--muted);
    cursor:pointer;
    font-size: var(--widget-font-size);
  }

  main{
    position:relative;
    z-index:2;
    /* FIX 1: Auto-scroll to top when loading */
    scroll-margin-top: 0;
  }
  
  .search-bar{
    max-width:1100px;
    margin:14px auto 16px;
    display:flex;
    background:linear-gradient(180deg,var(--glass),rgba(255,255,255,0.02));
    border-radius:12px;
    padding:12px 16px;
    border:1px solid rgba(255,255,255,0.04);
    /* FIX 1: Anchor point for scrolling */
    scroll-margin-top: 20px;
  }
  
  .search-bar input{flex:1;border:none;background:transparent;color:var(--text);font-size:1rem;outline:none}

  .controls{display:flex;gap:8px;justify-content:center;margin-bottom:12px}
  .controls button{padding:8px 12px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted);cursor:pointer}

  .dashboard{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
    gap:20px;
    padding:20px;
    align-items:start;
    box-sizing:border-box;
    /* NEW: Prevent grid from being too wide */
    max-width:100%;
    overflow:hidden;
    /* NEW: For lazy loading placeholder calculation */
    min-height: 800px;
    position: relative;
  }

  .card{
    box-sizing:border-box;
    background:linear-gradient(135deg,var(--card-grad-1),var(--card-grad-2));
    border:1px solid var(--border);
    border-radius:12px;
    padding:16px;
    min-height:120px;
    width:100%;
    max-width:100%;
    opacity:0;
    transform: translateY(var(--card-translateY)) scale(var(--card-scale));
    transition:opacity .36s ease, transform .36s ease;
    box-shadow:0 8px 24px rgba(0,0,0,0.35);
    overflow:hidden;
    /* NEW: Critical fix - isolate card content */
    position:relative;
    contain: content;
    /* NEW: Prevent card from breaking layout */
    word-wrap: break-word;
    overflow-wrap: break-word;
    /* NEW: Disable dragging on main page */
    cursor: default;
  }
  .card.visible{opacity:1; transform: translateY(0) scale(var(--card-scale));}
  
  /* NEW: Card skeleton for lazy loading */
  .card-skeleton {
    background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.04));
    border:1px solid rgba(255,255,255,0.04);
    border-radius:12px;
    padding:16px;
    min-height:120px;
    animation: pulse 1.5s infinite;
  }
  
  .card-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:10px;
    /* NEW: Make header non-draggable */
    cursor: default;
    user-select: none;
  }
  .card-header h3{
    margin:0;
    color:var(--accent);
    font-size:1.05rem;
    /* NEW: Prevent text overflow */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width:80%;
  }
  
  /* NEW: Card content container with scroll isolation */
  .card-content {
    position: relative;
    max-height: 400px;
    overflow-y: auto;
    overflow-x: hidden;
    padding-right: 4px;
    /* NEW: Isolate scrolling from parent */
    isolation: isolate;
  }
  
  /* NEW: Custom scrollbar for card content */
  .card-content::-webkit-scrollbar {
    width: 6px;
  }
  
  .card-content::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.03);
    border-radius: 3px;
  }
  
  .card-content::-webkit-scrollbar-thumb {
    background: var(--accent);
    border-radius: 3px;
    opacity: 0.5;
  }
  
  .card-content::-webkit-scrollbar-thumb:hover {
    opacity: 0.8;
  }

  /* ===== SIMPLE EMBED SECTION ===== */
  .embed-section {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.06);
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
  }
  
  .embed-section span {
    color: rgba(230,250,255,0.7);
    white-space: nowrap;
  }
  
  .embed-btn {
    background: rgba(45,212,255,0.1);
    color: var(--accent);
    border: 1px solid rgba(45,212,255,0.3);
    padding: 4px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  
  .embed-btn:hover {
    background: rgba(45,212,255,0.2);
    transform: translateY(-1px);
  }
  
  .embed-btn.copied {
    background: rgba(57,255,20,0.1);
    color: #39ff14;
    border-color: rgba(57,255,20,0.3);
  }

  body.reader-mode{font-size:1.12rem;line-height:1.6}
  body.reader-mode .dashboard{grid-template-columns:1fr;gap:18px}
  body.reader-mode .card{padding:20px;background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.04));border-color:rgba(255,255,255,0.06)}

  /* ===== LAZY LOADING ANIMATIONS ===== */
  @keyframes pulse {
    0% { opacity: 0.6; }
    50% { opacity: 0.8; }
    100% { opacity: 0.6; }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .card-loading {
    animation: pulse 1.5s infinite;
  }
  
  .card-loaded {
    animation: fadeIn 0.3s ease-out;
  }

  /* ===== CRITICAL FIXES ===== */
  
  /* NEW: Isolate card content to prevent layout breaking */
  .card iframe,
  .card canvas,
  .card video,
  .card img,
  .card table {
    max-width: 100%;
    display: block;
  }
  
  /* NEW: Fix for any card that might have overflowing content */
  .card * {
    max-width: 100%;
    box-sizing: border-box;
  }
  
  /* NEW: Prevent textareas and inputs from breaking layout */
  .card textarea,
  .card input,
  .card select {
    max-width: 100%;
    box-sizing: border-box;
  }
  
  /* NEW: Fix for pre/code blocks */
  .card pre,
  .card code {
    white-space: pre-wrap;
    word-break: break-word;
    max-width: 100%;
    overflow-x: auto;
  }
  
  /* NEW: Disable Sortable cursor on main page */
  .dashboard .sortable-chosen {
    cursor: default !important;
  }
  
  /* NEW: Only enable dragging in toolbox */
  .toolbox .sortable-chosen {
    cursor: move !important;
  }

  /* NEW: Loading indicator */
  .loading-indicator {
    position: fixed;
    bottom: 80px;
    right: 20px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 12px;
    color: var(--accent);
    z-index: 13000;
    backdrop-filter: blur(6px);
    display: none;
    align-items: center;
    gap: 8px;
  }
  
  .loading-indicator .spinner {
    width: 12px;
    height: 12px;
    border: 2px solid rgba(45,212,255,0.3);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* ===== MOBILE-FRIENDLY SCROLLING FIX ===== */
  @media (max-width: 768px) {
    .card {
      touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
    }
    
    .dashboard {
      gap: 16px;
      padding: 16px;
      min-height: 600px;
    }
    
    .card-header h3 {
      padding: 4px 0;
      font-size: 1rem;
    }
    
    .search-bar input {
      font-size: 16px;
    }
    
    .card-content {
      max-height: 300px;
    }
    
    .loading-indicator {
      bottom: 60px;
      right: 10px;
      left: 10px;
      text-align: center;
      justify-content: center;
    }
  }
  
  /* NEW: Fix for very small screens */
  @media (max-width: 480px) {
    .dashboard {
      grid-template-columns: 1fr;
      padding: 12px;
      min-height: 500px;
    }
    
    .card {
      padding: 12px;
    }
  }
</style>
</head>
<body>

  <button id="toolboxToggle" class="control-btn" title="Open toolbox">ðŸ§°</button>
  <button id="paletteToggle" class="control-btn" title="Theme">ðŸŽ¨</button>
  <button id="readerToggle" class="control-btn" title="Reader mode">ðŸ‘“</button>

  <!-- NEW: Loading indicator -->
  <div id="loadingIndicator" class="loading-indicator">
    <div class="spinner"></div>
    <span id="loadingText">Loading cards...</span>
  </div>

  <div id="palettePanel" class="palette-panel" aria-hidden="true">
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px">Accent color</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <div class="palette-color active" data-accent="#2dd4ff" style="background:#2dd4ff;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ff2d55" style="background:#ff2d55;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#00ff99" style="background:#00ff99;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#ffcc00" style="background:#ffcc00;height:34px;border-radius:8px;cursor:pointer"></div>
      <div class="palette-color" data-accent="#9d4edd" style="background:#9d4edd;height:34px;border-radius:8px;cursor:pointer"></div>
    </div>
    
    <!-- SIMPLIFIED BACKGROUND THEMES - DIRECT COLOR VALUES -->
    <div style="color:var(--accent);font-weight:600;margin-bottom:8px;margin-top:12px">Background theme</div>
    <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px">
      <button class="theme-btn active" data-color="default" style="background:linear-gradient(135deg, #0a0f14, #141e28);height:34px;border-radius:8px;cursor:pointer;border:2px solid var(--accent)"></button>
      <button class="theme-btn" data-color="deep-blue" style="background:linear-gradient(135deg, #05080c, #0f151f);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-purple" style="background:linear-gradient(135deg, #12081a, #1f1229);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-teal" style="background:linear-gradient(135deg, #061616, #0f2525);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
      <button class="theme-btn" data-color="deep-red" style="background:linear-gradient(135deg, #160606, #251010);height:34px;border-radius:8px;cursor:pointer;border:1px solid var(--border)"></button>
    </div>
  </div>

  <div id="toolbox" class="toolbox hidden" role="dialog" aria-hidden="true">
    <div class="titlebar" id="toolboxTitle">
      <div style="font-weight:600;color:var(--accent)">Toolbox</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="dockBtn" title="Dock/undock" style="background:transparent;border:0;color:var(--muted);cursor:pointer">â‡±</button>
        <button id="toolboxClose" title="Close" style="background:transparent;border:0;color:var(--muted);cursor:pointer">âœ•</button>
      </div>
    </div>
    <div class="content" id="toolboxContent" aria-live="polite"></div>
  </div>

  <header><h1>The Most Useful Site in the World</h1></header>

  <main>
    <div class="search-bar"><input id="searchInput" placeholder="Search cards..." autofocus /></div>

    <div class="controls">
      <button id="sortAlphaBtn">Sort Aâ†’Z</button>
      <button id="sortRandomBtn">Random</button>
      <button id="loadMoreBtn" style="display:none">Load More Cards</button>
    </div>

    <div id="status" class="muted" style="text-align:center;margin-bottom:6px">Loading card list...</div>
    <div id="gridContainer" class="dashboard" aria-live="polite"></div>
    
    <!-- NEW: Infinite scroll sentinel -->
    <div id="scrollSentinel" style="height:1px;margin-top:20px;"></div>
  </main>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
// ===== CLEVER LAZY LOADING SYSTEM =====
// Loads only cards in visible area + buffer (max ~40 cards)
// Unloads cards that are far away to save memory
// Smart loading based on scroll position and viewport

console.log("=== STARTING APP WITH LAZY LOADING ===");

// Configuration
const LAZY_LOAD_CONFIG = {
  // How many cards to load around visible area
  VISIBLE_BUFFER: 12, // Cards to load around current viewport
  MAX_LOADED_CARDS: 40, // Maximum cards loaded at once
  BATCH_SIZE: 6, // Cards to load per batch
  BATCH_DELAY: 100, // Delay between batches (ms)
  UNLOAD_DISTANCE: 5, // Cards away from viewport to unload
  SEARCH_LOAD_ALL: true, // Load all cards when searching
  
  // Performance settings
  DEBOUNCE_SCROLL: 100, // Scroll event debounce (ms)
  THROTTLE_OBSERVER: 50, // Intersection observer throttle (ms)
  CACHE_SIZE: 20, // Number of cards to keep cached
};

// Global state for lazy loading
const lazyState = {
  allCardFiles: [], // All available card files
  loadedCards: new Set(), // Set of currently loaded card names
  cardCache: new Map(), // Cache of loaded card HTML content
  cardPositions: new Map(), // Map of card positions in grid
  isLoading: false,
  isSearching: false,
  currentViewportRange: { start: 0, end: 0 },
  scrollObserver: null,
  visibleCards: new Set(),
  placeholderCount: 0
};

// Background themes - SIMPLE OBJECT MAPPING
const themes = {
  'default': { bg1: '#0a0f14', bg2: '#141e28' },
  'deep-blue': { bg1: '#05080c', bg2: '#0f151f' },
  'deep-purple': { bg1: '#12081a', bg2: '#1f1229' },
  'deep-teal': { bg1: '#061616', bg2: '#0f2525' },
  'deep-red': { bg1: '#160606', bg2: '#251010' }
};

// Apply background directly (no CSS variables for background)
function applyTheme(themeName) {
  console.log("Applying theme:", themeName);
  const theme = themes[themeName];
  if (!theme) return;
  
  // Apply to html AND body for full coverage
  const gradient = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
  document.documentElement.style.background = gradient;
  document.body.style.background = gradient;
  
  // Also update theme buttons for consistency
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === themeName) {
      btn.style.background = gradient;
    }
  });
  
  // Save to localStorage
  localStorage.setItem('theme', themeName);
  console.log("Theme saved to localStorage:", themeName);
}

// ===== LAZY LOADING CORE FUNCTIONS =====

// Calculate which cards should be visible based on scroll position
function calculateVisibleRange() {
  const grid = document.getElementById('gridContainer');
  if (!grid || !grid.children.length) return { start: 0, end: 0 };
  
  const cards = Array.from(grid.children);
  const gridRect = grid.getBoundingClientRect();
  const viewportHeight = window.innerHeight;
  
  // Find first visible card
  let firstVisible = 0;
  let lastVisible = cards.length - 1;
  
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const rect = card.getBoundingClientRect();
    
    // Card is in viewport
    if (rect.bottom > 0 && rect.top < viewportHeight) {
      firstVisible = i;
      break;
    }
  }
  
  // Find last visible card
  for (let i = cards.length - 1; i >= 0; i--) {
    const card = cards[i];
    const rect = card.getBoundingClientRect();
    
    // Card is in viewport
    if (rect.bottom > 0 && rect.top < viewportHeight) {
      lastVisible = i;
      break;
    }
  }
  
  // Add buffer around visible area
  const buffer = LAZY_LOAD_CONFIG.VISIBLE_BUFFER;
  const start = Math.max(0, firstVisible - buffer);
  const end = Math.min(cards.length - 1, lastVisible + buffer);
  
  return { start, end };
}

// Update which cards are currently visible
function updateVisibleCards() {
  const range = calculateVisibleRange();
  lazyState.currentViewportRange = range;
  
  // Track visible cards
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  lazyState.visibleCards.clear();
  for (let i = range.start; i <= range.end && i < cards.length; i++) {
    const card = cards[i];
    if (card.dataset.name) {
      lazyState.visibleCards.add(card.dataset.name);
    }
  }
  
  console.log(`Visible cards: ${range.start}-${range.end} (${lazyState.visibleCards.size} cards)`);
  
  // Trigger lazy loading for cards in range
  scheduleLazyLoad(range);
}

// Schedule cards to be loaded based on visibility
function scheduleLazyLoad(range) {
  if (lazyState.isLoading || lazyState.isSearching) return;
  
  const cardsToLoad = [];
  const cardsToUnload = [];
  
  // Determine which cards need loading
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const cardName = card.dataset.name;
    
    if (!cardName) continue;
    
    const isInRange = i >= range.start && i <= range.end;
    const isLoaded = lazyState.loadedCards.has(cardName);
    const isLoading = card.classList.contains('loading');
    
    // Card needs loading if in range and not loaded/loading
    if (isInRange && !isLoaded && !isLoading) {
      cardsToLoad.push({ index: i, name: cardName, element: card });
    }
    
    // Card can be unloaded if far away and loaded
    const isFarAway = i < range.start - LAZY_LOAD_CONFIG.UNLOAD_DISTANCE || 
                     i > range.end + LAZY_LOAD_CONFIG.UNLOAD_DISTANCE;
    if (isFarAway && isLoaded) {
      cardsToUnload.push({ index: i, name: cardName, element: card });
    }
  }
  
  // Limit loading to batch size
  const loadingBatch = cardsToLoad.slice(0, LAZY_LOAD_CONFIG.BATCH_SIZE);
  
  // Unload distant cards first (to free up memory)
  unloadCards(cardsToUnload);
  
  // Then load visible cards
  if (loadingBatch.length > 0) {
    lazyState.isLoading = true;
    showLoadingIndicator(`Loading ${loadingBatch.length} cards...`);
    
    // Load in sequence with delay
    loadingBatch.forEach((card, idx) => {
      setTimeout(() => {
        loadCardContent(card.name, card.element, idx === loadingBatch.length - 1);
      }, idx * LAZY_LOAD_CONFIG.BATCH_DELAY);
    });
  } else {
    hideLoadingIndicator();
  }
}

// Load a single card's content
function loadCardContent(cardName, cardElement, isLastInBatch = false) {
  if (!cardElement) return;
  
  const contentDiv = cardElement.querySelector('.content');
  if (!contentDiv) return;
  
  // Mark as loading
  cardElement.classList.add('loading');
  contentDiv.innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.6)">Loading...</div>';
  
  // Check cache first
  if (lazyState.cardCache.has(cardName)) {
    const cachedHTML = lazyState.cardCache.get(cardName);
    processLoadedCard(cardName, cardElement, cachedHTML, isLastInBatch, true);
    return;
  }
  
  // Fetch from server
  fetch(`cards/${cardName}.html`)
    .then(r => r.ok ? r.text() : Promise.reject())
    .then(html => {
      // Cache the HTML
      lazyState.cardCache.set(cardName, html);
      
      // Process the loaded card
      processLoadedCard(cardName, cardElement, html, isLastInBatch, false);
    })
    .catch(() => {
      contentDiv.textContent = 'Preview unavailable';
      cardElement.classList.remove('loading');
      lazyState.loadedCards.add(cardName);
      
      if (isLastInBatch) {
        lazyState.isLoading = false;
        hideLoadingIndicator();
      }
    });
}

// Process loaded card content
function processLoadedCard(cardName, cardElement, html, isLastInBatch, fromCache) {
  const contentDiv = cardElement.querySelector('.content');
  
  // Load HTML
  contentDiv.innerHTML = html;
  
  // Sanitize card content
  sanitizeCardContent(cardElement);
  
  // Add embed section
  addEmbedSectionToCard(cardElement, `${cardName}.html`);
  
  // Execute any scripts
  const scripts = contentDiv.querySelectorAll('script');
  scripts.forEach(script => {
    const newScript = document.createElement('script');
    if (script.src) {
      newScript.src = script.src;
    } else {
      newScript.textContent = script.textContent;
    }
    [...script.attributes].forEach(attr => {
      newScript.setAttribute(attr.name, attr.value);
    });
    script.parentNode.replaceChild(newScript, script);
  });
  
  // Mark as loaded
  lazyState.loadedCards.add(cardName);
  cardElement.classList.remove('loading');
  cardElement.classList.add('loaded');
  cardElement.classList.add('visible');
  
  // Update status
  updateStatusText();
  
  // If this was the last in batch, update loading state
  if (isLastInBatch) {
    lazyState.isLoading = false;
    hideLoadingIndicator();
    
    // Clean up cache if too large
    cleanupCardCache();
  }
  
  console.log(`Loaded card: ${cardName} ${fromCache ? '(from cache)' : ''}`);
}

// Unload cards that are far from viewport
function unloadCards(cardsToUnload) {
  // Only unload if we have too many loaded cards
  if (lazyState.loadedCards.size <= LAZY_LOAD_CONFIG.MAX_LOADED_CARDS) {
    return;
  }
  
  cardsToUnload.forEach(({ name, element }) => {
    if (lazyState.loadedCards.has(name) && !lazyState.visibleCards.has(name)) {
      // Create placeholder
      const contentDiv = element.querySelector('.content');
      if (contentDiv) {
        contentDiv.innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.4)">Card unloaded (scroll to load)</div>';
      }
      
      // Remove from loaded set (but keep in cache)
      lazyState.loadedCards.delete(name);
      element.classList.remove('loaded');
      element.classList.remove('visible');
      
      console.log(`Unloaded card: ${name}`);
    }
  });
}

// Clean up card cache when it gets too large
function cleanupCardCache() {
  if (lazyState.cardCache.size <= LAZY_LOAD_CONFIG.CACHE_SIZE) return;
  
  // Remove oldest cached items
  const cacheEntries = Array.from(lazyState.cardCache.entries());
  const toRemove = cacheEntries
    .filter(([name]) => !lazyState.loadedCards.has(name) && !lazyState.visibleCards.has(name))
    .slice(0, lazyState.cardCache.size - LAZY_LOAD_CONFIG.CACHE_SIZE);
  
  toRemove.forEach(([name]) => {
    lazyState.cardCache.delete(name);
  });
  
  if (toRemove.length > 0) {
    console.log(`Cleaned ${toRemove.length} items from cache`);
  }
}

// Show loading indicator
function showLoadingIndicator(text = 'Loading...') {
  const indicator = document.getElementById('loadingIndicator');
  const textElement = document.getElementById('loadingText');
  
  if (indicator && textElement) {
    textElement.textContent = text;
    indicator.style.display = 'flex';
  }
}

// Hide loading indicator
function hideLoadingIndicator() {
  const indicator = document.getElementById('loadingIndicator');
  if (indicator) {
    indicator.style.display = 'none';
  }
}

// Update status text with loaded counts
function updateStatusText() {
  const status = document.getElementById('status');
  if (!status) return;
  
  const total = lazyState.allCardFiles.length;
  const loaded = lazyState.loadedCards.size;
  const visible = lazyState.visibleCards.size;
  
  if (lazyState.isSearching) {
    status.textContent = `Search results: ${visible} cards`;
  } else {
    status.textContent = `${loaded} of ${total} cards loaded (${visible} visible)`;
  }
}

// ===== SIMPLE EMBED SYSTEM =====
function addEmbedSectionToCard(card, fileName) {
  const cardName = fileName.replace('.html', '');
  const displayName = cardName.replace(/-/g, ' ');
  
  const embedHTML = `
    <div class="embed-section">
      <span>Share this tool:</span>
      <button class="embed-btn" data-card="${cardName}" data-file="${fileName}">
        ðŸ”— Copy Embed Code
      </button>
    </div>
  `;
  
  // Add the embed section to the card
  const contentDiv = card.querySelector('.content');
  if (contentDiv) {
    contentDiv.insertAdjacentHTML('beforeend', embedHTML);
    
    // Add click event to the embed button
    const embedBtn = contentDiv.querySelector('.embed-btn');
    if (embedBtn) {
      embedBtn.addEventListener('click', function() {
        copyEmbedCode(cardName, fileName, displayName);
      });
    }
  }
}

// Function to copy embed code
function copyEmbedCode(cardName, fileName, displayName) {
  // Generate clean embed code
  const embedCode = `<iframe src="https://mrpr0phecy.github.io/mrpr0phecy/cards/${fileName}" width="100%" height="400" style="border:none;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.3);" title="${displayName} - The Most Useful Site"></iframe>`;
  
  // Copy to clipboard
  navigator.clipboard.writeText(embedCode).then(() => {
    // Visual feedback
    const embedBtn = document.querySelector(`.embed-btn[data-card="${cardName}"]`);
    if (embedBtn) {
      const originalText = embedBtn.textContent;
      embedBtn.textContent = 'âœ… Copied!';
      embedBtn.classList.add('copied');
      
      setTimeout(() => {
        embedBtn.textContent = originalText;
        embedBtn.classList.remove('copied');
      }, 2000);
    }
    
    console.log(`Embed code for ${displayName} copied to clipboard!`);
  }).catch(err => {
    console.error('Failed to copy: ', err);
    // Fallback: Create a temporary textarea
    const textArea = document.createElement('textarea');
    textArea.value = embedCode;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
      console.log('Fallback copy successful');
    } catch (e) {
      console.error('Fallback copy failed: ', e);
    }
    document.body.removeChild(textArea);
  });
}

// ===== CARD SANITIZATION =====
function sanitizeCardContent(cardElement) {
  const content = cardElement.querySelector('.content');
  if (!content) return;
  
  // Apply containment to prevent layout thrashing
  cardElement.style.contain = 'content';
  
  // Make sure all images/videos/iframes don't overflow
  const mediaElements = content.querySelectorAll('img, video, iframe, canvas');
  mediaElements.forEach(el => {
    el.style.maxWidth = '100%';
    el.style.height = 'auto';
    el.style.display = 'block';
  });
  
  // Fix textareas and inputs
  const formElements = content.querySelectorAll('textarea, input, select');
  formElements.forEach(el => {
    el.style.maxWidth = '100%';
    el.style.boxSizing = 'border-box';
  });
  
  // Fix tables
  const tables = content.querySelectorAll('table');
  tables.forEach(table => {
    table.style.maxWidth = '100%';
    table.style.overflowX = 'auto';
    table.style.display = 'block';
  });
  
  // Fix code blocks
  const codeBlocks = content.querySelectorAll('pre, code');
  codeBlocks.forEach(el => {
    el.style.whiteSpace = 'pre-wrap';
    el.style.wordBreak = 'break-word';
    el.style.maxWidth = '100%';
    el.style.overflowX = 'auto';
  });
  
  // Wrap content in scrollable container
  const originalHTML = content.innerHTML;
  content.innerHTML = '';
  
  const scrollContainer = document.createElement('div');
  scrollContainer.className = 'card-content';
  scrollContainer.innerHTML = originalHTML;
  
  content.appendChild(scrollContainer);
}

// ===== TOOLBOX WIDGET MANAGEMENT =====
let widgets = [];
let toolboxDocked = false;

// Make toolbox draggable and resizable
function initToolbox() {
  const toolbox = document.getElementById('toolbox');
  const toolboxTitle = document.getElementById('toolboxTitle');
  
  // Make toolbox draggable
  let isDragging = false;
  let dragOffset = { x: 0, y: 0 };
  
  toolboxTitle.addEventListener('mousedown', startDrag);
  
  function startDrag(e) {
    if (e.target.tagName === 'BUTTON') return;
    
    isDragging = true;
    const rect = toolbox.getBoundingClientRect();
    dragOffset.x = e.clientX - rect.left;
    dragOffset.y = e.clientY - rect.top;
    
    document.addEventListener('mousemove', onDrag);
    document.addEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = 'grabbing';
  }
  
  function onDrag(e) {
    if (!isDragging) return;
    
    e.preventDefault();
    toolbox.style.left = 'auto';
    toolbox.style.right = 'auto';
    toolbox.style.top = e.clientY - dragOffset.y + 'px';
    toolbox.style.left = e.clientX - dragOffset.x + 'px';
  }
  
  function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', onDrag);
    document.removeEventListener('mouseup', stopDrag);
    toolboxTitle.style.cursor = '';
  }
  
  // Dock/undock button
  document.getElementById('dockBtn').addEventListener('click', function() {
    toolboxDocked = !toolboxDocked;
    
    if (toolboxDocked) {
      // Dock to right
      toolbox.style.left = 'auto';
      toolbox.style.right = '18px';
      toolbox.style.top = 'auto';
      toolbox.style.bottom = '18px';
      this.textContent = 'â‡²';
    } else {
      // Undock
      this.textContent = 'â‡±';
    }
  });
  
  // Load saved widgets
  loadSavedWidgets();
}

// Create a widget in toolbox
function createWidget(name, contentHTML) {
  const widgetId = 'widget-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  const widget = document.createElement('div');
  widget.className = 'widget-wrap';
  widget.id = widgetId;
  widget.dataset.name = name;
  
  // Random position within toolbox
  const toolboxContent = document.getElementById('toolboxContent');
  const tRect = toolboxContent.getBoundingClientRect();
  
  widget.style.left = Math.random() * (tRect.width - 200) + 'px';
  widget.style.top = Math.random() * (tRect.height - 150) + 'px';
  widget.style.width = '200px';
  widget.style.height = '150px';
  
  widget.innerHTML = `
    <div class="widget-titlebar">
      <strong>${name}</strong>
      <button class="widget-close" title="Close widget">âœ•</button>
    </div>
    <div class="widget-body">${contentHTML}</div>
  `;
  
  toolboxContent.appendChild(widget);
  
  // Save widget
  widgets.push({
    id: widgetId,
    name: name,
    content: contentHTML,
    x: widget.style.left,
    y: widget.style.top,
    width: widget.style.width,
    height: widget.style.height
  });
  
  saveWidgets();
  
  return widgetId;
}

// Save widgets to localStorage
function saveWidgets() {
  localStorage.setItem('toolboxWidgets', JSON.stringify(widgets));
}

// Load saved widgets
function loadSavedWidgets() {
  const saved = localStorage.getItem('toolboxWidgets');
  if (saved) {
    try {
      widgets = JSON.parse(saved) || [];
    } catch (e) {
      console.error('Failed to load widgets:', e);
      widgets = [];
    }
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
  console.log("DOM ready");
  
  // FIX 1: Scroll to top immediately
  window.scrollTo(0, 0);
  
  // Apply saved theme or default
  const savedTheme = localStorage.getItem('theme') || 'default';
  applyTheme(savedTheme);
  
  // Activate saved theme button
  document.querySelectorAll('.theme-btn').forEach(btn => {
    if (btn.dataset.color === savedTheme) {
      btn.classList.add('active');
      btn.style.border = '2px solid var(--accent)';
    } else {
      btn.classList.remove('active');
      btn.style.border = '1px solid var(--border)';
    }
  });
  
  // Apply saved accent
  const savedAccent = localStorage.getItem('accent') || '#2dd4ff';
  document.documentElement.style.setProperty('--accent', savedAccent);
  document.querySelectorAll('.palette-color').forEach(c => {
    c.classList.toggle('active', c.dataset.accent === savedAccent);
  });
  
  // Apply reader mode
  if(localStorage.getItem('readerMode') === 'on') {
    document.body.classList.add('reader-mode');
  }
  
  // Initialize toolbox
  initToolbox();
  
  // Load dashboard with lazy loading
  loadDashboard();
});

// FIX 1: Scroll to search bar when page loads or refreshes
window.addEventListener('load', function() {
  // Small delay to ensure everything is rendered
  setTimeout(() => {
    const searchBar = document.querySelector('.search-bar');
    if (searchBar) {
      searchBar.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    // Also focus the search input
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.focus();
    }
  }, 100);
});

// FIX 1: Also scroll to top when clicking home/reloading
window.addEventListener('beforeunload', function() {
  window.scrollTo(0, 0);
});

// ===== PALETTE HANDLING =====
document.getElementById('paletteToggle').addEventListener('click', function() {
  const panel = document.getElementById('palettePanel');
  panel.classList.toggle('open');
});

// Accent colors
document.querySelectorAll('.palette-color').forEach(c => {
  c.addEventListener('click', function() {
    document.querySelectorAll('.palette-color').forEach(x => x.classList.remove('active'));
    this.classList.add('active');
    const col = this.dataset.accent;
    document.documentElement.style.setProperty('--accent', col);
    localStorage.setItem('accent', col);
  });
});

// Background themes - SIMPLE
document.querySelectorAll('.theme-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    document.querySelectorAll('.theme-btn').forEach(b => {
      b.classList.remove('active');
      b.style.border = '1px solid var(--border)';
    });
    this.classList.add('active');
    this.style.border = '2px solid var(--accent)';
    
    const themeName = this.dataset.color;
    applyTheme(themeName);
  });
});

// ===== TOOLBOX =====
const toolbox = document.getElementById('toolbox');
document.getElementById('toolboxToggle').addEventListener('click', function() {
  toolbox.classList.toggle('hidden');
});
document.getElementById('toolboxClose').addEventListener('click', function(e) {
  e.stopPropagation();
  toolbox.classList.add('hidden');
});

// ===== READER MODE =====
document.getElementById('readerToggle').addEventListener('click', function() {
  document.body.classList.toggle('reader-mode');
  localStorage.setItem('readerMode', document.body.classList.contains('reader-mode') ? 'on' : 'off');
});

// ===== SEARCH =====
const searchInput = document.getElementById('searchInput');
let searchTimeout = null;

searchInput.addEventListener('input', function(e) {
  const q = e.target.value.toLowerCase().trim();
  
  // Clear previous timeout
  if (searchTimeout) clearTimeout(searchTimeout);
  
  // Debounce search
  searchTimeout = setTimeout(() => {
    lazyState.isSearching = q.length > 0;
    
    if (lazyState.isSearching) {
      // When searching, load all matching cards
      performSearch(q);
    } else {
      // When not searching, revert to lazy loading
      document.querySelectorAll('.card').forEach(card => {
        card.style.display = '';
      });
      updateVisibleCards();
    }
  }, 300);
});

// Perform search and load matching cards
function performSearch(query) {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  let visibleCount = 0;
  
  cards.forEach(card => {
    const name = card.dataset.name.toLowerCase();
    const text = card.textContent.toLowerCase();
    const matches = name.includes(query) || text.includes(query);
    
    card.style.display = matches ? '' : 'none';
    
    if (matches) {
      visibleCount++;
      
      // If searching, load the card immediately
      if (!lazyState.loadedCards.has(card.dataset.name)) {
        loadCardContent(card.dataset.name, card, false);
      }
    }
  });
  
  updateStatusText();
  console.log(`Search found ${visibleCount} cards for: "${query}"`);
}

// ===== SORT BUTTONS =====
document.getElementById('sortAlphaBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  cards.sort((a,b) => a.dataset.name.localeCompare(b.dataset.name));
  cards.forEach(card => grid.appendChild(card));
  
  // Update positions and reload visible area
  updateCardPositions();
  updateVisibleCards();
});

document.getElementById('sortRandomBtn').addEventListener('click', function() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  for (let i = cards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [cards[i], cards[j]] = [cards[j], cards[i]];
  }
  cards.forEach(card => grid.appendChild(card));
  
  // Update positions and reload visible area
  updateCardPositions();
  updateVisibleCards();
});

// Update card positions map
function updateCardPositions() {
  const grid = document.getElementById('gridContainer');
  const cards = Array.from(grid.children);
  
  lazyState.cardPositions.clear();
  cards.forEach((card, index) => {
    if (card.dataset.name) {
      lazyState.cardPositions.set(card.dataset.name, index);
    }
  });
}

// ===== LAZY LOAD DASHBOARD =====
async function loadDashboard() {
  try {
    const DEFAULT_REPO = 'mrpr0phecy/mrpr0phecy';
    const DEFAULT_BRANCH = 'main';
    
    // Parse repo
    const [owner, repo] = DEFAULT_REPO.split('/');
    
    document.getElementById('status').textContent = 'Fetching card list...';
    showLoadingIndicator('Loading card list...');
    
    // Fetch card files
    const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/${DEFAULT_BRANCH}?recursive=1`;
    const response = await fetch(url);
    const data = await response.json();
    
    lazyState.allCardFiles = (data.tree || [])
      .filter(item => item.path.startsWith('cards/') && item.path.endsWith('.html'))
      .map(item => item.path.replace(/^cards\//, '').replace('.html', ''))
      .sort();
    
    console.log(`Found ${lazyState.allCardFiles.length} cards`);
    
    // Display card placeholders
    const grid = document.getElementById('gridContainer');
    grid.innerHTML = '';
    
    lazyState.allCardFiles.forEach((cardName, index) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.dataset.name = cardName;
      card.dataset.index = index;
      
      const header = document.createElement('div');
      header.className = 'card-header';
      header.innerHTML = `<h3>${cardName.replace(/-/g, ' ')}</h3><div style="display:flex;gap:8px"><div class="add-to-toolbox" title="Add to toolbox" style="cursor:pointer;font-weight:bold;color:var(--accent)">+</div></div>`;
      
      const content = document.createElement('div');
      content.className = 'content';
      content.innerHTML = '<div style="padding:20px;text-align:center;color:rgba(230,250,255,0.4)">Click or scroll to load card...</div>';
      
      card.appendChild(header);
      card.appendChild(content);
      grid.appendChild(card);
      
      // Store position
      lazyState.cardPositions.set(cardName, index);
    });
    
    // Update status
    updateStatusText();
    hideLoadingIndicator();
    
    // Initialize scroll observer
    initScrollObserver();
    
    // Load initial visible cards
    setTimeout(() => {
      updateVisibleCards();
    }, 100);
    
  } catch (error) {
    console.error("Error loading dashboard:", error);
    document.getElementById('status').textContent = 'Error loading cards';
    hideLoadingIndicator();
  }
}

// Initialize scroll observer for lazy loading
function initScrollObserver() {
  // Use scroll event with debouncing for compatibility
  let scrollTimeout = null;
  
  window.addEventListener('scroll', () => {
    if (scrollTimeout) clearTimeout(scrollTimeout);
    
    scrollTimeout = setTimeout(() => {
      if (!lazyState.isSearching) {
        updateVisibleCards();
      }
    }, LAZY_LOAD_CONFIG.DEBOUNCE_SCROLL);
  }, { passive: true });
  
  // Also listen for resize
  window.addEventListener('resize', () => {
    if (!lazyState.isSearching) {
      updateVisibleCards();
    }
  }, { passive: true });
  
  // Click to load cards that aren't loaded yet
  document.addEventListener('click', function(e) {
    const card = e.target.closest('.card');
    if (card && !card.classList.contains('loaded')) {
      const cardName = card.dataset.name;
      if (cardName && !lazyState.loadedCards.has(cardName)) {
        loadCardContent(cardName, card, true);
      }
    }
  });
}

// Add event listener for adding cards to toolbox
document.addEventListener('click', function(e) {
  // Check if click is on "Add to toolbox" button
  if (e.target.classList.contains('add-to-toolbox') || 
      e.target.closest('.add-to-toolbox')) {
    
    const card = e.target.closest('.card');
    if (!card) return;
    
    const cardName = card.dataset.name;
    const contentElement = card.querySelector('.content');
    const contentHTML = contentElement.innerHTML;
    
    // Make sure card is loaded first
    if (!lazyState.loadedCards.has(cardName)) {
      alert('Please wait for the card to load before adding to toolbox');
      return;
    }
    
    // Create widget in toolbox
    createWidget(cardName, contentHTML);
    
    // Show toolbox if hidden
    toolbox.classList.remove('hidden');
    
    // Visual feedback
    const addBtn = e.target.closest('.add-to-toolbox');
    addBtn.textContent = 'âœ“';
    addBtn.style.color = 'var(--accent)';
    setTimeout(() => {
      addBtn.textContent = '+';
      addBtn.style.color = '';
    }, 1000);
  }
});

// Make Sortable (disabled on main page)
new Sortable(document.getElementById('gridContainer'), {
  animation: 150,
  disabled: true
});

// ===== MOBILE-FRIENDLY SCROLLING FIX =====
document.addEventListener('DOMContentLoaded', function() {
  // Add passive event listeners for better scrolling performance
  document.addEventListener('touchmove', function(e) {
    // Allow default scrolling behavior for the main page
    if (!e.target.closest('.card, .widget-wrap, .toolbox')) {
      return;
    }
  }, { passive: true });
});

// Helper function to detect touch devices
function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}

// If on mobile, adjust some settings for better UX
if (isTouchDevice()) {
  // Make buttons slightly larger for touch
  document.documentElement.style.setProperty('--card-min', '280px');
  
  // Adjust toolbox dimensions for mobile
  const toolbox = document.getElementById('toolbox');
  if (toolbox) {
    toolbox.style.minWidth = '280px';
    toolbox.style.minHeight = '300px';
  }
}

console.log("=== APP WITH LAZY LOADING INITIALIZED ===");
</script>
</body>
</html>
