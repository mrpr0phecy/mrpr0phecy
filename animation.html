<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy Hip-Hop Screensaver</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    @font-face {
      font-family: 'HipHopFont';
      src: url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
    }
  </style>
</head>
<body>
  <script>
    let particles = [];
    let shapes = [];
    let glitchTimer = 0;
    const GLITCH_INTERVAL = 90; // Glitch every ~1.5 seconds at 60 FPS
    let time = 0; // Global time for animation evolution
    let noiseScale = 0.003; // For smoother, faster noise

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 1);

      // Initialize particles with noise-driven motion
      for (let i = 0; i < 250; i++) {
        particles.push({
          x: random(width),
          y: random(height),
          baseX: random(1000), // Base for noise-driven motion
          baseY: random(1000),
          size: random(5, 15),
          hue: random(360),
          alpha: random(0.6, 1),
          type: random(['circle', 'square', 'triangle'])
        });
      }

      // Initialize fractal-inspired shapes
      for (let i = 0; i < 15; i++) {
        shapes.push({
          x: random(width),
          y: random(height),
          baseX: random(1000),
          baseY: random(1000),
          size: random(50, 100),
          angle: random(TWO_PI),
          speed: random(-0.05, 0.05),
          hue: random(360),
          glitchOffsetX: 0,
          glitchOffsetY: 0,
          variation: random(['linear', 'swirl'])
        });
      }

      // Optional: Audio input setup
      /*
      mic = new p5.AudioIn();
      mic.start();
      */
    }

    function draw() {
      // Semi-transparent background for smooth motion trails
      background(0, 0, 0, 0.2);
      time += 0.02; // Faster evolution for noticeable motion

      // Layer 1: Evolving noise background
      drawNoiseBackground();

      // Layer 2: Fractal-inspired shapes with continuous motion
      glitchTimer++;
      if (glitchTimer > GLITCH_INTERVAL) {
        glitchTimer = 0;
        applyGlitch();
      }
      for (let s of shapes) {
        // Noise-driven position for organic motion
        let nx = noise(s.baseX + time * 0.1) * width;
        let ny = noise(s.baseY + time * 0.1) * height;
        s.x = lerp(s.x, nx, 0.05); // Smoothly interpolate position
        s.y = lerp(s.y, ny, 0.05);
        push();
        translate(s.x + s.glitchOffsetX, s.y + s.glitchOffsetY);
        rotate(s.angle);
        let scale = 1 + 0.2 * sin(time + s.baseX); // Pulsating scale
        scaleMatrix(scale, scale);
        fill(s.hue, 80, 80, 0.8);
        noStroke();
        if (s.variation === 'swirl') {
          // Swirl effect inspired by FLAM3
          beginShape();
          for (let a = 0; a < TWO_PI; a += 0.1) {
            let r = s.size * (1 + 0.3 * sin(a * 8 + time));
            vertex(r * cos(a + time * 0.5), r * sin(a + time * 0.5));
          }
          endShape(CLOSE);
        } else {
          // Triangle for geometric hip-hop vibe
          triangle(
            -s.size / 2, s.size / 2,
            s.size / 2, s.size / 2,
            0, -s.size / 2
          );
        }
        s.angle += s.speed;
        s.hue = (s.hue + 0.5) % 360; // Continuous color shift
        pop();
      }

      // Layer 3: Dynamic particle system
      /*
      let vol = mic.getLevel(); // Uncomment for audio reactivity
      */
      for (let p of particles) {
        // Noise-driven motion for fluid paths
        p.vx = map(noise(p.baseX + time * 0.2), 0, 1, -2, 2);
        p.vy = map(noise(p.baseY + time * 0.2), 0, 1, -2, 2);
        p.x += p.vx;
        p.y += p.vy;
        // Wrap around edges for continuous flow
        if (p.x < 0) p.x += width;
        if (p.x > width) p.x -= width;
        if (p.y < 0) p.y += height;
        if (p.y > height) p.y -= height;
        // Pulsating size
        p.size = constrain(p.size + sin(time + p.baseX) * 0.2 /* + map(vol, 0, 1, 0, 5) */, 5, 20);
        fill(p.hue, 80, 80, p.alpha);
        noStroke();
        push();
        translate(p.x, p.y);
        if (p.type === 'circle') {
          ellipse(0, 0, p.size);
        } else if (p.type === 'square') {
          rect(-p.size / 2, -p.size / 2, p.size, p.size);
        } else {
          triangle(
            -p.size / 2, p.size / 2,
            p.size / 2, p.size / 2,
            0, -p.size / 2
          );
        }
        pop();
        p.hue = (p.hue + random(0.8)) % 360; // Random color shift
      }

      // Layer 4: Glitchy text overlay
      let textX = width - 220 + sin(time) * 5; // Subtle wobble
      let textY = height - 50 + cos(time) * 5;
      drawGlitchText("MrProphecy", textX, textY, 40);
    }

    function drawNoiseBackground() {
      // Fast-evolving noise background
      loadPixels();
      for (let x = 0; x < width; x += 6) {
        for (let y = 0; y < height; y += 6) {
          let n = noise(x * noiseScale, y * noiseScale, time * 0.5);
          let hue = map(n, 0, 1, 0, 360);
          fill(hue, 60, 60, 0.5);
          noStroke();
          rect(x, y, 6, 6);
        }
      }
      updatePixels();
    }

    function applyGlitch() {
      // Glitch effect for shapes
      for (let s of shapes) {
        s.glitchOffsetX = random(-20, 20);
        s.glitchOffsetY = random(-20, 20);
        setTimeout(() => {
          s.glitchOffsetX = 0;
          s.glitchOffsetY = 0;
        }, 80); // Brief glitch duration
      }
    }

    function drawGlitchText(text, x, y, size) {
      // Glitchy neon text
      fill(60, 100, 100, 1); // Neon yellow
      textSize(size);
      textStyle(BOLD);
      textFont('Orbitron');
      text(text, x, y);
      if (random() < 0.15) { // 15% chance for glitch
        fill(180, 100, 100, 0.7); // Cyan glitch
        text(text, x + random(-12, 12), y + random(-12, 12));
        fill(300, 100, 100, 0.7); // Magenta glitch
        text(text, x + random(-12, 12), y + random(-12, 12));
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>