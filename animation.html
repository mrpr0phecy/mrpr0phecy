<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    @font-face { font-family: 'Graffiti'; src: url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap'); }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const c = document.getElementById('canvas'), ctx = c.getContext('2d', { alpha: true });
    c.width = innerWidth; c.height = innerHeight;

    const baseHue = Math.random() * 360, colors = {
      primary: baseHue, secondary: (baseHue + 120) % 360, neon: (baseHue + 60) % 360
    };

    let time = 0, glitchTimer = 0, GLITCH_INTERVAL = 6;

    const particles = Array(40).fill().map(() => ({
      x: Math.random() * c.width - c.width / 2, y: Math.random() * c.height - c.height / 2,
      size: Math.random() * 6 + 3, hue: colors[Math.random() < 0.5 ? 'primary' : 'secondary'],
      alpha: Math.random() * 0.5 + 0.5, type: Math.random() < 0.5 ? 'circle' : 'star',
      angle: Math.random() * Math.PI * 2, speed: Math.random() * 0.03 + 0.02, radius: Math.random() * 80 + 40
    }));

    const flames = Array(3).fill().map(() => ({
      scale: Math.random() * 80 + 100, angle: Math.random() * Math.PI * 2,
      hue: colors.neon, speed: Math.random() * 0.07 + 0.05, x: Math.random() * c.width - c.width / 2,
      y: Math.random() * c.height - c.height / 2, radius: Math.random() * 80 + 40
    }));

    let spiroParams = { R: 120, r: 30, d: 20 };
    function updateSpiroParams() {
      if (Math.random() < 0.04) spiroParams = {
        R: 100 + Math.random() * 30, r: 20 + Math.random() * 15, d: 15 + Math.random() * 15
      };
    }

    function draw() {
      ctx.clearRect(0, 0, c.width, c.height); ctx.setTransform(1, 0, 0, 1, 0, 0);
      time += 0.05; glitchTimer++; if (glitchTimer > GLITCH_INTERVAL) glitchTimer = 0;

      drawBackground(); drawSpirograph(); drawKaleidoscope(); drawParticles();
      drawGraffitiText("MrProphecy", c.width - 160 + Math.sin(time) * 8, c.height - 40 + Math.cos(time) * 8, 36);

      requestAnimationFrame(draw);
    }

    function drawBackground() {
      ctx.save();
      const g = ctx.createRadialGradient(c.width / 2, c.height / 2, 0, c.width / 2, c.height / 2, Math.max(c.width, c.height) / 1.5);
      g.addColorStop(0, `hsla(${colors.primary},90%,30%,0.8)`); g.addColorStop(1, `hsla(${colors.secondary},90%,25%,0.8)`);
      ctx.fillStyle = g; ctx.fillRect(0, 0, c.width, c.height);
      ctx.fillStyle = `hsla(${colors.neon},95%,40%,0.6)`; ctx.fillRect(0, c.height / 2 - 20, c.width, 40);
      ctx.restore();
    }

    function drawSpirograph() {
      ctx.save(); ctx.translate(c.width / 2, c.height / 2); updateSpiroParams();
      const R = spiroParams.R, r = spiroParams.r, d = spiroParams.d;
      ctx.beginPath();
      for (let t = 0; t < Math.PI * 4; t += 0.05) {
        const x = (R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t + time),
              y = (R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t + time),
              glitchX = glitchTimer > GLITCH_INTERVAL - 1 ? (Math.random() - 0.5) * 4 : 0;
        t === 0 ? ctx.moveTo(x, y + glitchX) : ctx.lineTo(x, y + glitchX);
      }
      ctx.strokeStyle = `hsla(${colors.neon},95%,90%,0.8)`; ctx.lineWidth = 1.5;
      ctx.shadowColor = `hsla(${colors.neon},100%,80%,0.6)`; ctx.shadowBlur = 8; ctx.stroke();
      ctx.shadowBlur = 0; ctx.restore();
    }

    function drawKaleidoscope() {
      ctx.save(); ctx.translate(c.width / 2, c.height / 2);
      flames.forEach((f, i) => {
        f.angle += f.speed; f.x = f.radius * Math.cos(f.angle + Math.sin(time + i) * 0.1);
        f.y = f.radius * Math.sin(f.angle + Math.cos(time + i) * 0.1);
        const radius = f.scale + Math.sin(time * 0.7 + i) * 30;
        for (let s = 0; s < 8; s++) {
          ctx.save(); ctx.rotate(Math.PI * 2 * s / 8); ctx.beginPath();
          for (let t = 0; t < Math.PI * 2; t += 0.05) {
            const r = radius * Math.sin(5 * t + time + i),
                  x = r * Math.cos(t + r * 0.03), y = r * Math.sin(t + r * 0.03),
                  glitchY = glitchTimer > GLITCH_INTERVAL - 1 ? (Math.random() - 0.5) * 6 : 0;
            t === 0 ? ctx.moveTo(f.x + x, f.y + y + glitchY) : ctx.lineTo(f.x + x, f.y + y + glitchY);
          }
          ctx.strokeStyle = `hsla(${(f.hue + s * 10) % 360},95%,90%,0.7)`; ctx.lineWidth = 1;
          ctx.shadowColor = `hsla(${f.hue},100%,80%,0.5)`; ctx.shadowBlur = 6; ctx.stroke(); ctx.restore();
        }
        f.hue = (f.hue + 1.5) % 360; f.scale = Math.max(60, Math.min(180, f.scale + Math.sin(time + i) * 2));
        f.radius = Math.max(40, Math.min(180, f.radius + Math.sin(time + i) * 1.5));
      });
      ctx.shadowBlur = 0; ctx.restore();
    }

    function drawParticles() {
      ctx.save(); ctx.translate(c.width / 2, c.height / 2);
      particles.forEach(p => {
        p.angle += p.speed; p.x = p.radius * Math.cos(p.angle + Math.sin(time) * 0.1);
        p.y = p.radius * Math.sin(p.angle + Math.cos(time) * 0.1); p.hue = (p.hue + 1.5) % 360;
        ctx.fillStyle = `hsla(${p.hue},95%,90%,${p.alpha})`; ctx.beginPath();
        if (p.type === 'circle') {
          ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
        } else {
          const s = p.size / 2;
          ctx.moveTo(p.x, p.y - s); ctx.lineTo(p.x + s * 0.3, p.y - s * 0.3); ctx.lineTo(p.x + s, p.y);
          ctx.lineTo(p.x + s * 0.3, p.y + s * 0.3); ctx.lineTo(p.x, p.y + s); ctx.lineTo(p.x - s * 0.3, p.y + s * 0.3);
          ctx.lineTo(p.x - s, p.y); ctx.lineTo(p.x - s * 0.3, p.y - s * 0.3); ctx.closePath();
        }
        ctx.shadowColor = `hsla(${p.hue},100%,80%,0.5)`; ctx.shadowBlur = 6; ctx.fill();
      });
      ctx.shadowBlur = 0; ctx.restore();
    }

    function drawGraffitiText(text, x, y, size) {
      ctx.save(); ctx.translate(x, y); ctx.rotate(Math.sin(time * 0.4) * 0.04);
      const scale = 1 + Math.sin(time * 1.5) * 0.08; ctx.scale(scale, scale);
      ctx.shadowColor = `hsla(${colors.neon},100%,100%,0.7)`; ctx.shadowBlur = 15;
      ctx.font = `${size}px Graffiti,Arial`; ctx.fillStyle = '#000'; ctx.fillText(text, 0, 0);
      ctx.strokeStyle = `hsla(${colors.secondary},100%,70%,0.8)`; ctx.lineWidth = 2; ctx.strokeText(text, 0, 0);
      if (glitchTimer > GLITCH_INTERVAL - 1) {
        ctx.fillStyle = `hsla(${colors.neon},100%,100%,0.7)`; ctx.fillText(text, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);
      }
      ctx.shadowBlur = 0; ctx.restore();
    }

    addEventListener('resize', () => { c.width = innerWidth; c.height = innerHeight; });

    draw();
  </script>
</body>
</html>