<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy Hip-Hop 3D-Like Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    @font-face {
      font-family: 'GraffitiFont';
      src: url('https://fonts.googleapis.com/css2?family=Urbanist:wght@700&display=swap');
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Animation variables
    let time = 0;
    let glitchTimer = 0;
    const GLITCH_INTERVAL = 20; // Glitch every ~0.33 seconds
    let frameCounter = 0;
    let lastFrameTime = 0;
    let fps = 0;
    
    // Camera
    const camera = {
      x: 0,
      y: 0,
      zoom: 1,
      angle: 0
    };
    
    // Particles
    const particles = [];
    for (let i = 0; i < 40; i++) {
      particles.push({
        x: Math.random() * canvas.width - canvas.width / 2,
        y: Math.random() * canvas.height - canvas.height / 2,
        z: Math.random() * 200 - 100, // 3D-like depth
        baseX: Math.random() * 1000,
        baseY: Math.random() * 1000,
        size: Math.random() * 6 + 4,
        hue: Math.random() * 360,
        alpha: Math.random() * 0.4 + 0.6,
        type: Math.random() < 0.33 ? 'circle' : Math.random() < 0.66 ? 'triangle' : 'square',
        trail: []
      });
    }
    
    // Fractal flames
    const flames = [];
    for (let i = 0; i < 3; i++) {
      flames.push({
        scale: Math.random() * 80 + 120,
        angle: Math.random() * Math.PI * 2,
        variation: ['swirl', 'spherical', 'handkerchief', 'bubble'][Math.floor(Math.random() * 4)],
        hue: Math.random() * 360,
        speed: Math.random() * 0.07 + 0.05,
        z: Math.random() * 100 - 50
      });
    }
    
    // Graffiti splatters
    const splatters = [];
    for (let i = 0; i < 12; i++) {
      splatters.push({
        x: Math.random() * canvas.width - canvas.width / 2,
        y: Math.random() * canvas.height - canvas.height / 2,
        z: Math.random() * 100 - 50,
        size: Math.random() * 20 + 10,
        hue: Math.random() * 360,
        alpha: Math.random() * 0.3 + 0.3
      });
    }
    
    function draw() {
      // Motion blur
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Update camera
      camera.x = Math.sin(time * 0.15) * 100;
      camera.y = Math.cos(time * 0.15) * 100;
      camera.zoom = 0.8 + Math.sin(time * 0.1) * 0.2;
      camera.angle = Math.sin(time * 0.05) * 0.1;
      
      ctx.save();
      ctx.translate(canvas.width / 2 + camera.x, canvas.height / 2 + camera.y);
      ctx.scale(camera.zoom, camera.zoom);
      ctx.rotate(camera.angle);
      
      time += 0.07;
      frameCounter++;
      glitchTimer++;
      if (glitchTimer > GLITCH_INTERVAL) glitchTimer = 0;
      
      // Calculate FPS
      const currentTime = performance.now();
      if (currentTime - lastFrameTime > 1000) {
        fps = frameCounter / ((currentTime - lastFrameTime) / 1000);
        frameCounter = 0;
        lastFrameTime = currentTime;
        console.log(`FPS: ${fps.toFixed(1)}`);
      }
      
      // Layer 1: Neon gradient background
      drawNeonBackground();
      
      // Layer 2: Spirograph patterns
      drawSpirograph();
      
      // Layer 3: Kaleidoscope patterns
      drawKaleidoscope();
      
      // Layer 4: Particles with trails
      particles.forEach(p => {
        const nx = Math.sin(time * 0.8 + p.baseX);
        const ny = Math.cos(time * 0.8 + p.baseY);
        p.x += nx * 2.5;
        p.y += ny * 2.5;
        p.z += Math.sin(time + p.baseX) * 0.5;
        if (p.x < -canvas.width / 2) p.x += canvas.width;
        if (p.x > canvas.width / 2) p.x -= canvas.width;
        if (p.y < -canvas.height / 2) p.y += canvas.height;
        if (p.y > canvas.height / 2) p.y -= canvas.height;
        p.size = Math.max(4, Math.min(10, p.size + Math.sin(time + p.baseX) * 0.3));
        p.hue = (p.hue + 2.5) % 360;
        
        // 3D projection
        const scale = 200 / (200 + p.z);
        const px = p.x * scale;
        const py = p.y * scale;
        const psize = p.size * scale;
        
        // Trails
        p.trail.push({ x: px, y: py, alpha: p.alpha });
        if (p.trail.length > 8) p.trail.shift();
        p.trail.forEach((t, i) => {
          ctx.fillStyle = `hsla(${p.hue}, 90%, 90%, ${t.alpha * (i / 8)})`;
          ctx.beginPath();
          ctx.arc(t.x, t.y, psize * (i / 8), 0, Math.PI * 2);
          ctx.fill();
        });
        
        // Main particle
        ctx.fillStyle = `hsla(${p.hue}, 90%, 90%, ${p.alpha * scale})`;
        ctx.beginPath();
        if (p.type === 'circle') {
          ctx.arc(px, py, psize / 2, 0, Math.PI * 2);
        } else if (p.type === 'triangle') {
          const s = psize / 2;
          ctx.moveTo(px - s, py + s);
          ctx.lineTo(px + s, py + s);
          ctx.lineTo(px, py - s);
          ctx.closePath();
        } else {
          const s = psize / 2;
          ctx.rect(px - s, py - s, psize, psize);
        }
        ctx.fill();
      });
      
      // Layer 5: Grid overlay
      drawGridOverlay();
      
      // Layer 6: Graffiti splatters
      drawSplatters();
      
      ctx.restore();
      
      // Layer 7: Graffiti text
      const textX = canvas.width - 220 + Math.sin(time * 1) * 10;
      const textY = canvas.height - 50 + Math.cos(time * 1) * 10;
      drawGraffitiText("MrProphecy", textX, textY, 40);
      
      // Debug: FPS and frame counter
      ctx.fillStyle = 'hsla(0, 0%, 100%, 0.5)';
      ctx.font = '16px GraffitiFont';
      ctx.fillText(`FPS: ${fps.toFixed(1)} | Frame: ${frameCounter}`, 10, 20);
      
      requestAnimationFrame(draw);
    }
    
    function drawNeonBackground() {
      const gradient = ctx.createLinearGradient(0, -canvas.height / 2, 0, canvas.height / 2);
      const hue1 = (Math.sin(time * 0.4) * 180 + 180) % 360;
      const hue2 = (hue1 + 180) % 360;
      gradient.addColorStop(0, `hsla(${hue1}, 70%, 60%, 0.3)`);
      gradient.addColorStop(1, `hsla(${hue2}, 70%, 60%, 0.3)`);
      ctx.fillStyle = gradient;
      ctx.fillRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);
      
      // Neon horizon
      const glowHue = (Math.sin(time * 0.5) * 180 + 180) % 360;
      ctx.fillStyle = `hsla(${glowHue}, 80%, 70%, 0.2)`;
      ctx.fillRect(-canvas.width / 2, -20, canvas.width, 40);
    }
    
    function drawSpirograph() {
      for (let layer = 0; layer < 3; layer++) {
        const R = 160 + Math.sin(time * 1.2 + layer) * 60;
        const r = 40 + Math.cos(time * 0.9 + layer) * 25;
        const d = 30 + Math.sin(time * 1 + layer) * 35;
        const z = Math.sin(time + layer) * 50;
        const scale = 200 / (200 + z);
        const gradient = ctx.createLinearGradient(-R * scale, 0, R * scale, 0);
        gradient.addColorStop(0, `hsla(${(60 + Math.sin(time + layer * 2) * 90) % 360}, 90%, 90%, 0.8)`);
        gradient.addColorStop(1, `hsla(${(60 + Math.sin(time + layer * 2 + 1) * 90) % 360}, 90%, 90%, 0.8)`);
        ctx.beginPath();
        for (let t = 0; t < Math.PI * 5; t += 0.015) {
          const x = (R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t + layer * 0.6);
          const y = (R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t + layer * 0.6);
          const glitchX = glitchTimer > GLITCH_INTERVAL - 3 ? (Math.random() - 0.5) * 8 : 0;
          const px = x * scale + glitchX;
          const py = y * scale;
          if (t === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = gradient;
        ctx.lineWidth = (1.2 + layer * 0.4) * scale;
        ctx.stroke();
      }
    }
    
    function drawKaleidoscope() {
      const segments = 8;
      flames.forEach((f, i) => {
        const radius = f.scale + Math.sin(time * 0.8 + i) * 35;
        const z = f.z + Math.sin(time + i) * 20;
        const scale = 200 / (200 + z);
        for (let s = 0; s < segments; s++) {
          ctx.save();
          ctx.rotate(Math.PI * 2 * s / segments);
          ctx.beginPath();
          for (let t = 0; t < Math.PI * 2; t += 0.02) {
            let x, y;
            if (f.variation === 'swirl') {
              const r = radius * Math.sin(7 * t + time + i);
              x = r * Math.cos(t + Math.sin(r * 0.06 + time));
              y = r * Math.sin(t + Math.sin(r * 0.06 + time));
            } else if (f.variation === 'spherical') {
              const r = radius / (1 + Math.cos(t * 6 + time + i));
              x = r * Math.cos(t);
              y = r * Math.sin(t);
            } else if (f.variation === 'handkerchief') {
              const r = radius * Math.cos(t * 8 + time + i);
              x = r * Math.cos(t) / (1 + Math.sin(t * t + time));
              y = r * Math.sin(t) / (1 + Math.sin(t * t + time));
            } else {
              const r = radius * Math.sin(5 * t + time + i);
              x = r * Math.cos(t + r * 0.03);
              y = r * Math.sin(t + r * 0.03);
            }
            const glitchY = glitchTimer > GLITCH_INTERVAL - 3 ? (Math.random() - 0.5) * 8 : 0;
            const px = x * scale;
            const py = y * scale + glitchY;
            if (t === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.strokeStyle = `hsla(${(f.hue + s * 12) % 360}, 90%, 90%, ${0.7 * scale})`;
          ctx.lineWidth = 0.9 * scale;
          ctx.stroke();
          ctx.restore();
        }
        f.hue = (f.hue + 2.2) % 360;
        f.angle += f.speed;
        f.scale = Math.max(80, Math.min(200, f.scale + Math.sin(time + i) * 3));
        f.z = Math.max(-50, Math.min(50, f.z + Math.sin(time + i) * 1));
      });
    }
    
    function drawGridOverlay() {
      const z = Math.sin(time * 0.5) * 50;
      const scale = 200 / (200 + z);
      ctx.strokeStyle = `hsla(180, 50%, 50%, ${0.15 + Math.sin(time * 0.5) * 0.05})`;
      ctx.lineWidth = 0.5 * scale;
      for (let x = -canvas.width / 2; x < canvas.width / 2; x += 50 * scale) {
        ctx.beginPath();
        ctx.moveTo(x, -canvas.height / 2);
        ctx.lineTo(x, canvas.height / 2);
        ctx.stroke();
      }
      for (let y = -canvas.height / 2; y < canvas.height / 2; y += 50 * scale) {
        ctx.beginPath();
        ctx.moveTo(-canvas.width / 2, y);
        ctx.lineTo(canvas.width / 2, y);
        ctx.stroke();
      }
    }
    
    function drawSplatters() {
      splatters.forEach(s => {
        const scale = 200 / (200 + s.z);
        ctx.fillStyle = `hsla(${s.hue}, 80%, 70%, ${s.alpha * scale * (0.5 + Math.sin(time * 0.3) * 0.2)})`;
        ctx.beginPath();
        ctx.arc(s.x * scale, s.y * scale, s.size * scale, 0, Math.PI * 2);
        ctx.fill();
        s.hue = (s.hue + 1) % 360;
        s.alpha = Math.max(0.3, Math.min(0.6, s.alpha + Math.sin(time + s.x) * 0.01));
        s.z += Math.sin(time + s.x) * 0.5;
        s.z = Math.max(-50, Math.min(50, s.z));
      });
    }
    
    function drawGraffitiText(text, x, y, size) {
      // 3D-like tilt
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.sin(time * 0.5) * 0.1);
      ctx.shadowColor = 'hsla(60, 100%, 100%, 0.5)';
      ctx.shadowBlur = 10;
      ctx.font = `${size}px GraffitiFont`;
      ctx.fillStyle = 'hsla(60, 100%, 100%, 1)';
      ctx.fillText(text, 0, 0);
      ctx.strokeStyle = 'hsla(0, 0%, 0%, 0.8)';
      ctx.lineWidth = 2;
      ctx.strokeText(text, 0, 0);
      ctx.shadowBlur = 0;
      
      // Glitch effects
      if (glitchTimer > GLITCH_INTERVAL - 3) {
        ctx.fillStyle = 'hsla(180, 100%, 100%, 0.8)';
        ctx.fillText(text, (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 12);
        ctx.fillStyle = 'hsla(300, 100%, 100%, 0.8)';
        ctx.fillText(text, (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 12);
      }
      
      // Spray-paint splatter
      if (Math.random() < 0.1) {
        const sx = (Math.random() - 0.5) * 50;
        const sy = (Math.random() - 0.5) * 20;
        ctx.fillStyle = `hsla(${(Math.sin(time) * 180 + 180) % 360}, 80%, 70%, 0.4)`;
        ctx.beginPath();
        ctx.arc(sx, sy, Math.random() * 10 + 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      console.log("Canvas resized:", canvas.width, canvas.height);
    });
    
    // Start animation
    draw();
  </script>
</body>
</html>