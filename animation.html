<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy Hip-Hop Fractal Animation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    @font-face {
      font-family: 'HipHopFont';
      src: url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
    }
  </style>
</head>
<body>
  <script>
    let particles = [];
    let flames = [];
    let time = 0;
    let glitchTimer = 0;
    const GLITCH_INTERVAL = 30; // Glitch every ~0.5 seconds
    let frameCounter = 0;
    let lastFrameTime = 0;
    let fps = 0;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 1);
      translate(width / 2, height / 2);
      console.log("Setup complete:", windowWidth, windowHeight);

      // Initialize particles (reduced count)
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: random(-width / 2, width / 2),
          y: random(-height / 2, height / 2),
          baseX: random(1000),
          baseY: random(1000),
          size: random(4, 10),
          hue: random(360),
          alpha: random(0.6, 1),
          type: random(['circle', 'triangle'])
        });
      }

      // Initialize fractal flames (reduced count)
      for (let i = 0; i < 2; i++) {
        flames.push({
          x: 0,
          y: 0,
          scale: random(100, 200),
          angle: random(TWO_PI),
          variation: random(['swirl', 'spherical']),
          hue: random(360),
          speed: random(0.05, 0.1)
        });
      }
    }

    function draw() {
      background(0, 0, 0, 0.12); // Light trails for motion blur
      translate(width / 2, height / 2);
      time += 0.05; // Faster evolution
      frameCounter++;

      // Calculate FPS
      let currentTime = millis();
      if (currentTime - lastFrameTime > 1000) {
        fps = frameCounter / (currentTime / 1000);
        frameCounter = 0;
        lastFrameTime = currentTime;
        console.log("FPS:", fps.toFixed(1));
      }

      // Layer 1: Static gradient with subtle animation
      drawGradientBackground();

      // Layer 2: Spirograph patterns
      drawSpirograph();

      // Layer 3: Kaleidoscope with fractal flames
      drawKaleidoscope();

      // Layer 4: Particle system
      for (let p of particles) {
        p.x += map(noise(p.baseX + time * 0.6), 0, 1, -2, 2);
        p.y += map(noise(p.baseY + time * 0.6), 0, 1, -2, 2);
        if (p.x < -width / 2) p.x += width;
        if (p.x > width / 2) p.x -= width;
        if (p.y < -height / 2) p.y += height;
        if (p.y > height / 2) p.y -= height;
        p.size = constrain(p.size + sin(time + p.baseX) * 0.2, 4, 10);
        fill(p.hue, 90, 90, p.alpha);
        noStroke();
        push();
        translate(p.x, p.y);
        if (p.type === 'circle') {
          ellipse(0, 0, p.size);
        } else {
          triangle(-p.size / 2, p.size / 2, p.size / 2, p.size / 2, 0, -p.size / 2);
        }
        pop();
        p.hue = (p.hue + 1.8) % 360;
      }

      // Layer 5: Urban grid overlay
      drawGridOverlay();

      // Layer 6: Glitchy text
      push();
      translate(-width / 2, -height / 2);
      let textX = width - 220 + sin(time * 0.8) * 10;
      let textY = height - 60 + cos(time * 0.8) * 10;
      drawGlitchText("MrProphecy", textX, textY, 40);

      // Debug: FPS and frame counter
      fill(0, 0, 100, 0.5);
      textSize(16);
      textFont('Orbitron');
      text(`FPS: ${fps.toFixed(1)} | Frame: ${frameCounter}`, 10, 20);
      pop();

      glitchTimer++;
      if (glitchTimer > GLITCH_INTERVAL) {
        glitchTimer = 0;
      }
    }

    function drawGradientBackground() {
      // Lightweight animated gradient
      for (let r = 0; r < max(width, height) / 2; r += 12) {
        let hue = (sin(time * 0.3 + r * 0.015) * 180 + 180) % 360;
        fill(hue, 50, 50, 0.2);
        noStroke();
        ellipse(0, 0, r * 2, r * 2);
      }
    }

    function drawSpirograph() {
      // Optimized Spirograph curves
      for (let layer = 0; layer < 2; layer++) {
        let R = 180 + sin(time * 0.9 + layer) * 60;
        let r = 50 + cos(time * 0.7 + layer) * 30;
        let d = 40 + sin(time * 0.8 + layer) * 40;
        let points = [];
        for (let t = 0; t < TWO_PI * 4; t += 0.01) {
          let x = (R - r) * cos(t) + d * cos((R - r) / r * t + layer * 0.4);
          let y = (R - r) * sin(t) - d * sin((R - r) / r * t + layer * 0.4);
          points.push({ x: x * (0.4 + layer * 0.1), y: y * (0.4 + layer * 0.1) });
        }
        stroke((60 + sin(time + layer * 2) * 90) % 360, 90, 90, 0.8);
        strokeWeight(1 + layer * 0.3);
        noFill();
        beginShape();
        for (let p of points) {
          let glitchX = glitchTimer > GLITCH_INTERVAL - 4 ? random(-8, 8) : 0;
          vertex(p.x + glitchX, p.y);
        }
        endShape();
      }
    }

    function drawKaleidoscope() {
      // Optimized kaleidoscope with FLAM3 variations
      let segments = 8;
      for (let i = 0; i < flames.length; i++) {
        let f = flames[i];
        let points = [];
        let radius = f.scale + sin(time * 0.6 + i) * 40;
        for (let t = 0; t < TWO_PI; t += 0.015) {
          let x, y, r;
          if (f.variation === 'swirl') {
            r = radius * sin(7 * t + time + i);
            x = r * cos(t + sin(r * 0.05 + time));
            y = r * sin(t + sin(r * 0.05 + time));
          } else {
            r = radius / (1 + cos(t * 6 + time + i));
            x = r * cos(t);
            y = r * sin(t);
          }
          points.push({ x, y });
        }
        for (let s = 0; s < segments; s++) {
          push();
          rotate(TWO_PI * s / segments);
          stroke((f.hue + s * 15) % 360, 90, 90, 0.7);
          strokeWeight(0.8);
          noFill();
          beginShape();
          for (let p of points) {
            let glitchY = glitchTimer > GLITCH_INTERVAL - 4 ? random(-8, 8) : 0;
            vertex(p.x, p.y + glitchY);
          }
          endShape();
          pop();
        }
        f.hue = (f.hue + 1.5) % 360;
        f.angle += f.speed;
        f.scale = constrain(f.scale + sin(time + i) * 2, 80, 200);
      }
    }

    function drawGridOverlay() {
      stroke(180, 50, 50, 0.15);
      strokeWeight(0.6);
      for (let x = -width / 2; x < width / 2; x += 70) {
        line(x, -height / 2, x, height / 2);
      }
      for (let y = -height / 2; y < height / 2; y += 70) {
        line(-width / 2, y, width / 2, y);
      }
    }

    function drawGlitchText(text, x, y, size) {
      fill(60, 100, 100, 1); // Neon yellow
      textSize(size);
      textStyle(BOLD);
      textFont('Orbitron');
      text(text, x, y);
      if (glitchTimer > GLITCH_INTERVAL - 4) {
        fill(180, 100, 100, 0.8); // Cyan
        text(text, x + random(-10, 10), y + random(-10, 10));
        fill(300, 100, 100, 0.8); // Magenta
        text(text, x + random(-10, 10), y + random(-10, 10));
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      console.log("Canvas resized:", windowWidth, windowHeight);
    }
  </script>
</body>
</html>