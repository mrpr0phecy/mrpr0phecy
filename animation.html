<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy Hip-Hop 2D Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    @font-face {
      font-family: 'GraffitiFont';
      src: url('https://fonts.googleapis.com/css2?family=Anton&display=swap');
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const baseHue = Math.random() * 360;
    const colors = {
      primary: baseHue,
      secondary: (baseHue + 120) % 360,
      tertiary: (baseHue + 240) % 360,
      accent: (baseHue + 30) % 360
    };
    
    let time = 0;
    let glitchTimer = 0;
    const GLITCH_INTERVAL = 10;
    
    const noise = [];
    const noiseSize = 64;
    for (let i = 0; i < noiseSize; i++) {
      noise[i] = [];
      for (let j = 0; j < noiseSize; j++) {
        noise[i][j] = Math.random();
      }
    }
    function getNoise(x, y) {
      const xi = Math.floor(x) % noiseSize;
      const yi = Math.floor(y) % noiseSize;
      const xf = x - Math.floor(x);
      const yf = y - Math.floor(y);
      const v00 = noise[xi][yi];
      const v10 = noise[(xi + 1) % noiseSize][yi];
      const v01 = noise[xi][(yi + 1) % noiseSize];
      const v11 = noise[(xi + 1) % noiseSize][(yi + 1) % noiseSize];
      const u = xf * xf * (3 - 2 * xf);
      const v = yf * yf * (3 - 2 * yf);
      return v00 + u * (v10 - v00) + v * (v01 - v00 + u * (v11 - v01 - v10 + v00));
    }
    
    const particles = [];
    for (let i = 0; i < 30; i++) {
      particles.push({
        x: Math.random() * canvas.width - canvas.width / 2,
        y: Math.random() * canvas.height - canvas.height / 2,
        baseX: Math.random() * 1000,
        baseY: Math.random() * 1000,
        size: Math.random() * 5 + 3,
        hue: colors[Math.random() < 0.5 ? 'primary' : 'secondary'],
        alpha: Math.random() * 0.3 + 0.5,
        angle: Math.random() * Math.PI * 2,
        speed: Math.random() * 0.015 + 0.005,
        radius: Math.random() * 80 + 40
      });
    }
    
    const splatters = [];
    for (let i = 0; i < 10; i++) {
      splatters.push({
        x: Math.random() * canvas.width - canvas.width / 2,
        y: Math.random() * canvas.height - canvas.height / 2,
        size: Math.random() * 15 + 8,
        hue: colors.accent,
        alpha: Math.random() * 0.2 + 0.3,
        shape: Math.random() < 0.5 ? 'circle' : 'drip',
        angle: Math.random() * Math.PI * 2,
        speed: Math.random() * 0.01 + 0.005,
        radius: Math.random() * 60 + 30
      });
    }
    
    let spirographParams = {
      R: 140,
      r: 35,
      d: 25,
      dash: [3, 3]
    };
    
    function updateSpirographParams() {
      if (Math.random() < 0.005) {
        spirographParams = {
          R: 130 + Math.random() * 20,
          r: 30 + Math.random() * 10,
          d: 20 + Math.random() * 10,
          dash: Math.random() < 0.5 ? [3, 3] : [5, 5]
        };
      }
    }
    
    function draw() {
      try {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        
        time += 0.02; // Very slow time increment
        glitchTimer++;
        if (glitchTimer > GLITCH_INTERVAL) glitchTimer = 0;
        
        drawDarkGradientBackground();
        drawClouds();
        drawSpirograph();
        drawParticles();
        drawSplatters();
        drawGraffitiText("www.youtube.com/mrprophecy", canvas.width - 300, canvas.height - 30, 24);
        drawVignette();
        
        requestAnimationFrame(draw);
      } catch (e) {
        console.error("Error in draw function:", e);
      }
    }
    
    function drawDarkGradientBackground() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, `hsla(${colors.primary}, 70%, 20%, 0.5)`);
      gradient.addColorStop(1, `hsla(${colors.secondary}, 70%, 20%, 0.5)`);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
    
    function drawClouds() {
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      for (let x = -canvas.width / 2; x < canvas.width / 2; x += 50) {
        for (let y = -canvas.height / 2; y < canvas.height / 2; y += 50) {
          const dist = Math.sqrt(x * x + y * y);
          const n = getNoise((x + time * 8) / 50, (y + time * 5) / 50);
          if (n > 0.5) {
            const scale = 1 + dist / Math.max(canvas.width, canvas.height) * 3;
            ctx.fillStyle = `hsla(${colors.tertiary}, 50%, 50%, ${n * 0.07 * (1 - dist / 500)})`;
            ctx.beginPath();
            ctx.arc(x * scale, y * scale, 15, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      ctx.restore();
    }
    
    function drawSpirograph() {
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.rotate(time * 0.02); // Very slow axis spin
      updateSpirographParams();
      for (let layer = 0; layer < 3; layer++) {
        const R = spirographParams.R + Math.sin(time * 0.1 + layer) * 20;
        const r = spirographParams.r + Math.cos(time * 0.07 + layer) * 6;
        const d = spirographParams.d + Math.sin(time * 0.05 + layer) * 10;
        ctx.beginPath();
        for (let t = 0; t < Math.PI * 5; t += 0.05) {
          const x = (R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t + layer * 0.3);
          const y = (R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t + layer * 0.3);
          const glitchX = glitchTimer > GLITCH_INTERVAL - 3 ? (Math.random() - 0.5) * 3 : 0;
          if (t === 0) ctx.moveTo(x, y + glitchX);
          else ctx.lineTo(x, y + glitchX);
        }
        ctx.strokeStyle = `hsla(${(colors[layer % 2 ? 'primary' : 'secondary'] + layer * 90) % 360}, 90%, 90%, 0.8)`;
        ctx.lineWidth = 2.5 + layer * 0.6;
        ctx.shadowColor = `hsla(${(colors[layer % 2 ? 'primary' : 'secondary'] + layer * 90) % 360}, 90%, 90%, 0.6)`;
        ctx.shadowBlur = 20;
        ctx.globalCompositeOperation = 'screen';
        if (layer % 2 === 1) ctx.setLineDash(spirographParams.dash);
        else ctx.setLineDash([]);
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
      }
      ctx.setLineDash([]);
      ctx.restore();
    }
    
    function drawParticles() {
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      particles.forEach(p => {
        p.angle += p.speed;
        p.x = p.radius * Math.cos(p.angle + Math.sin(time + p.baseX) * 0.08);
        p.y = p.radius * Math.sin(p.angle + Math.cos(time + p.baseY) * 0.08);
        p.radius = Math.max(40, Math.min(150, p.radius + Math.sin(time + p.baseX) * 1.5));
        p.size = Math.max(3, Math.min(8, p.size + Math.sin(time + p.baseX) * 0.2));
        p.hue = (p.hue + 1.5) % 360;
        
        ctx.fillStyle = `hsla(${p.hue}, 90%, 90%, ${p.alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    }
    
    function drawSplatters() {
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      splatters.forEach(s => {
        s.angle += s.speed;
        s.x = s.radius * Math.cos(s.angle + Math.sin(time + s.x) * 0.08);
        s.y = s.radius * Math.sin(s.angle + Math.cos(time + s.y) * 0.08);
        s.radius = Math.max(30, Math.min(120, s.radius + Math.sin(time + s.x) * 1));
        ctx.fillStyle = `hsla(${s.hue}, 80%, 70%, ${s.alpha * (0.5 + Math.sin(time * 0.2) * 0.2)})`;
        ctx.beginPath();
        if (s.shape === 'circle') {
          ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        } else {
          const sSize = s.size;
          ctx.moveTo(s.x, s.y - sSize);
          ctx.quadraticCurveTo(s.x + sSize * 0.5, s.y, s.x, s.y + sSize);
          ctx.quadraticCurveTo(s.x - sSize * 0.5, s.y, s.x, s.y - sSize);
          ctx.closePath();
        }
        ctx.fill();
        s.hue = (s.hue + 0.8) % 360;
      });
      ctx.restore();
    }
    
    function drawGraffitiText(text, x, y, size) {
      ctx.save();
      ctx.translate(x, y);
      const scale = 1 + Math.sin(time * 1.2) * 0.06;
      ctx.scale(scale, scale);
      ctx.shadowColor = `hsla(${colors.primary}, 100%, 100%, ${0.6 + Math.sin(time * 0.3) * 0.2})`;
      ctx.shadowBlur = 15;
      ctx.font = `${size}px GraffitiFont, Arial, sans-serif`;
      ctx.fillStyle = 'hsla(0, 0%, 0%, 1)';
      ctx.fillText(text, 0, 0);
      ctx.strokeStyle = `hsla(${colors.accent}, 100%, 70%, 0.8)`;
      ctx.lineWidth = 1.5;
      ctx.strokeText(text, 0, 0);
      ctx.shadowBlur = 0;
      
      if (glitchTimer > GLITCH_INTERVAL - 3) {
        ctx.fillStyle = `hsla(${colors.tertiary}, 100%, 100%, 0.7)`;
        ctx.fillText(text, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);
      }
      
      if (Math.random() < 0.3) {
        const sx = (Math.random() - 0.5) * 40;
        const sy = (Math.random() - 0.5) * 20;
        ctx.fillStyle = `hsla(${colors.primary}, 80%, 70%, 0.4)`;
        ctx.beginPath();
        if (Math.random() < 0.5) {
          ctx.arc(sx, sy, Math.random() * 8 + 4, 0, Math.PI * 2);
        } else {
          const sSize = Math.random() * 8 + 4;
          ctx.moveTo(sx, sy - sSize);
          ctx.quadraticCurveTo(sx + sSize * 0.5, sy, sx, sy + sSize);
          ctx.quadraticCurveTo(sx - sSize * 0.5, sy, sx, sy - sSize);
          ctx.closePath();
        }
        ctx.fill();
      }
      ctx.restore();
    }
    
    function drawVignette() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2);
      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }
    
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
    
    draw();
  </script>
</body>
</html>