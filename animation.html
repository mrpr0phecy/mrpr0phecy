<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy Hip-Hop Fractal Animation</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    @font-face {
      font-family: 'HipHopFont';
      src: url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
    }
  </style>
</head>
<body>
  <script>
    let particles = [];
    let flames = [];
    let time = 0;
    let glitchTimer = 0;
    const GLITCH_INTERVAL = 60; // Glitch every ~1 second at 60 FPS
    let noiseScale = 0.002;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 1);
      translate(width / 2, height / 2);

      // Initialize particles
      for (let i = 0; i < 150; i++) {
        particles.push({
          x: random(-width / 2, width / 2),
          y: random(-height / 2, height / 2),
          baseX: random(1000),
          baseY: random(1000),
          size: random(3, 12),
          hue: random(360),
          alpha: random(0.5, 0.9),
          type: random(['circle', 'triangle', 'square'])
        });
      }

      // Initialize fractal flames (inspired by FLAM3)
      for (let i = 0; i < 3; i++) {
        flames.push({
          x: 0,
          y: 0,
          scale: random(100, 200),
          angle: random(TWO_PI),
          variation: random(['swirl', 'spherical', 'horseshoe']),
          hue: random(360),
          speed: random(0.02, 0.05)
        });
      }

      // Optional: Audio input
      /*
      mic = new p5.AudioIn();
      mic.start();
      */
    }

    function draw() {
      background(0, 0, 0, 0.08); // Subtle trails for motion blur
      translate(width / 2, height / 2);
      time += 0.02; // Fast evolution for dynamic motion

      // Layer 1: Noise-based gradient background
      drawGradientBackground();

      // Layer 2: Spirograph patterns
      drawSpirograph();

      // Layer 3: Kaleidoscope with fractal flames
      drawKaleidoscope();

      // Layer 4: Particle system
      /*
      let vol = mic.getLevel();
      */
      for (let p of particles) {
        p.x += map(noise(p.baseX + time * 0.3), 0, 1, -2, 2);
        p.y += map(noise(p.baseY + time * 0.3), 0, 1, -2, 2);
        if (p.x < -width / 2) p.x += width;
        if (p.x > width / 2) p.x -= width;
        if (p.y < -height / 2) p.y += height;
        if (p.y > height / 2) p.y -= height;
        p.size = constrain(p.size + sin(time + p.baseX) * 0.2 /* + map(vol, 0, 1, 0, 4) */, 3, 12);
        fill(p.hue, 80, 80, p.alpha);
        noStroke();
        push();
        translate(p.x, p.y);
        if (p.type === 'circle') {
          ellipse(0, 0, p.size);
        } else if (p.type === 'triangle') {
          triangle(-p.size / 2, p.size / 2, p.size / 2, p.size / 2, 0, -p.size / 2);
        } else {
          rect(-p.size / 2, -p.size / 2, p.size, p.size);
        }
        pop();
        p.hue = (p.hue + 1) % 360;
      }

      // Layer 5: Urban grid overlay
      drawGridOverlay();

      // Layer 6: Glitchy text
      push();
      translate(-width / 2, -height / 2);
      let textX = width - 250 + sin(time * 0.5) * 8;
      let textY = height - 60 + cos(time * 0.5) * 8;
      drawGlitchText("MrProphecy", textX, textY, 48);
      pop();

      glitchTimer++;
      if (glitchTimer > GLITCH_INTERVAL) {
        glitchTimer = 0;
      }
    }

    function drawGradientBackground() {
      for (let x = -width / 2; x < width / 2; x += 8) {
        for (let y = -height / 2; y < height / 2; y += 8) {
          let n = noise(x * noiseScale, y * noiseScale, time * 0.4);
          let hue = map(n, 0, 1, 0, 360);
          fill(hue, 60, 60, 0.25);
          noStroke();
          rect(x, y, 8, 8);
        }
      }
    }

    function drawSpirograph() {
      // Layered Spirograph curves
      for (let layer = 0; layer < 2; layer++) {
        let R = 180 + sin(time * 0.6 + layer) * 60;
        let r = 70 + cos(time * 0.4 + layer) * 30;
        let d = 50 + sin(time * 0.5 + layer) * 40;
        let points = [];
        for (let t = 0; t < TWO_PI * 4; t += 0.01) {
          let x = (R - r) * cos(t) + d * cos((R - r) / r * t);
          let y = (R - r) * sin(t) - d * sin((R - r) / r * t);
          points.push({ x: x * (0.5 + layer * 0.2), y: y * (0.5 + layer * 0.2) });
        }
        stroke((60 + sin(time + layer) * 60) % 360, 90, 90, 0.7);
        strokeWeight(1.5 + layer);
        noFill();
        beginShape();
        for (let p of points) {
          let glitchX = glitchTimer > GLITCH_INTERVAL - 8 ? random(-6, 6) : 0;
          vertex(p.x + glitchX, p.y);
        }
        endShape();
      }
    }

    function drawKaleidoscope() {
      // Kaleidoscope with FLAM3-inspired variations
      let segments = 8;
      for (let i = 0; i < flames.length; i++) {
        let f = flames[i];
        let points = [];
        let radius = f.scale + sin(time * 0.3) * 30;
        for (let t = 0; t < TWO_PI; t += 0.02) {
          let x, y;
          if (f.variation === 'swirl') {
            let r = radius * sin(7 * t + time);
            x = r * cos(t + sin(r * 0.02 + time));
            y = r * sin(t + sin(r * 0.02 + time));
          } else if (f.variation === 'spherical') {
            let r = radius / (1 + cos(t * 5 + time));
            x = r * cos(t);
            y = r * sin(t);
          } else {
            let r = radius * cos(t * 6 + time);
            x = r * cos(t) / (1 + sin(t * t + time));
            y = r * sin(t) / (1 + sin(t * t + time));
          }
          points.push({ x, y });
        }
        for (let s = 0; s < segments; s++) {
          push();
          rotate(TWO_PI * s / segments);
          stroke((f.hue + s * 20) % 360, 90, 90, 0.6);
          strokeWeight(1);
          noFill();
          beginShape();
          for (let p of points) {
            let glitchY = glitchTimer > GLITCH_INTERVAL - 8 ? random(-6, 6) : 0;
            vertex(p.x, p.y + glitchY);
          }
          endShape();
          pop();
        }
        f.hue = (f.hue + 0.8) % 360;
        f.angle += f.speed;
      }
    }

    function drawGridOverlay() {
      // Subtle urban grid for hip-hop vibe
      stroke(180, 50, 50, 0.2);
      strokeWeight(0.5);
      for (let x = -width / 2; x < width / 2; x += 50) {
        line(x, -height / 2, x, height / 2);
      }
      for (let y = -height / 2; y < height / 2; y += 50) {
        line(-width / 2, y, width / 2, y);
      }
    }

    function drawGlitchText(text, x, y, size) {
      fill(60, 100, 100, 1); // Neon yellow
      textSize(size);
      textStyle(BOLD);
      textFont('Orbitron');
      text(text, x, y);
      if (glitchTimer > GLITCH_INTERVAL - 8) {
        fill(180, 100, 100, 0.8); // Cyan
        text(text, x + random(-12, 12), y + random(-12, 12));
        fill(300, 100, 100, 0.8); // Magenta
        text(text, x + random(-12, 12), y + random(-12, 12));
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>