<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy Hip-Hop Spirograph & Kaleidoscope</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    @font-face {
      font-family: 'HipHopFont';
      src: url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
    }
  </style>
</head>
<body>
  <script>
    let particles = [];
    let time = 0;
    let glitchTimer = 0;
    const GLITCH_INTERVAL = 90; // Glitch every ~1.5 seconds
    let noiseScale = 0.005;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 1);
      // Center for Spirograph and kaleidoscope
      translate(width / 2, height / 2);

      // Initialize particles
      for (let i = 0; i < 100; i++) {
        particles.push({
          x: random(-width / 2, width / 2),
          y: random(-height / 2, height / 2),
          baseX: random(1000),
          baseY: random(1000),
          size: random(3, 10),
          hue: random(360),
          alpha: random(0.6, 1),
          type: random(['circle', 'triangle'])
        });
      }

      // Optional: Audio input
      /*
      mic = new p5.AudioIn();
      mic.start();
      */
    }

    function draw() {
      // Semi-transparent background for motion trails
      background(0, 0, 0, 0.1);
      translate(width / 2, height / 2); // Center all drawings
      time += 0.015; // Smooth evolution

      // Layer 1: Gradient background with subtle noise
      drawGradientBackground();

      // Layer 2: Spirograph patterns
      drawSpirograph();

      // Layer 3: Kaleidoscope patterns
      drawKaleidoscope();

      // Layer 4: Particle system
      /*
      let vol = mic.getLevel();
      */
      for (let p of particles) {
        // Noise-driven motion
        p.x += map(noise(p.baseX + time * 0.2), 0, 1, -1.5, 1.5);
        p.y += map(noise(p.baseY + time * 0.2), 0, 1, -1.5, 1.5);
        // Wrap around edges
        if (p.x < -width / 2) p.x += width;
        if (p.x > width / 2) p.x -= width;
        if p.y < -height / 2) p.y += height;
        if (p.y > height / 2) p.y -= height;
        p.size = constrain(p.size + sin(time + p.baseX) * 0.1 /* + map(vol, 0, 1, 0, 3) */, 3, 10);
        fill(p.hue, 80, 80, p.alpha);
        noStroke();
        push();
        translate(p.x, p.y);
        if (p.type === 'circle') {
          ellipse(0, 0, p.size);
        } else {
          triangle(-p.size / 2, p.size / 2, p.size / 2, p.size / 2, 0, -p.size / 2);
        }
        pop();
        p.hue = (p.hue + 0.7) % 360;
      }

      // Layer 5: Glitchy text
      push();
      translate(-width / 2, -height / 2); // Reset for text
      let textX = width - 220 + sin(time) * 5;
      let textY = height - 50 + cos(time) * 5;
      drawGlitchText("MrProphecy", textX, textY, 40);
      pop();

      glitchTimer++;
      if (glitchTimer > GLITCH_INTERVAL) {
        glitchTimer = 0;
      }
    }

    function drawGradientBackground() {
      // Subtle noise-based gradient
      for (let x = -width / 2; x < width / 2; x += 10) {
        for (let y = -height / 2; y < height / 2; y += 10) {
          let n = noise(x * noiseScale, y * noiseScale, time * 0.3);
          let hue = map(n, 0, 1, 0, 360);
          fill(hue, 50, 50, 0.3);
          noStroke();
          rect(x, y, 10, 10);
        }
      }
    }

    function drawSpirograph() {
      // Spirograph-like curves (hypotrochoid)
      let R = 200 + sin(time * 0.5) * 50; // Large radius
      let r = 80 + cos(time * 0.3) * 20; // Small radius
      let d = 60 + sin(time * 0.4) * 30; // Pen distance
      let points = [];
      for (let t = 0; t < TWO_PI * 3; t += 0.02) {
        let x = (R - r) * cos(t) + d * cos((R - r) / r * t);
        let y = (R - r) * sin(t) - d * sin((R - r) / r * t);
        points.push({ x: x * 0.5, y: y * 0.5 }); // Scale to fit
      }
      // Draw with neon colors and slight glitch
      stroke((60 + sin(time) * 30) % 360, 80, 80, 0.8);
      strokeWeight(2);
      noFill();
      beginShape();
      for (let p of points) {
        let glitchX = glitchTimer > GLITCH_INTERVAL - 10 ? random(-5, 5) : 0;
        vertex(p.x + glitchX, p.y);
      }
      endShape();
    }

    function drawKaleidoscope() {
      // Kaleidoscope with radial symmetry
      let segments = 6; // Number of mirrored segments
      let radius = 150 + sin(time * 0.4) * 30;
      for (let i = 0; i < segments; i++) {
        push();
        rotate(TWO_PI * i / segments);
        // Rose curve for complex patterns
        let points = [];
        for (let t = 0; t < TWO_PI; t += 0.05) {
          let r = radius * sin(5 * t + time);
          let x = r * cos(t);
          let y = r * sin(t);
          points.push({ x, y });
        }
        stroke((180 + cos(time) * 30) % 360, 80, 80, 0.7);
        strokeWeight(1.5);
        noFill();
        beginShape();
        for (let p of points) {
          let glitchY = glitchTimer > GLITCH_INTERVAL - 10 ? random(-5, 5) : 0;
          vertex(p.x, p.y + glitchY);
        }
        endShape();
        pop();
      }
    }

    function drawGlitchText(text, x, y, size) {
      fill(60, 100, 100, 1); // Neon yellow
      textSize(size);
      textStyle(BOLD);
      textFont('Orbitron');
      text(text, x, y);
      if (glitchTimer > GLITCH_INTERVAL - 10) {
        fill(180, 100, 100, 0.7); // Cyan glitch
        text(text, x + random(-10, 10), y + random(-10, 10));
        fill(300, 100, 100, 0.7); // Magenta glitch
        text(text, x + random(-10, 10), y + random(-10, 10));
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>