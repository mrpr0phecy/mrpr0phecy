<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MrProphecy 3D Hip-Hop Fractal Animation</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    #info { position: absolute; top: 10px; left: 10px; color: white; font-family: 'Urbanist', sans-serif; font-size: 16px; opacity: 0.5; }
    @font-face {
      font-family: 'GraffitiFont';
      src: url('https://fonts.googleapis.com/css2?family=Urbanist:wght@700&display=swap');
    }
  </style>
</head>
<body>
  <div id="info">FPS: 0 | Frame: 0</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // Animation variables
    let time = 0;
    let glitchTimer = 0;
    const GLITCH_INTERVAL = 20;
    let frameCounter = 0;
    let lastFrameTime = 0;
    let fps = 0;
    const infoDiv = document.getElementById('info');
    
    // Particles
    const particles = [];
    const particleCount = 30;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleColors = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    const particleTypes = [];
    for (let i = 0; i < particleCount; i++) {
      particlePositions[i * 3] = (Math.random() - 0.5) * 400;
      particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 400;
      particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 100;
      const hue = Math.random() * 360;
      const color = new THREE.Color(`hsl(${hue}, 90%, 90%)`);
      particleColors[i * 3] = color.r;
      particleColors[i * 3 + 1] = color.g;
      particleColors[i * 3 + 2] = color.b;
      particleSizes[i] = Math.random() * 4 + 2;
      particleTypes.push(Math.random() < 0.5 ? 'circle' : 'triangle');
      particles.push({ baseX: Math.random() * 1000, baseY: Math.random() * 1000, hue });
    }
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    const particleMaterial = new THREE.PointsMaterial({
      size: 5,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particleSystem);
    
    // Spirograph curves
    const spirographs = [];
    for (let layer = 0; layer < 2; layer++) {
      const geometry = new THREE.BufferGeometry();
      const points = [];
      const colors = [];
      const R = 100 + layer * 20;
      const r = 30 + layer * 10;
      const d = 20 + layer * 10;
      for (let t = 0; t < Math.PI * 4; t += 0.02) {
        const x = (R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t);
        const y = (R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t);
        const z = Math.sin(t + layer) * 20;
        points.push(x, y, z);
        const color = new THREE.Color(`hsl(${(60 + layer * 90) % 360}, 90%, 90%)`);
        colors.push(color.r, color.g, color.b);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7 });
      const spirograph = new THREE.Line(geometry, material);
      scene.add(spirograph);
      spirographs.push({ R, r, d });
    }
    
    // Kaleidoscope (simplified 3D prisms)
    const kaleidoscopes = [];
    for (let i = 0; i < 2; i++) {
      const geometry = new THREE.BufferGeometry();
      const points = [];
      const colors = [];
      const radius = 80 + i * 20;
      const variation = ['swirl', 'spherical'][i % 2];
      for (let t = 0; t < Math.PI * 2; t += 0.03) {
        let x, y, z;
        if (variation === 'swirl') {
          const r = radius * Math.sin(6 * t);
          x = r * Math.cos(t + Math.sin(r * 0.05));
          y = r * Math.sin(t + Math.sin(r * 0.05));
          z = Math.sin(t) * 30;
        } else {
          const r = radius / (1 + Math.cos(t * 5));
          x = r * Math.cos(t);
          y = r * Math.sin(t);
          z = Math.cos(t) * 30;
        }
        points.push(x, y, z);
        const color = new THREE.Color(`hsl(${(i * 90) % 360}, 90%, 90%)`);
        colors.push(color.r, color.g, color.b);
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      const material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7 });
      const kaleidoscope = new THREE.Line(geometry, material);
      scene.add(kaleidoscope);
      kaleidoscopes.push({ radius, variation });
    }
    
    // Grid
    const gridGeometry = new THREE.BufferGeometry();
    const gridPoints = [];
    const gridColors = [];
    for (let x = -200; x <= 200; x += 40) {
      gridPoints.push(x, -200, 0, x, 200, 0);
      gridPoints.push(-200, x, 0, 200, x, 0);
      const color = new THREE.Color('hsl(180, 50%, 50%)');
      for (let i = 0; i < 4; i++) {
        gridColors.push(color.r, color.g, color.b);
      }
    }
    gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPoints, 3));
    gridGeometry.setAttribute('color', new THREE.Float32BufferAttribute(gridColors, 3));
    const gridMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.2 });
    const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
    scene.add(grid);
    
    // Floating camera
    camera.position.set(0, 0, 200);
    
    function animate() {
      time += 0.08;
      frameCounter++;
      glitchTimer++;
      if (glitchTimer > GLITCH_INTERVAL) glitchTimer = 0;
      
      // Update FPS
      const currentTime = performance.now();
      if (currentTime - lastFrameTime > 1000) {
        fps = frameCounter / ((currentTime - lastFrameTime) / 1000);
        frameCounter = 0;
        lastFrameTime = currentTime;
        infoDiv.textContent = `FPS: ${fps.toFixed(1)} | Frame: ${frameCounter}`;
        console.log(`FPS: ${fps.toFixed(1)}`);
      }
      
      // Update camera
      camera.position.x = Math.sin(time * 0.1) * 150;
      camera.position.y = Math.cos(time * 0.1) * 150;
      camera.position.z = 150 + Math.sin(time * 0.05) * 50;
      camera.lookAt(0, 0, 0);
      
      // Update particles
      for (let i = 0; i < particleCount; i++) {
        const p = particles[i];
        particlePositions[i * 3] += Math.sin(time * 0.9 + p.baseX) * 1.5;
        particlePositions[i * 3 + 1] += Math.cos(time * 0.9 + p.baseY) * 1.5;
        particlePositions[i * 3 + 2] += Math.sin(time + p.baseX) * 0.5;
        if (Math.abs(particlePositions[i * 3]) > 200) particlePositions[i * 3] -= Math.sign(particlePositions[i * 3]) * 400;
        if (Math.abs(particlePositions[i * 3 + 1]) > 200) particlePositions[i * 3 + 1] -= Math.sign(particlePositions[i * 3 + 1]) * 400;
        particleSizes[i] = Math.max(2, Math.min(6, particleSizes[i] + Math.sin(time + p.baseX) * 0.2));
        p.hue = (p.hue + 2.5) % 360;
        const color = new THREE.Color(`hsl(${p.hue}, 90%, 90%)`);
        particleColors[i * 3] = color.r;
        particleColors[i * 3 + 1] = color.g;
        particleColors[i * 3 + 2] = color.b;
      }
      particleGeometry.attributes.position.needsUpdate = true;
      particleGeometry.attributes.color.needsUpdate = true;
      particleGeometry.attributes.size.needsUpdate = true;
      
      // Update Spirograph
      spirographs.forEach((s, layer) => {
        const points = [];
        const colors = [];
        const R = s.R + Math.sin(time * 1.2 + layer) * 20;
        const r = s.r + Math.cos(time * 0.9 + layer) * 10;
        const d = s.d + Math.sin(time * 1 + layer) * 15;
        for (let t = 0; t < Math.PI * 4; t += 0.02) {
          const x = (R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t);
          const y = (R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t);
          const z = Math.sin(t + time + layer) * 20;
          points.push(x, y, z);
          const hue = (60 + Math.sin(time + layer * 2) * 90) % 360;
          const color = new THREE.Color(`hsl(${hue}, 90%, 90%)`);
          colors.push(color.r, color.g, color.b);
        }
        spirographs[layer].geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        spirographs[layer].geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      });
      
      // Update Kaleidoscope
      kaleidoscopes.forEach((k, i) => {
        const points = [];
        const colors = [];
        const radius = k.radius + Math.sin(time * 0.8 + i) * 20;
        for (let t = 0; t < Math.PI * 2; t += 0.03) {
          let x, y, z;
          if (k.variation === 'swirl') {
            const r = radius * Math.sin(6 * t + time);
            x = r * Math.cos(t + Math.sin(r * 0.05 + time));
            y = r * Math.sin(t + Math.sin(r * 0.05 + time));
            z = Math.sin(t + time) * 30;
          } else {
            const r = radius / (1 + Math.cos(t * 5 + time));
            x = r * Math.cos(t);
            y = r * Math.sin(t);
            z = Math.cos(t + time) * 30;
          }
          points.push(x, y, z);
          const hue = (i * 90 + Math.sin(time) * 90) % 360;
          const color = new THREE.Color(`hsl(${hue}, 90%, 90%)`);
          colors.push(color.r, color.g, color.b);
        }
        kaleidoscopes[i].geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        kaleidoscopes[i].geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      });
      
      // Render
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    
    // Resize handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      console.log("Canvas resized:", window.innerWidth, window.innerHeight);
    });
    
    // Start animation
    animate();
  </script>
</body>
</html>