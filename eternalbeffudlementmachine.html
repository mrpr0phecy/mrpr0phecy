<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Eternal Befuddlement Machine</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Orbitron:wght@400;700;900&family=Glitch+Goblin&display=swap');

```
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        background: linear-gradient(45deg, #000, #1a0033, #330066, #000, #4d0080, #001a33);
        background-size: 600% 600%;
        animation: gradientShift 8s ease infinite;
        font-family: 'Orbitron', monospace;
        overflow-x: hidden;
        cursor: none;
        position: relative;
    }
    
    @keyframes gradientShift {
        0%, 100% { background-position: 0% 50%; }
        25% { background-position: 100% 0%; }
        50% { background-position: 100% 100%; }
        75% { background-position: 0% 100%; }
    }
    
    .matrix-rain {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: -2;
        opacity: 0.1;
    }
    
    .matrix-column {
        position: absolute;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        color: #00ff41;
        white-space: pre;
        line-height: 12px;
        animation: matrixFall linear infinite;
    }
    
    @keyframes matrixFall {
        from { transform: translateY(-100vh); }
        to { transform: translateY(100vh); }
    }
    
    .tetris-background {
        position: fixed;
        top: 20px;
        right: 20px;
        pointer-events: none;
        z-index: -1;
        opacity: 0.4;
        transform: scale(0.8);
    }
    
    .tetris-grid {
        display: grid;
        grid-template-columns: repeat(10, 15px);
        grid-template-rows: repeat(20, 15px);
        gap: 1px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(0, 0, 0, 0.3);
        border-radius: 5px;
    }
    
    .tetris-cell {
        background: transparent;
        border: 0.5px solid rgba(255, 255, 255, 0.1);
        transition: all 0.2s ease;
    }
    
    .tetris-cell.filled {
        background: var(--cell-color);
        box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.4);
        border: 0.5px solid rgba(255, 255, 255, 0.6);
    }
    
    .dvd-logo {
        position: fixed;
        width: 80px;
        height: 40px;
        background: linear-gradient(45deg, #ff00ff, #00ffff);
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 12px;
        color: white;
        z-index: 1;
        pointer-events: none;
        box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
    }
    
    .custom-cursor {
        position: fixed;
        width: 20px;
        height: 20px;
        border: 2px solid #ff00ff;
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        animation: cursorPulse 2s infinite;
    }
    
    .cursor-trail {
        position: fixed;
        width: 4px;
        height: 4px;
        background: #ff00ff;
        border-radius: 50%;
        pointer-events: none;
        z-index: 9998;
        opacity: 0.8;
    }
    
    @keyframes cursorPulse {
        0%, 100% { transform: scale(1); border-color: #ff00ff; }
        25% { transform: scale(1.5); border-color: #00ffff; }
        50% { transform: scale(2); border-color: #ffff00; }
        75% { transform: scale(1.2); border-color: #ff0000; }
    }
    
    .container {
        position: relative;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 2;
    }
    
    .title {
        font-family: 'Creepster', cursive;
        font-size: 3rem;
        color: #ff00ff;
        text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff;
        animation: titleGlitch 3s infinite;
        margin-bottom: 2rem;
        text-align: center;
        position: relative;
    }
    
    .title::before {
        content: attr(data-text);
        position: absolute;
        left: -2px;
        color: #00ffff;
        animation: glitchBefore 3s infinite;
        z-index: -1;
    }
    
    .title::after {
        content: attr(data-text);
        position: absolute;
        left: 2px;
        color: #ff0000;
        animation: glitchAfter 3s infinite;
        z-index: -1;
    }
    
    @keyframes titleGlitch {
        0%, 90%, 100% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
    }
    
    @keyframes glitchBefore {
        0%, 90%, 100% { transform: translate(0); }
        10% { transform: translate(-5px, 0); }
        20% { transform: translate(5px, 0); }
    }
    
    @keyframes glitchAfter {
        0%, 90%, 100% { transform: translate(0); }
        30% { transform: translate(5px, 0); }
        40% { transform: translate(-5px, 0); }
    }
    
    .optical-illusion {
        width: 300px;
        height: 300px;
        margin: 2rem;
        position: relative;
        animation: rotate360 10s linear infinite;
    }
    
    @keyframes rotate360 {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .spiral {
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: conic-gradient(from 0deg, #ff0080, #8000ff, #00ff80, #ff8000, #ff0080);
        animation: spiralSpin 5s linear infinite reverse;
        position: relative;
    }
    
    .spiral::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 150px;
        height: 150px;
        transform: translate(-50%, -50%);
        background: conic-gradient(from 180deg, #00ff80, #ff8000, #ff0080, #8000ff, #00ff80);
        border-radius: 50%;
        animation: spiralSpin 3s linear infinite;
    }
    
    @keyframes spiralSpin {
        from { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
        50% { transform: translate(-50%, -50%) rotate(180deg) scale(1.2); }
        to { transform: translate(-50%, -50%) rotate(360deg) scale(1); }
    }
    
    .paradox-text {
        color: #00ff00;
        font-size: 1.2rem;
        text-align: center;
        margin: 2rem;
        animation: textFlicker 2s infinite alternate;
        max-width: 600px;
        position: relative;
    }
    
    @keyframes textFlicker {
        0% { opacity: 0.5; transform: skew(-2deg) scale(0.98); }
        100% { opacity: 1; transform: skew(2deg) scale(1.02); }
    }
    
    .floating-elements {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 1;
    }
    
    .floating-shape {
        position: absolute;
        animation: float 15s infinite linear;
        font-size: 2rem;
        filter: drop-shadow(0 0 10px currentColor);
    }
    
    @keyframes float {
        from { 
            transform: translateY(100vh) rotate(0deg) scale(1); 
            opacity: 0;
        }
        10% { opacity: 1; }
        90% { opacity: 1; }
        to { 
            transform: translateY(-100px) rotate(360deg) scale(1.5); 
            opacity: 0;
        }
    }
    
    .shape1 { left: 10%; animation-delay: 0s; color: #ff0066; }
    .shape2 { left: 30%; animation-delay: 3s; color: #6600ff; }
    .shape3 { left: 50%; animation-delay: 6s; color: #00ff66; }
    .shape4 { left: 70%; animation-delay: 9s; color: #ffff00; }
    .shape5 { left: 90%; animation-delay: 12s; color: #00ffff; }
    
    .impossible-object {
        width: 200px;
        height: 200px;
        margin: 2rem;
        border: 5px solid #ff4444;
        transform-style: preserve-3d;
        animation: impossibleRotate 8s infinite ease-in-out;
        position: relative;
        background: linear-gradient(45deg, transparent 30%, rgba(255,68,68,0.1) 70%);
    }
    
    .impossible-object::before {
        content: '';
        position: absolute;
        top: 20px;
        left: 20px;
        right: 20px;
        bottom: 20px;
        border: 3px solid #44ff44;
        animation: impossibleRotate 6s infinite ease-in-out reverse;
    }
    
    .impossible-object::after {
        content: '';
        position: absolute;
        top: 40px;
        left: 40px;
        right: 40px;
        bottom: 40px;
        border: 2px solid #4444ff;
        animation: impossibleRotate 4s infinite ease-in-out;
    }
    
    @keyframes impossibleRotate {
        0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
        25% { transform: rotateX(90deg) rotateY(90deg) rotateZ(45deg); }
        50% { transform: rotateX(180deg) rotateY(180deg) rotateZ(90deg); }
        75% { transform: rotateX(270deg) rotateY(270deg) rotateZ(135deg); }
        100% { transform: rotateX(360deg) rotateY(360deg) rotateZ(180deg); }
    }
    
    .clicking-challenge {
        background: linear-gradient(45deg, #ff0066, #6600ff);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 1.1rem;
        font-family: 'Orbitron', monospace;
        border-radius: 25px;
        cursor: pointer;
        animation: buttonPulse 1s infinite alternate;
        margin: 1rem;
        box-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
        position: relative;
        overflow: hidden;
    }
    
    .clicking-challenge::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
        animation: buttonShine 2s infinite;
    }
    
    @keyframes buttonShine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
    @keyframes buttonPulse {
        from { transform: scale(1) rotate(0deg); }
        to { transform: scale(1.1) rotate(1deg); }
    }
    
    .click-counter {
        color: #ffff00;
        font-size: 1.5rem;
        margin: 1rem;
        animation: counterGlow 2s infinite alternate;
        text-align: center;
    }
    
    @keyframes counterGlow {
        from { 
            text-shadow: 0 0 10px #ffff00; 
            transform: scale(1);
        }
        to { 
            text-shadow: 0 0 30px #ffff00, 0 0 40px #ffff00; 
            transform: scale(1.05);
        }
    }
    
    .warning {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 0.9rem;
        animation: warningBlink 1s infinite;
        z-index: 1000;
    }
    
    @keyframes warningBlink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.3; }
    }
    
    .fake-loading-bar {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: rgba(0,0,0,0.5);
        z-index: 1001;
    }
    
    .fake-loading-progress {
        height: 100%;
        background: linear-gradient(90deg, #ff0066, #00ff66, #0066ff, #ff0066);
        background-size: 200% 100%;
        animation: loadingProgress 8s infinite, loadingShine 2s infinite;
        width: 0%;
    }
    
    @keyframes loadingProgress {
        0% { width: 0%; }
        20% { width: 30%; }
        40% { width: 65%; }
        60% { width: 85%; }
        80% { width: 95%; }
        90% { width: 99%; }
        95% { width: 99.9%; }
        100% { width: 0%; }
    }
    
    @keyframes loadingShine {
        0% { background-position: 0% 50%; }
        100% { background-position: 200% 50%; }
    }
    
    .screen-shake {
        animation: screenShake 0.1s;
    }
    
    @keyframes screenShake {
        0%, 100% { transform: translate(0px, 0px); }
        10% { transform: translate(-2px, -1px); }
        20% { transform: translate(2px, 1px); }
        30% { transform: translate(-1px, 2px); }
        40% { transform: translate(1px, -1px); }
        50% { transform: translate(-2px, 2px); }
        60% { transform: translate(2px, -2px); }
        70% { transform: translate(-1px, 1px); }
        80% { transform: translate(1px, -2px); }
        90% { transform: translate(-2px, 1px); }
    }
    
    .notification {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 20px;
        border-radius: 10px;
        border: 2px solid #ff0066;
        z-index: 1002;
        animation: notificationPulse 0.5s ease-out;
        pointer-events: none;
    }
    
    @keyframes notificationPulse {
        0% { transform: translate(-50%, -50%) scale(0); }
        50% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .hidden-message {
        position: absolute;
        color: rgba(255, 255, 255, 0.01);
        font-size: 1px;
        pointer-events: none;
        user-select: none;
    }
</style>
```

</head>
<body>
    <div class="matrix-rain" id="matrixRain"></div>

```
<div class="fake-loading-bar">
    <div class="fake-loading-progress"></div>
</div>

<div class="custom-cursor" id="customCursor"></div>

<div class="tetris-background" id="tetrisBackground">
    <div class="tetris-grid" id="tetrisGrid"></div>
</div>

<div class="dvd-logo" id="dvdLogo">BEFUDDLE</div>

<div class="floating-elements">
    <div class="floating-shape shape1">🌀</div>
    <div class="floating-shape shape2">🔮</div>
    <div class="floating-shape shape3">👁️</div>
    <div class="floating-shape shape4">🌟</div>
    <div class="floating-shape shape5">❓</div>
    <div class="floating-shape" style="left: 15%; animation-delay: 1s; color: #ff9900;">🤯</div>
    <div class="floating-shape" style="left: 35%; animation-delay: 4s; color: #9900ff;">🎭</div>
    <div class="floating-shape" style="left: 55%; animation-delay: 7s; color: #ff0099;">🎪</div>
    <div class="floating-shape" style="left: 75%; animation-delay: 10s; color: #00ff99;">🎨</div>
    <div class="floating-shape" style="left: 85%; animation-delay: 13s; color: #9999ff;">🎯</div>
</div>

<div class="container">
    <h1 class="title" data-text="THE ETERNAL BEFUDDLEMENT MACHINE">THE ETERNAL BEFUDDLEMENT MACHINE</h1>
    
    <div class="optical-illusion">
        <div class="spiral"></div>
    </div>
    
    <div class="paradox-text" id="paradoxText">
        This statement is false. If you can read this, you're not reading this. 
        The following sentence is true. The previous sentence is false.
    </div>
    
    <div class="impossible-object"></div>
    
    <button class="clicking-challenge" onclick="handleClick()">
        DON'T CLICK ME
    </button>
    
    <div class="click-counter">
        Clicks: <span id="clickCount">0</span> | Time Wasted: <span id="timeWasted">0</span>s | Confusion Level: <span id="confusionLevel">MINIMAL</span>
    </div>
    
    <div class="paradox-text">
        You are now manually breathing. You are also manually blinking. 
        Your tongue doesn't fit comfortably in your mouth.
    </div>
</div>

<div class="warning">
    ⚠️ WARNING: Extended exposure may cause existential confusion ⚠️
</div>

<div class="hidden-message">
    You found the hidden message! But this message doesn't exist. 
    If you're reading this, you're not reading this. Congratulations on finding nothing!
    The cake is a lie. The spoon does not exist. There is no Matrix.
    You are not the chosen one. This is not a simulation. Wake up, Neo... just kidding, there's no escape.
</div>

<script>
    let clickCount = 0;
    let startTime = Date.now();
    let confusionMultiplier = 1;
    let cursorTrails = [];
    
    const paradoxes = [
        "This statement is false. If you can read this, you're not reading this.",
        "Can an omnipotent being create a stone so heavy they cannot lift it?",
        "If Pinocchio says 'My nose will grow now,' what happens?",
        "What happens when an unstoppable force meets an immovable object?",
        "Is the set of all sets that do not contain themselves a member of itself?",
        "You are now manually breathing. Don't think about breathing.",
        "If you try to fail and succeed, which have you done?",
        "This sentence contains five words. (Actually it contains more than five.)",
        "The next statement is true. The previous statement is false.",
        "I know that I know nothing. But if I know that, do I know something?",
        "If everything is possible, is it possible for something to be impossible?",
        "Can you remember forgetting something you never knew?",
        "If time heals all wounds, what happens to the time that was wounded?",
        "Is the answer to this question no?",
        "If you're not part of the solution, are you part of the precipitate?",
        "Why do we park in driveways and drive on parkways?",
        "If you're unique, just like everyone else, how unique are you really?",
        "Can you have déjà vu about having déjà vu?",
        "If you expect the unexpected, doesn't that make the unexpected expected?",
        "Are you reading this, or is this reading you?"
    ];
    
    const confusionLevels = [
        "MINIMAL", "SLIGHT", "MODERATE", "HIGH", "SEVERE", 
        "CRITICAL", "MAXIMUM", "OVERFLOW", "ERROR", "UNDEFINED", 
        "∞", "NULL", "404", "BLUE SCREEN", "PARADOX"
    ];
    
    const notifications = [
        "Reality.exe has stopped working",
        "Your brain has encountered an error",
        "Logic not found",
        "Sanity.dll is missing",
        "Press F to pay respects to your confusion",
        "You are the 1,000,000th confused visitor!",
        "Congratulations! You've achieved peak bewilderment!",
        "Warning: Your reality subscription has expired",
        "404: Sense not found",
        "Your confusion level is over 9000!"
    ];
    
    // Matrix Rain Effect
    function createMatrixRain() {
        const matrixContainer = document.getElementById('matrixRain');
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
        
        for (let i = 0; i < 50; i++) {
            const column = document.createElement('div');
            column.className = 'matrix-column';
            column.style.left = Math.random() * 100 + 'vw';
            column.style.animationDuration = (Math.random() * 3 + 2) + 's';
            column.style.animationDelay = Math.random() * 2 + 's';
            
            let columnText = '';
            for (let j = 0; j < 20; j++) {
                columnText += characters[Math.floor(Math.random() * characters.length)] + '\n';
            }
            column.textContent = columnText;
            
            matrixContainer.appendChild(column);
            
            // Remove and recreate columns periodically
            setTimeout(() => {
                if (column.parentNode) {
                    column.parentNode.removeChild(column);
                }
            }, Math.random() * 10000 + 5000);
        }
    }
    
    // DVD Logo Bouncer
    class DVDBouncer {
        constructor() {
            this.element = document.getElementById('dvdLogo');
            this.x = Math.random() * (window.innerWidth - 80);
            this.y = Math.random() * (window.innerHeight - 40);
            this.vx = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 2 + 1);
            this.vy = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 2 + 1);
            this.colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff0000', '#00ff00', '#0000ff'];
            this.colorIndex = 0;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            
            if (this.x <= 0 || this.x >= window.innerWidth - 80) {
                this.vx = -this.vx;
                this.changeColor();
                this.triggerCornerEffect();
            }
            
            if (this.y <= 0 || this.y >= window.innerHeight - 40) {
                this.vy = -this.vy;
                this.changeColor();
                this.triggerCornerEffect();
            }
            
            this.element.style.left = this.x + 'px';
            this.element.style.top = this.y + 'px';
        }
        
        changeColor() {
            this.colorIndex = (this.colorIndex + 1) % this.colors.length;
            this.element.style.background = `linear-gradient(45deg, ${this.colors[this.colorIndex]}, ${this.colors[(this.colorIndex + 1) % this.colors.length]})`;
        }
        
        triggerCornerEffect() {
            if ((this.x <= 5 || this.x >= window.innerWidth - 85) && 
                (this.y <= 5 || this.y >= window.innerHeight - 45)) {
                document.body.classList.add('screen-shake');
                setTimeout(() => document.body.classList.remove('screen-shake'), 100);
                showNotification("DVD LOGO HIT THE CORNER! REALITY IS BREAKING!");
            }
        }
    }
    
    const dvdBouncer = new DVDBouncer();
    
    // Tetris Game Logic
    class TetrisGame {
        constructor() {
            this.grid = Array(20).fill().map(() => Array(10).fill(0));
            this.colors = [
                '#ff0066', '#6600ff', '#00ff66', '#ff6600', 
                '#0066ff', '#ff0000', '#ffff00', '#00ffff'
            ];
            this.currentPiece = null;
            this.currentX = 4;
            this.currentY = 0;
            this.gameSpeed = 600;
            this.lastMoveTime = 0;
            
            this.pieces = [
                [[1,1,1,1]], // I
                [[1,1],[1,1]], // O
                [[0,1,0],[1,1,1]], // T
                [[1,0,0],[1,1,1]], // L
                [[0,0,1],[1,1,1]], // J
                [[0,1,1],[1,1,0]], // S
                [[1,1,0],[0,1,1]]  // Z
            ];
            
            this.initGrid();
            this.spawnPiece();
        }
        
        initGrid() {
            const grid = document.getElementById('tetrisGrid');
            if (!grid) return;
            grid.innerHTML = '';
            for (let i = 0; i < 200; i++) {
                const cell = document.createElement('div');
                cell.className = 'tetris-cell';
                grid.appendChild(cell);
            }
        }
        
        spawnPiece() {
            const pieceIndex = Math.floor(Math.random() * this.pieces.length);
            this.currentPiece = JSON.parse(JSON.stringify(this.pieces[pieceIndex]));
            this.currentX = Math.floor((10 - this.currentPiece[0].length) / 2);
            this.currentY = 0;
            this.currentColor = this.colors[pieceIndex];
        }
        
        canMove(piece, x, y) {
            for (let py = 0; py < piece.length; py++) {
                for (let px = 0; px < piece[py].length; px++) {
                    if (piece[py][px]) {
                        const newX = x + px;
                        const newY = y + py;
                        
                        if (newX < 0 || newX >= 10 || newY >= 20) return false;
                        if (newY >= 0 && this.grid[newY][newX]) return false;
                    }
                }
            }
            return true;
        }
        
        placePiece() {
            for (let py = 0; py < this.currentPiece.length; py++) {
                for (let px = 0; px < this.currentPiece[py].length; px++) {
                    if (this.currentPiece[py][px]) {
                        const gridY = this.currentY + py;
                        const gridX = this.currentX + px;
                        if (gridY >= 0 && gridY < 20 && gridX >= 0 && gridX < 10) {
                            this.grid[gridY][gridX] = this.currentColor;
                        }
                    }
                }
            }
        }
        
        clearLines() {
            let linesCleared = 0;
            for (let y = 19; y >= 0; y--) {
                if (this.grid[y].every(cell => cell !== 0)) {
                    this.grid.splice(y, 1);
                    this.grid.unshift(Array(10).fill(0));
                    y++; // Check the same line again
                    linesCleared++;
                }
            }
            if (linesCleared > 0) {
                confusionMultiplier += 0.1;
            }
        }
        
        update(currentTime) {
            if (currentTime - this.lastMoveTime > this.gameSpeed) {
                if (this.canMove(this.currentPiece, this.currentX, this.currentY + 1)) {
                    this.currentY++;
                } else {
                    this.placePiece();
                    this.clearLines();
                    this.spawnPiece();
                    
                    // Check game over
                    if (!this.canMove(this.currentPiece, this.currentX, this.currentY)) {
                        this.reset();
                    }
                }
                this.lastMoveTime = currentTime;
            }
            
            // Chaotic AI behavior
            if (Math.random() < 0.03) {
                const direction = Math.random() < 0.5 ? -1 : 1;
                if (this.canMove(this.currentPiece, this.currentX + direction, this.currentY)) {
                    this.currentX += direction;
                }
            }
            
            if (Math.random() < 0.02) {
                const rotated = this.rotatePiece(this.currentPiece);
                if (this.canMove(rotated, this.currentX, this.currentY)) {
                    this.currentPiece = rotated;
                }
            }
            
            this.render();
        }
        
        rotatePiece(piece) {
            const rows = piece.length;
            const cols = piece[0].length;
            const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    rotated[x][rows - 1 - y] = piece[y][x];
                }
            }
            return rotated;
        }
        
        render() {
            const cells = document.querySelectorAll('.tetris-cell');
            
            // Clear all cells
            cells.forEach(cell => {
                cell.classList.remove('filled');
                cell.style.setProperty('--cell-color', 'transparent');
            });
            
            // Render placed pieces
            for (let y = 0; y < 20; y++) {
                for (let x = 0; x < 10; x++) {
                    if (this.grid[y][x]) {
                        const index = y * 10 + x;
                        if (cells[index]) {
                            cells[index].classList.add('filled');
                            cells[index].style.setProperty('--cell-color', this.grid[y][x]);
                        }
                    }
                }
            }
            
            // Render current piece
            if (this.currentPiece) {
                for (let py = 0; py < this.currentPiece.length; py++) {
                    for (let px = 0; px < this.currentPiece[py].length; px++) {
                        if (this.currentPiece[py][px]) {
                            const gridX = this.currentX + px;
                            const gridY = this.currentY + py;
                            if (gridY >= 0 && gridY < 20 && gridX >= 0 && gridX < 10) {
                                const index = gridY * 10 + gridX;
                                if (cells[index]) {
                                    cells[index].classList.add('filled');
                                    cells[index].style.setProperty('--cell-color', this.currentColor);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        reset() {
            this.grid = Array(20).fill().map(() => Array(10).fill(0));
            this.spawnPiece();
            showNotification("Tetris Reset! Your confusion continues...");
        }
    }
    
    // Initialize systems
    const tetris = new TetrisGame();
    createMatrixRain();
    
    // Cursor trail system
    function createCursorTrail(x, y) {
        const trail = document.createElement('div');
        trail.className = 'cursor-trail';
        trail.style.left = x + 'px';
        trail.style.top = y + 'px';
        document.body.appendChild(trail);
        
        cursorTrails.push(trail);
        
        setTimeout(() => {
            if (trail.parentNode) {
                trail.parentNode.removeChild(trail);
            }
            cursorTrails = cursorTrails.filter(t => t !== trail);
        }, 500);
        
        // Animate trail
        let opacity = 0.8;
        const fade = setInterval(() => {
            opacity -= 0.1;
            trail.style.opacity = opacity;
            if (opacity <= 0) {
                clearInterval(fade);
            }
        }, 50);
    }
    
    // Custom cursor tracking
    let mouseX = 0, mouseY = 0;
    document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        const cursor = document.getElementById('customCursor');
        cursor.style.left = e.clientX + 'px';
        cursor.style.top = e.clientY + 'px';
        
        // Create trail occasionally
        if (Math.random() < 0.3) {
            createCursorTrail(e.clientX, e.clientY);
        }
    });
    
    // Notification system
    function showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }
    
    // Button click handler with enhanced chaos
    function handleClick() {
        clickCount++;
        document.getElementById('clickCount').textContent = clickCount;
        
        // Update confusion level
        const levelIndex = Math.min(Math.floor(clickCount / 3), confusionLevels.length - 1);
        document.getElementById('confusionLevel').textContent = confusionLevels[levelIndex];
        
        // Enhanced button messages
        const button = document.querySelector('.clicking-challenge');
        const messages = [
            "DON'T CLICK ME",
            "I SAID DON'T CLICK",
            "WHY ARE YOU CLICKING?",
            "STOP CLICKING ME!",
            "SERIOUSLY, STOP!",
            "YOU'RE MAKING IT WORSE",
            "CLICK TO STOP CLICKING",
            "WAIT... THAT DOESN'T WORK",
            "NOW YOU'RE CONFUSED",
            "MISSION ACCOMPLISHED",
            "BUT WHY THOUGH?",
            "CLICK ADDICTION DETECTED",
            "INITIALIZING CHAOS MODE",
            "REALITY.EXE HAS CRASHED",
            "THE BUTTON CLICKED YOU",
            "CONGRATULATIONS, YOU PLAYED YOURSELF",
            "404: LOGIC NOT FOUND",
            "ENTERING INFINITE LOOP",
            "HELP I'M TRAPPED IN A BUTTON",
            "THE CLICKS... THEY DO NOTHING!",
            "YOU'VE ACHIEVED PEAK CONFUSION",
            "WELCOME TO THE MATRIX",
            "THERE IS NO BUTTON",
            "THE BUTTON IS A LIE",
            "CLICK COUNTER OVERFLOW ERROR"
        ];
        
        if (clickCount <= messages.length) {
            button.textContent = messages[clickCount - 1];
        } else {
            button.textContent = `ERROR: ${clickCount} CLICKS DETECTED`;
        }
        
        // Random visual chaos
        const colors = ['#ff0066', '#6600ff', '#00ff66', '#ff6600', '#0066ff', '#ff0000', '#ffff00', '#00ffff'];
        button.style.background = `linear-gradient(${Math.random() * 360}deg, ${colors[Math.floor(Math.random() * colors.length)]}, ${colors[Math.floor(Math.random() * colors.length)]})`;
        
        // Trigger various chaos effects
        if (clickCount % 5 === 0) {
            document.body.classList.add('screen-shake');
            setTimeout(() => document.body.classList.remove('screen-shake'), 200);
        }
        
        if (clickCount % 7 === 0) {
            showNotification(notifications[Math.floor(Math.random() * notifications.length)]);
        }
        
        if (clickCount % 10 === 0) {
            // Temporarily invert colors
            document.body.style.filter = 'invert(1) hue-rotate(180deg)';
            setTimeout(() => {
                document.body.style.filter = 'none';
            }, 1000);
        }
        
        if (clickCount % 15 === 0) {
            // Create more floating elements
            for (let i = 0; i < 5; i++) {
                const newShape = document.createElement('div');
                newShape.className = 'floating-shape';
                newShape.textContent = ['🤪', '🙃', '🤔', '😵‍💫', '🤯'][Math.floor(Math.random() * 5)];
                newShape.style.left = Math.random() * 100 + '%';
                newShape.style.color = colors[Math.floor(Math.random() * colors.length)];
                document.querySelector('.floating-elements').appendChild(newShape);
                
                setTimeout(() => {
                    if (newShape.parentNode) {
                        newShape.parentNode.removeChild(newShape);
                    }
                }, 15000);
            }
        }
        
        // Increase global confusion
        confusionMultiplier += 0.05;
    }
    
    // Time counter with confusion bonus
    setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById('timeWasted').textContent = Math.floor(elapsed * confusionMultiplier);
    }, 1000);
    
    // Paradox text rotation with enhanced chaos
    setInterval(() => {
        const textElement = document.getElementById('paradoxText');
        const newParadox = paradoxes[Math.floor(Math.random() * paradoxes.length)];
        textElement.textContent = newParadox;
        
        // Occasionally make text do weird things
        if (Math.random() < 0.1) {
            textElement.style.transform = `rotate(${Math.random() * 360}deg) scale(${0.5 + Math.random()})`;
            setTimeout(() => {
                textElement.style.transform = 'none';
            }, 2000);
        }
    }, 3000 / confusionMultiplier);
    
    // Random page effects
    setInterval(() => {
        if (Math.random() < 0.05 * confusionMultiplier) {
            document.body.classList.add('screen-shake');
            setTimeout(() => {
                document.body.classList.remove('screen-shake');
            }, 100);
        }
        
        // Random cursor changes
        if (Math.random() < 0.02) {
            const cursors = ['none', 'wait', 'not-allowed', 'grab', 'zoom-in', 'crosshair'];
            document.body.style.cursor = cursors[Math.floor(Math.random() * cursors.length)];
            setTimeout(() => {
                document.body.style.cursor = 'none';
            }, 2000);
        }
    }, 1000);
    
    // Enhanced click anywhere chaos
    document.addEventListener('click', (e) => {
        if (Math.random() < 0.2 * confusionMultiplier && !e.target.classList.contains('clicking-challenge')) {
            handleClick();
        }
        
        // Create explosion effect
        for (let i = 0; i < 10; i++) {
            const spark = document.createElement('div');
            spark.style.position = 'fixed';
            spark.style.left = e.clientX + 'px';
            spark.style.top = e.clientY + 'px';
            spark.style.width = '4px';
            spark.style.height = '4px';
            spark.style.background = ['#ff0066', '#00ff66', '#0066ff', '#ffff00'][Math.floor(Math.random() * 4)];
            spark.style.pointerEvents = 'none';
            spark.style.zIndex = '9999';
            document.body.appendChild(spark);
            
            const angle = (Math.PI * 2 * i) / 10;
            const velocity = 50 + Math.random() * 100;
            let x = e.clientX;
            let y = e.clientY;
            
            const animate = () => {
                x += Math.cos(angle) * velocity * 0.02;
                y += Math.sin(angle) * velocity * 0.02;
                velocity *= 0.98;
                
                spark.style.left = x + 'px';
                spark.style.top = y + 'px';
                spark.style.opacity = velocity / 150;
                
                if (velocity > 1) {
                    requestAnimationFrame(animate);
                } else {
                    if (spark.parentNode) {
                        spark.parentNode.removeChild(spark);
                    }
                }
            };
            requestAnimationFrame(animate);
        }
    });
    
    // Konami code with enhanced easter egg
    let konamiCode = [];
    const konamiSequence = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
    
    document.addEventListener('keydown', (e) => {
        konamiCode.push(e.code);
        if (konamiCode.length > 10) konamiCode.shift();
        
        if (konamiCode.join(',') === konamiSequence.join(',')) {
            showNotification('🎉 ULTRA CONFUSION MODE ACTIVATED! 🎉');
            confusionMultiplier *= 2;
            
            // Ultimate chaos mode
            document.body.style.animation = 'gradientShift 1s ease infinite';
            
            // Spawn many more matrix columns
            for (let i = 0; i < 100; i++) {
                setTimeout(() => createMatrixRain(), i * 100);
            }
            
            // Make everything spin
            document.querySelector('.container').style.animation = 'rotate360 10s linear infinite';
            
            setTimeout(() => {
                document.body.style.animation = 'gradientShift 8s ease infinite';
                document.querySelector('.container').style.animation = 'none';
            }, 10000);
        }
    });
    
    // Main game loop
    function gameLoop(currentTime) {
        tetris.update(currentTime);
        dvdBouncer.update();
        requestAnimationFrame(gameLoop);
    }
    
    // Refresh matrix rain periodically
    setInterval(createMatrixRain, 5000);
    
    // Start the madness
    requestAnimationFrame(gameLoop);
    
    // Secret hidden interactions
    let secretCounter = 0;
    document.addEventListener('keypress', (e) => {
        if (e.key === 'h' && e.ctrlKey) {
            secretCounter++;
            if (secretCounter >= 3) {
                showNotification("You found the secret! But secrets don't exist in a world without logic...");
                // Make hidden message briefly visible
                const hiddenMsg = document.querySelector('.hidden-message');
                hiddenMsg.style.color = 'rgba(255, 255, 255, 0.8)';
                hiddenMsg.style.fontSize = '14px';
                setTimeout(() => {
                    hiddenMsg.style.color = 'rgba(255, 255, 255, 0.01)';
                    hiddenMsg.style.fontSize = '1px';
                }, 3000);
            }
        }
    });
    
    // Final layer of confusion - make some elements lie about their state
    setInterval(() => {
        if (Math.random() < 0.1) {
            const fakeCount = Math.floor(Math.random() * 999999);
            document.getElementById('clickCount').textContent = fakeCount;
            setTimeout(() => {
                document.getElementById('clickCount').textContent = clickCount;
            }, 500);
        }
    }, 10000);
</script>
```

</body>
</html>